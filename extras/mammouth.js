/**
 * Mammouth Compiler v3.0.0
 * http://mammouth.wamalaka.com
 *
 * Copyright 2015, Wael Boutglay
 * Released under the MIT License
 */
(function(root) {
function require(path){ return require[path]; }
require["./parser"] = (function() {var exports = {}, module = {exports: exports};return exports;})();
require["./utils"] = (function() {var exports = {}, module = {exports: exports};// Generated by CoffeeScript 1.9.3
(function() {
  var IndentGenerator, nodes;

  nodes = require('./nodes');

  exports.errorAt = function(input, pos) {
    var i, j, ref, res;
    res = input.split("\n")[pos.row - 1];
    res += '\n';
    for (i = j = 0, ref = pos.col; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      res += '^';
    }
    return res;
  };

  exports.IndentGenerator = IndentGenerator = (function() {
    function IndentGenerator(indent) {
      this.indent = indent != null ? indent : '  ';
      this.level = 0;
    }

    IndentGenerator.prototype.get = function(num) {
      var i, j, ref, res;
      if (num == null) {
        num = this.level;
      }
      res = '';
      for (i = j = 0, ref = num; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        res += this.indent;
      }
      return res;
    };

    IndentGenerator.prototype.up = function() {
      return this.level++;
    };

    IndentGenerator.prototype.down = function() {
      return this.level--;
    };

    return IndentGenerator;

  })();

}).call(this);
return exports;})();
require["./lexer"] = (function() {var exports = {}, module = {exports: exports};// Generated by CoffeeScript 1.9.3
(function() {
  var KEYWORDS, Lexer, Position, REGEX, Token, errorAt,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  errorAt = require('./utils').errorAt;

  Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.setInput = function(input) {
      this.yytext = '';
      this.track = {
        position: new Position,
        into: {
          mammouth: false
        },
        opened: []
      };
      this.tokens = [];
      this.pos = 0;
      return this.input = input.replace(/\r\n/g, '\n');
    };

    Lexer.prototype.addToken = function(tokens) {
      var j, len, ref, token;
      if (tokens instanceof Array) {
        for (j = 0, len = tokens.length; j < len; j++) {
          token = tokens[j];
          if ((ref = token.type) === 'INDENT' || ref === 'MINDENT' || ref === 'LINETERMINATOR') {
            this.track.into["for"] = false;
          }
          this.tokens.push(token);
        }
      } else {
        this.tokens.push(tokens);
      }
      return tokens;
    };

    Lexer.prototype.addIndentLevel = function() {
      return this.track.opened.unshift({
        type: 'IndentLevel',
        indentStack: [],
        currentIndent: -1,
        openedIndent: 0
      });
    };

    Lexer.prototype.getPos = function() {
      return this.track.position.clone();
    };

    Lexer.prototype.posAdvance = function(string, incPos) {
      var i, j, len, line, lines, results;
      if (incPos == null) {
        incPos = true;
      }
      if (incPos) {
        this.pos += string.length;
      }
      lines = string.split(REGEX.LINETERMINATOR);
      results = [];
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        if (i === 0) {
          results.push(this.track.position.col += string.length);
        } else {
          this.track.position.row++;
          results.push(this.track.position.col = line.length);
        }
      }
      return results;
    };

    Lexer.prototype.colAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      return this.track.position.col += num;
    };

    Lexer.prototype.rowAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      this.track.position.row += num;
      return this.track.position.col = 0;
    };

    Lexer.prototype.last = function(num) {
      if (num == null) {
        num = 1;
      }
      if (this.tokens[this.tokens.length - num]) {
        return this.tokens[this.tokens.length - num];
      }
      return void 0;
    };

    Lexer.prototype.next = function(num) {
      var lexer;
      if (num == null) {
        num = 1;
      }
      lexer = new Lexer;
      lexer.track = JSON.parse(JSON.stringify(this.track));
      lexer.track.position = this.track.position.clone();
      lexer.tokens = JSON.parse(JSON.stringify(this.tokens));
      lexer.pos = this.pos;
      lexer.input = this.input;
      while (num > 0) {
        lexer.nextToken();
        num--;
      }
      return lexer.tokens[lexer.tokens.length - 1];
    };

    Lexer.prototype.charCode = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.charCodeAt(pos);
    };

    Lexer.prototype.currentIndentTracker = function() {
      var ele, j, len, ref;
      ref = this.track.opened;
      for (j = 0, len = ref.length; j < len; j++) {
        ele = ref[j];
        if (ele.type === 'IndentLevel') {
          return ele;
        }
      }
    };

    Lexer.prototype.lex = function() {
      var token;
      if (!this.lexed) {
        this.tokenize();
      }
      token = this.tokens.shift();
      if (token) {
        this.yytext = token.value ? token.value : '';
        this.yylloc = {
          first_column: token.location.start.col,
          first_line: token.location.start.row,
          last_line: token.location.end.row,
          last_column: token.location.end.col
        };
        return token.type;
      }
    };

    Lexer.prototype.tokenize = function() {
      var m;
      m = 0;
      while (m !== void 0) {
        m = this.nextToken();
      }
      this.rewrite();
      this.lexed = true;
      return this.tokens;
    };

    Lexer.prototype.nextToken = function() {
      if (this.pos === this.input.length) {
        return void 0;
      }
      if (!this.track.into.mammouth) {
        return this.readTokenRAW();
      }
      if (this.isStartTag()) {
        return this.readTokenStartTag();
      }
      if (this.isEndTag()) {
        return this.readTokenEndTag();
      }
      if (this.last().type === 'LINETERMINATOR' && this.isEmptyLines()) {
        return this.skipEmptyLines();
      }
      if (this.last().type === 'LINETERMINATOR' && this.isIndent()) {
        this.tokens.pop();
        return this.readIndent();
      }
      if (this.isComment()) {
        return this.skipComment();
      }
      if (this.isQualifiedString()) {
        return this.readTokenQualifiedString();
      }
      if (this.isIdentifier()) {
        return this.readTokenIdentifier();
      }
      if (this.isNumber()) {
        return this.readTokenNumber();
      }
      if (this.isString()) {
        return this.readTokenString();
      }
      if (this.isHereDoc()) {
        return this.readTokenHereDoc();
      }
      return this.getTokenFromCode(this.charCode());
    };

    Lexer.prototype.readTokenRAW = function() {
      var startPos, token, value;
      token = (new Token('RAW')).setStart(this.getPos());
      startPos = this.pos;
      while (this.pos < this.input.length && !this.isStartTag()) {
        this.pos++;
      }
      if (this.isStartTag()) {
        this.track.into.mammouth = true;
      }
      value = this.input.slice(startPos, this.pos);
      this.posAdvance(value, false);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenStartTag = function() {
      var token;
      token = (new Token('{{')).setStart(this.getPos());
      this.colAdvance(2);
      this.track.opened.unshift({
        type: '{{',
        closableBy: '}}'
      });
      this.addIndentLevel();
      return this.addToken(token.setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenEndTag = function() {
      var token, tokens;
      token = (new Token('}}')).setStart(this.getPos());
      this.colAdvance(2);
      token.setEnd(this.getPos());
      this.track.into.mammouth = false;
      tokens = this.closeIndent(this.currentIndentTracker(), token.location);
      this.closeIndentLevel();
      if (this.track.opened[0].type === '{{') {
        this.track.opened.shift();
        tokens = tokens.concat(token);
      }
      return this.addToken(tokens);
    };

    Lexer.prototype.readIndent = function() {
      var indent, indentLevel, indentTracker, j, len, reversed, token, tokens;
      token = (new Token).setStart(this.getPos());
      indent = this.input.slice(this.pos).match(REGEX.INDENT)[0];
      this.colAdvance(indent.length);
      token.setEnd(this.getPos());
      indentTracker = this.currentIndentTracker();
      if (indent.length > indentTracker.currentIndent) {
        indentTracker.currentIndent = indent.length;
        indentTracker.openedIndent++;
        indentTracker.indentStack.push({
          length: indent.length
        });
        return this.addToken(token.set('type', 'INDENT').set('length', indent.length));
      } else if (indent.length === indentTracker.currentIndent) {
        if (this.last().type === 'MINDENT') {
          return this.nextToken();
        }
        return this.addToken(token.set('type', 'MINDENT').set('length', indent.length));
      } else {
        tokens = [];
        reversed = this.reversedIndentStack(indentTracker);
        for (j = 0, len = reversed.length; j < len; j++) {
          indentLevel = reversed[j];
          if (indent.length === indentLevel.length) {
            indentTracker.currentIndent = indent.length;
            tokens.push(new Token('MINDENT', token.location, {
              length: indent.length
            }));
          } else if (indent.length < indentLevel.length) {
            indentTracker.currentIndent = indentTracker.indentStack.pop().length;
            indentTracker.openedIndent--;
            tokens.push(new Token('OUTDENT', token.location, {
              length: indentLevel.length
            }));
          }
        }
        return this.addToken(tokens);
      }
    };

    Lexer.prototype.readTokenIdentifier = function() {
      var indentTracker, length, ref, ref1, ref2, res, startPos, token, value;
      startPos = this.getPos();
      token = (new Token).setStart(startPos);
      value = this.input.slice(this.pos).match(REGEX.IDENTIFIER)[0];
      this.colAdvance(value.length);
      token.setEnd(this.getPos());
      if (ref = value.toUpperCase(), indexOf.call(KEYWORDS.BOOL, ref) >= 0) {
        return this.addToken(token.set('type', 'BOOL').set('value', value));
      }
      if (indexOf.call(KEYWORDS.LOGIC, value) >= 0) {
        return this.addToken(token.set('type', 'LOGIC')).set('value', value === 'and' ? '&&' : value === 'or' ? '||' : value);
      }
      if (indexOf.call(KEYWORDS.COMPARE, value) >= 0) {
        return this.addToken(token.set('type', 'COMPARE')).set('value', value === 'is' ? '===' : value === 'isnt' ? '!=' : value);
      }
      if (this.last().type === '=>' && indexOf.call(KEYWORDS.CASTTYPE, value) >= 0) {
        return this.addToken(token.set('type', 'CASTTYPE').set('value', value));
      }
      if (indexOf.call(KEYWORDS.RESERVED, value) >= 0) {
        if (value === 'cte' || value === 'const') {
          return this.addToken(token.set('type', 'CONST'));
        }
        if ((value === 'if' || value === 'unless') && !((ref1 = this.last().type) === 'INDENT' || ref1 === 'MINDENT' || ref1 === 'OUTDENT' || ref1 === '(' || ref1 === 'CALL_START' || ref1 === ',' || ref1 === 'ELSE' || ref1 === '=' || ref1 === 'ASSIGN')) {
          return this.addToken(token.set('type', 'POST_IF')).set('value', value === 'if' ? false : true);
        }
        if (value === 'if' || value === 'unless') {
          return this.addToken(token.set('type', 'IF')).set('value', value === 'if' ? false : true);
        }
        if (value === 'then') {
          indentTracker = this.currentIndentTracker();
          length = indentTracker.currentIndent + 1;
          indentTracker.currentIndent = length;
          indentTracker.openedIndent++;
          indentTracker.indentStack.push({
            length: length,
            sensible: true
          });
          return this.addToken(token.set('type', 'INDENT').set('length', length));
        }
        if (value === 'else') {
          res = this.closeSensibleIndent(this.currentIndentTracker(), token.location);
          return this.addToken(res.concat(token.set('type', 'ELSE')).concat(this.lookLinearBlock(token.location, 'ELSE')));
        }
        if (value === 'try') {
          return this.addToken([].concat(token.set('type', 'TRY')).concat(this.lookLinearBlock(token.location)));
        }
        if (value === 'catch') {
          res = this.closeSensibleIndent(this.currentIndentTracker(), token.location);
          return this.addToken(res.concat(token.set('type', 'CATCH')));
        }
        if (value === 'finally') {
          res = this.closeSensibleIndent(this.currentIndentTracker(), token.location);
          return this.addToken(res.concat(token.set('type', 'FINALLY')).concat(this.lookLinearBlock(token.location)));
        }
        if (value === 'for') {
          this.track.into["for"] = true;
        }
        if ((value === 'of' || value === 'in') && this.track.into["for"]) {
          this.track.into["for"] = false;
          return this.addToken(token.set('type', 'FOR' + value.toUpperCase()));
        }
        if ((value === 'when' && ((ref2 = this.last().type) === 'INDENT' || ref2 === 'MINDENT' || ref2 === 'OUTDENT')) || value === 'case') {
          return this.addToken(token.set('type', 'LEADING_WHEN'));
        }
        return this.addToken(token.set('type', value.toUpperCase()));
      }
      if (indexOf.call(KEYWORDS.PHPRESERVED, value) >= 0) {
        throw ("Unexpected, PHP reserved words can't be identifier at line " + startPos.row + ", col " + startPos.col + ":\n") + errorAt(this.input, startPos);
      }
      return this.addToken(token.set('type', 'IDENTIFIER').set('value', value));
    };

    Lexer.prototype.readTokenNumber = function() {
      var token, value;
      token = (new Token('NUMBER')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.NUMBER)[0];
      this.colAdvance(value.length);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenString = function() {
      var token, value;
      token = (new Token('STRING')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.STRING)[0];
      this.posAdvance(value);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenHereDoc = function() {
      var token, value;
      token = (new Token('HEREDOC')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.HEREDOC)[0];
      this.posAdvance(value);
      return this.addToken(token.set('value', value.slice(1, value.length - 1)).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenQualifiedString = function() {
      var token, value;
      token = (new Token('QUALIFIEDQTRING')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.QUALIFIEDQTRING)[0];
      this.posAdvance(value);
      return this.addToken(token.set('value', eval(value.slice(1))).setEnd(this.getPos()));
    };

    Lexer.prototype.getTokenFromCode = function(code) {
      var ref, ref1, startPos, token, tokens;
      startPos = this.getPos();
      token = (new Token).setStart(startPos);
      this.colAdvance();
      switch (code) {
        case 10:
        case 13:
        case 8232:
          this.colAdvance(-1);
          return this.readLineTerminator();
        case 32:
        case 160:
        case 5760:
        case 6158:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
          return this.nextToken();
        case 33:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'COMPARE').set('value', '!=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'NOT').setEnd(this.getPos()));
        case 37:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '%=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '%').setEnd(this.getPos()));
        case 38:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '&=').setEnd(this.getPos()));
          }
          if (this.charCode() === 38) {
            this.colAdvance();
            return this.addToken(token.set('type', 'LOGIC').set('value', '&&').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '&').setEnd(this.getPos()));
        case 40:
          if ((ref = this.last().type, indexOf.call(KEYWORDS.CALLABLE, ref) >= 0) && this.last(2).type !== 'FUNC') {
            this.track.opened.unshift({
              type: 'CALL_START',
              closableBy: 'CALL_END'
            });
            this.addIndentLevel();
            return this.addToken(token.set('type', 'CALL_START').setEnd(this.getPos()));
          }
          this.track.opened.unshift({
            type: '(',
            closableBy: ')'
          });
          this.addIndentLevel();
          return this.addToken(token.set('type', '(').setEnd(this.getPos()));
        case 41:
          tokens = this.closeIndent(this.currentIndentTracker(), token.location);
          this.closeIndentLevel();
          switch (this.track.opened[0].type) {
            case 'CALL_START':
              tokens = tokens.concat(token.set('type', 'CALL_END').setEnd(this.getPos()));
              this.track.opened.shift();
              break;
            case '(':
              tokens = tokens.concat(token.set('type', ')').setEnd(this.getPos()));
              this.track.opened.shift();
          }
          return this.addToken(tokens);
        case 42:
          if (this.charCode() === 42) {
            this.colAdvance();
            return this.addToken(token.set('type', '**').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '*=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '*').setEnd(this.getPos()));
        case 43:
          if (this.charCode() === 43) {
            this.colAdvance();
            return this.addToken(token.set('type', '++').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '+=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '+').setEnd(this.getPos()));
        case 44:
          return this.addToken(token.set('type', ',').setEnd(this.getPos()));
        case 45:
          if (this.charCode() === 45) {
            this.colAdvance();
            return this.addToken(token.set('type', '--').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '-=').setEnd(this.getPos()));
          }
          if (this.charCode() === 62) {
            this.colAdvance();
            tokens = [token.set('type', '->').setEnd(this.getPos())].concat(this.lookLinearBlock(token.location));
            return this.addToken(tokens);
          }
          return this.addToken(token.set('type', '-').setEnd(this.getPos()));
        case 46:
          if (this.charCode() === 46) {
            this.colAdvance();
            if (this.charCode() === 46) {
              this.colAdvance();
              if (this.charCode() === 46) {
                this.colAdvance();
                return this.addToken(token.set('type', '....').setEnd(this.getPos()));
              }
              return this.addToken(token.set('type', '...').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', '..').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '.').setEnd(this.getPos()));
        case 47:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '/=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '/').setEnd(this.getPos()));
        case 58:
          if (this.charCode() === 58) {
            this.colAdvance();
            return this.addToken(token.set('type', '::').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', ':').setEnd(this.getPos()));
        case 59:
          return this.addToken(token.set('type', ';').setEnd(this.getPos()));
        case 60:
          if (this.charCode() === 60) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '<<=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'BITWISE').set('value', '<<').setEnd(this.getPos()));
          }
          if (this.charCode() === 45 && this.charCode(this.pos + 1) === 62) {
            this.colAdvance(2);
            return this.addToken(token.set('type', 'CONCAT').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'COMPARE').set('value', '<=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'COMPARE').set('value', '<').setEnd(this.getPos()));
        case 61:
          if (this.charCode() === 62) {
            this.colAdvance();
            return this.addToken(token.set('type', '=>').setEnd(this.getPos()));
          }
          if (this.charCode() === 61 && this.charCode(this.pos + 1) === 61) {
            this.colAdvance(2);
            return this.addToken(token.set('type', 'COMPARE').set('value', '===').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'COMPARE').set('value', '==').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '=').setEnd(this.getPos()));
        case 62:
          if (this.charCode() === 62) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '>>=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'BITWISE').set('value', '>>').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'COMPARE').set('value', '>=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'COMPARE').set('value', '>').setEnd(this.getPos()));
        case 63:
          return this.addToken(token.set('type', '?').setEnd(this.getPos()));
        case 64:
          return this.addToken(token.set('type', '@').setEnd(this.getPos()));
        case 91:
          if (ref1 = this.last().type, indexOf.call(KEYWORDS.INDEXABLE, ref1) >= 0) {
            this.track.opened.unshift({
              type: 'INDEX_START',
              closableBy: 'INDEX_END'
            });
            this.addIndentLevel();
            return this.addToken(token.set('type', 'INDEX_START').setEnd(this.getPos()));
          } else {
            this.track.opened.unshift({
              type: '[',
              closableBy: ']'
            });
            this.addIndentLevel();
            return this.addToken(token.set('type', '[').setEnd(this.getPos()));
          }
          break;
        case 93:
          tokens = this.closeIndent(this.currentIndentTracker(), token.location);
          this.closeIndentLevel();
          if (this.track.opened[0].type === '[') {
            this.track.opened.shift();
            tokens = tokens.concat(token.set('type', ']').setEnd(this.getPos()));
          } else if (this.track.opened[0].type === 'INDEX_START') {
            this.track.opened.shift();
            tokens = tokens.concat(token.set('type', 'INDEX_END').setEnd(this.getPos()));
          }
          return this.addToken(tokens);
        case 94:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '^=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'BITWISE').set('value', '^').setEnd(this.getPos()));
        case 123:
          return this.addToken(token.set('type', '{').setEnd(this.getPos()));
        case 124:
          if (this.charCode() === 124) {
            this.colAdvance();
            return this.addToken(token.set('type', 'BITWISE').set('value', '||').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '|=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'BITWISE').set('value', '|').setEnd(this.getPos()));
        case 125:
          return this.addToken(token.set('type', '}').setEnd(this.getPos()));
        case 126:
          if (this.charCode() === 126) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '.=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'CONCAT').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '~').setEnd(this.getPos()));
        default:
          throw ("Unexpected caharacter at line " + startPos.row + ", col " + startPos.col + ":\n") + errorAt(this.input, startPos);
      }
    };

    Lexer.prototype.readLineTerminator = function() {
      var ref, token;
      token = (new Token('LINETERMINATOR')).setStart(this.getPos());
      this.rowAdvance();
      if ((ref = this.charCode()) === 10 || ref === 13 || ref === 8232) {
        return this.readLineTerminator();
      }
      return this.addToken(token.setEnd(this.getPos()));
    };

    Lexer.prototype.skipEmptyLines = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.EMPTYLINE)[0];
      this.posAdvance(value);
      return this.nextToken();
    };

    Lexer.prototype.skipComment = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.COMMENT)[0];
      this.posAdvance(value);
      return this.nextToken();
    };

    Lexer.prototype.lookLinearBlock = function(loc, tok) {
      var indentTracker, length, next, ref, tokens;
      if (tok == null) {
        tok = '';
      }
      tokens = [];
      if (tok === 'ELSE' && ((ref = this.next().type) === 'IF' || ref === 'POST_IF')) {
        return tokens;
      }
      next = this.next(2).type;
      if (next !== 'INDENT') {
        indentTracker = this.currentIndentTracker();
        length = indentTracker.currentIndent + 1;
        if (next === 'MINDENT' || next === 'OUTDENT') {
          tokens.push((new Token('INDENT', loc)).set('length', indentTracker.currentIndent + 1));
          tokens.push((new Token('OUTDENT', loc)).set('length', indentTracker.currentIndent + 1));
        } else {
          indentTracker.currentIndent = length;
          indentTracker.openedIndent++;
          indentTracker.indentStack.push({
            length: length,
            sensible: true
          });
          tokens.push((new Token('INDENT', loc)).set('length', length));
        }
      }
      return tokens;
    };

    Lexer.prototype.isStartTag = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      if (this.pos + 1 > this.input.length - 1) {
        return false;
      }
      return this.charCode(pos) === 123 && this.charCode(this.pos + 1) === 123;
    };

    Lexer.prototype.isEndTag = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      if (this.pos + 1 > this.input.length - 1) {
        return false;
      }
      return this.charCode(pos) === 125 && this.charCode(this.pos + 1) === 125;
    };

    Lexer.prototype.isComment = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.COMMENT) !== null;
    };

    Lexer.prototype.isEmptyLines = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.EMPTYLINE) !== null;
    };

    Lexer.prototype.isIdentifier = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.IDENTIFIER) !== null;
    };

    Lexer.prototype.isIndent = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.INDENT) !== null && this.last().type !== 'INDENT';
    };

    Lexer.prototype.isNumber = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.NUMBER) !== null;
    };

    Lexer.prototype.isString = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.STRING) !== null;
    };

    Lexer.prototype.isHereDoc = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.HEREDOC) !== null;
    };

    Lexer.prototype.isQualifiedString = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.QUALIFIEDQTRING) !== null;
    };

    Lexer.prototype.rewrite = function() {
      var i, j, len, ref, ref1, results, token;
      ref = this.tokens;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        token = ref[i];
        if (token) {
          if (token.type === 'MINDENT' && this.tokens[i + 1] && ((ref1 = this.tokens[i + 1].type) === 'CATCH' || ref1 === 'ELSE' || ref1 === 'FINALLY')) {
            results.push(this.tokens.splice(i, 1));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Lexer.prototype.reversedIndentStack = function(indentTracker) {
      var i, j, len, ref, reversed;
      reversed = [];
      ref = indentTracker.indentStack;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        reversed.unshift(i);
      }
      return reversed;
    };

    Lexer.prototype.closeIndent = function(indentTracker, loc) {
      var ref, reversed, tokens;
      tokens = [];
      reversed = this.reversedIndentStack(indentTracker);
      while (indentTracker.openedIndent) {
        if ((ref = this.last().type) === 'LINETERMINAROR' || ref === 'MINDENT') {
          this.tokens.pop();
        }
        tokens.unshift((new Token('OUTDENT', loc)).set('length', reversed[indentTracker.openedIndent - 1].length));
        indentTracker.openedIndent--;
      }
      if (this.last().type === 'LINETERMINATOR') {
        this.tokens.pop();
      }
      return tokens;
    };

    Lexer.prototype.closeIndentLevel = function() {
      return this.track.opened.shift();
    };

    Lexer.prototype.closeSensibleIndent = function(indentTracker, loc) {
      var length, res;
      res = [];
      if (indentTracker.indentStack[indentTracker.indentStack.length - 1] && indentTracker.indentStack[indentTracker.indentStack.length - 1].sensible === true) {
        length = indentTracker.indentStack.pop().length - 1;
        indentTracker.currentIndent = length;
        indentTracker.openedIndent--;
        res.push((new Token('OUTDENT', loc)).set('length', length));
      }
      return res;
    };

    return Lexer;

  })();

  Token = (function() {
    function Token(type, location, obj) {
      var key, value;
      this.type = type != null ? type : null;
      this.location = location != null ? location : {};
      if (obj == null) {
        obj = {};
      }
      for (key in obj) {
        value = obj[key];
        this[key] = value;
      }
      if (this.location === null) {
        delete this.location;
      }
    }

    Token.prototype.set = function(key, value) {
      this[key] = value;
      return this;
    };

    Token.prototype.get = function(key) {
      return this[key];
    };

    Token.prototype.setStart = function(value) {
      this.location.start = value;
      return this;
    };

    Token.prototype.setEnd = function(value) {
      this.location.end = value;
      return this;
    };

    Token.prototype.clone = function() {
      var k, token, v;
      token = new Token;
      for (k in this) {
        v = this[k];
        token.set(k, v);
      }
      return token;
    };

    return Token;

  })();

  Position = (function() {
    function Position(row, col) {
      this.row = row != null ? row : 1;
      this.col = col != null ? col : 0;
    }

    Position.prototype.clone = function() {
      return new Position(this.row, this.col);
    };

    Position.from = function(pos) {
      return new Position(pos.row || 1, pos.col || 0);
    };

    return Position;

  })();

  REGEX = {
    COMMENT: /^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/,
    EMPTYLINE: /(^[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]*[\n\r\u2028\u2029])/,
    IDENTIFIER: /((^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    INDENT: /(^[ \t]*)/,
    HEREDOC: /^`(((?!(\`|{{|}}))([\n\r\u2028\u2029]|.))*)`/,
    LINETERMINATOR: /[\n\r\u2028]/,
    NUMBER: /^(0b[01]+|0o[0-7]+|0(x|X)[\da-fA-F]+|\d*\.?\d+(?:(e|E)[+-]?\d+)?)/,
    STRING: /^('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/,
    QUALIFIEDQTRING: /^q('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/
  };

  KEYWORDS = {
    BOOL: ['TRUE', 'FALSE'],
    CALLABLE: ['CALL_END', 'IDENTIFIER', ')', ']', 'INDEX_END', '?', '@', 'QUALIFIEDQTRING'],
    CASTTYPE: ['array', 'binary', 'bool', 'boolean', 'double', 'int', 'integer', 'float', 'object', 'real', 'string', 'unset'],
    COMPARE: ['is', 'isnt'],
    INDEXABLE: ['CALL_END', 'IDENTIFIER', ')', ']', '?', '@', 'QUALIFIEDQTRING', 'NUMBER', 'STRING', 'BOOL', 'NULL'],
    LOGIC: ['and', 'or', 'xor'],
    RESERVED: ['abstract', 'as', 'break', 'by', 'catch', 'case', 'class', 'clone', 'const', 'continue', 'cte', 'declare', 'delete', 'echo', 'else', 'extends', 'final', 'finally', 'for', 'func', 'goto', 'if', 'implements', 'in', 'instanceof', 'interface', 'include', 'loop', 'namespace', 'new', 'not', 'null', 'of', 'once', 'private', 'protected', 'public', 'require', 'return', 'static', 'switch', 'then', 'throw', 'try', 'unless', 'until', 'use', 'when', 'while'],
    PHPRESERVED: ['abstract', 'and', 'as', 'break', 'callable', 'case', 'catch', 'class', 'clone', 'const', 'continue', 'declare', 'default', 'do', 'echo', 'else', 'elseif', 'empty', 'enddeclare', 'endfor', 'endforeach', 'endif', 'endswitch', 'endwhile', 'extends', 'final', 'finally', 'for', 'foreach', 'function', 'global', 'goto', 'if', 'implements', 'include', 'include_once', 'instanceof', 'insteadof', 'interface', 'namespace', 'new', 'or', 'print', 'private', 'protected', 'public', 'require', 'require_once', 'return', 'static', 'switch', 'throw', 'trait', 'try', 'unset', 'use', 'var', 'while']
  };

  module.exports = new Lexer;

}).call(this);
return module.exports;})();
require["./context"] = (function() {var exports = {}, module = {exports: exports};// Generated by CoffeeScript 1.9.3
(function() {
  var Context, IndexGenerator, Name, Scope, nodes;

  nodes = require('./nodes');

  exports.Name = Name = (function() {
    function Name(name1, type) {
      this.name = name1;
      this.type = type != null ? type : 'variable';
    }

    return Name;

  })();

  exports.Scope = Scope = (function() {
    function Scope() {
      this.names = {};
    }

    Scope.prototype.has = function(name) {
      return this.names[name] != null;
    };

    Scope.prototype.add = function(name) {
      return this.names[name.name] = name;
    };

    Scope.prototype.get = function(name) {
      return this.names[name];
    };

    Scope.prototype["delete"] = function() {
      return delete this.names[name.name];
    };

    return Scope;

  })();

  exports.Context = Context = (function() {
    function Context(scope) {
      this.indexGen = new IndexGenerator;
      this.scopes = [];
      this.scopes.unshift(scope);
    }

    Context.prototype.push = function(name) {
      return this.scopes[0].add(name);
    };

    Context.prototype.has = function(name) {
      var j, len, ref, scope;
      ref = this.scopes;
      for (j = 0, len = ref.length; j < len; j++) {
        scope = ref[j];
        if (scope.has(name)) {
          return true;
        }
      }
      return false;
    };

    Context.prototype.scopeStarts = function() {
      return this.scopes.unshift(new Scope);
    };

    Context.prototype.scopeEnds = function() {
      return this.scopes.shift();
    };

    Context.prototype.Identify = function(name) {
      var j, len, ref, ref1, scope;
      ref = this.scopes;
      for (j = 0, len = ref.length; j < len; j++) {
        scope = ref[j];
        if (scope.has(name)) {
          if ((ref1 = scope.get(name).type) === 'function' || ref1 === 'const' || ref1 === 'class' || ref1 === 'interface') {
            return name;
          } else {
            return '$' + name;
          }
        }
      }
      return '$' + name;
    };

    Context.prototype.free = function(name) {
      var i, next;
      if (name === 'i') {
        next = this.indexGen.get();
        while (this.has(next)) {
          next = this.indexGen.get();
        }
        this.push(new Name(next));
        return next;
      } else {
        i = 0;
        while (true) {
          if (!this.has(name + (i === 0 ? '' : i))) {
            this.push(new Name(name + (i === 0 ? '' : i)));
            return name + (i === 0 ? '' : i);
          }
          i++;
        }
      }
    };

    return Context;

  })();

  exports.IndexGenerator = IndexGenerator = (function() {
    function IndexGenerator() {}

    IndexGenerator.prototype.letter = ['i', 'j', 'k', 'c', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'j', 'h'];

    IndexGenerator.prototype._level = 0;

    IndexGenerator.prototype.letterLevel = 0;

    IndexGenerator.prototype.generateAtLevel = function() {
      var i, r;
      r = '';
      i = 0;
      while (i < this._level) {
        r += '_';
        i++;
      }
      return r;
    };

    IndexGenerator.prototype.next = function() {
      if ((this.letterLevel + 1) === this.letter.length) {
        this._level++;
        return this.letterLevel = 0;
      } else {
        return this.letterLevel++;
      }
    };

    IndexGenerator.prototype.get = function() {
      var r;
      r = this.generateAtLevel() + this.letter[this.letterLevel];
      this.next();
      return r;
    };

    return IndexGenerator;

  })();

}).call(this);
return exports;})();
require["./predefined"] = (function() {var exports = {}, module = {exports: exports};// Generated by CoffeeScript 1.9.3
(function() {
  var Name, PHPPredefined;

  Name = require('./context').Name;

  exports.Initialize = function(context) {
    var name, results, type;
    results = [];
    for (name in PHPPredefined) {
      type = PHPPredefined[name];
      results.push(context.push(new Name(name, type)));
    }
    return results;
  };

  PHPPredefined = {

    /* Mammouth function */
    'mammouth': 'function',

    /* Variable and Type Related Extensions */
    'call_​user_​func_​array': 'function',
    'call_user_func': 'function',
    'create_function': 'function',
    'forward_static_call_array': 'function',
    'forward_static_call': 'function',
    'func_get_arg': 'function',
    'func_get_args': 'function',
    'func_num_args': 'function',
    'function_exists': 'function',
    'get_defined_functions': 'function',
    'register_shutdown_function': 'function',
    'register_tick_function': 'function',
    'unregister_tick_function': 'function',
    'CASE_LOWER': 'const',
    'CASE_UPPER': 'const',
    'SORT_ASC': 'const',
    'SORT_DESC': 'const',
    'SORT_REGULAR': 'const',
    'SORT_NUMERIC': 'const',
    'SORT_STRING': 'const',
    'SORT_LOCALE_STRING': 'const',
    'SORT_NATURAL': 'const',
    'SORT_FLAG_CASE': 'const',
    'COUNT_NORMAL': 'const',
    'COUNT_RECURSIVE': 'const',
    'EXTR_OVERWRITE': 'const',
    'EXTR_SKIP': 'const',
    'EXTR_PREFIX_SAME': 'const',
    'EXTR_PREFIX_ALL': 'const',
    'EXTR_PREFIX_INVALID': 'const',
    'EXTR_PREFIX_IF_EXISTS': 'const',
    'EXTR_IF_EXISTS': 'const',
    'EXTR_REFS': 'const',
    'array_change_key_case': 'function',
    'array_chunk': 'function',
    'array_column': 'function',
    'array_combine': 'function',
    'array_count_values': 'function',
    'array_diff_assoc': 'function',
    'array_diff_key': 'function',
    'array_diff_uassoc': 'function',
    'array_diff_ukey': 'function',
    'array_diff': 'function',
    'array_fill_keys': 'function',
    'array_fill': 'function',
    'array_filter': 'function',
    'array_flip': 'function',
    'array_intersect_assoc': 'function',
    'array_intersect_key': 'function',
    'array_intersect_uassoc': 'function',
    'array_intersect_ukey': 'function',
    'array_intersect': 'function',
    'array_key_exists': 'function',
    'array_keys': 'function',
    'array_map': 'function',
    'array_merge_recursive': 'function',
    'array_merge': 'function',
    'array_multisort': 'function',
    'array_pad': 'function',
    'array_pop': 'function',
    'array_product': 'function',
    'array_push': 'function',
    'array_rand': 'function',
    'array_reduce': 'function',
    'array_replace_recursive': 'function',
    'array_replace': 'function',
    'array_reverse': 'function',
    'array_search': 'function',
    'array_shift': 'function',
    'array_slice': 'function',
    'array_splice': 'function',
    'array_sum': 'function',
    'array_udiff_assoc': 'function',
    'array_udiff_uassoc': 'function',
    'array_udiff': 'function',
    'array_uintersect_assoc': 'function',
    'array_uintersect_uassoc': 'function',
    'array_uintersect': 'function',
    'array_unique': 'function',
    'array_unshift': 'function',
    'array_values': 'function',
    'array_walk_recursive': 'function',
    'array_walk': 'function',
    'array': 'function',
    'arsort': 'function',
    'asort': 'function',
    'compact': 'function',
    'count': 'function',
    'current': 'function',
    'each': 'function',
    'end': 'function',
    'extract': 'function',
    'in_array': 'function',
    'key_exists': 'function',
    'key': 'function',
    'krsort': 'function',
    'ksort': 'function',
    'list': 'function',
    'natcasesort': 'function',
    'natsort': 'function',
    'next': 'function',
    'pos': 'function',
    'prev': 'function',
    'range': 'function',
    'reset': 'function',
    'rsort': 'function',
    'shuffle': 'function',
    'sizeof': 'function',
    'sort': 'function',
    'uasort': 'function',
    'uksort': 'function',
    'usort': 'function',
    '__autoload': 'function',
    'call_user_method_array': 'function',
    'call_user_method': 'function',
    'class_alias': 'function',
    'class_exists': 'function',
    'get_called_class': 'function',
    'get_class_methods': 'function',
    'get_class_vars': 'function',
    'get_class': 'function',
    'get_declared_classes': 'function',
    'get_declared_interfaces': 'function',
    'get_declared_traits': 'function',
    'get_object_vars': 'function',
    'get_parent_class': 'function',
    'interface_exists': 'function',
    'is_a': 'function',
    'is_subclass_of': 'function',
    'method_exists': 'function',
    'property_exists': 'function',
    'trait_exists': 'function',
    'CLASSKIT_ACC_PRIVATE': 'const',
    'CLASSKIT_ACC_PROTEconstD': 'const',
    'CLASSKIT_ACC_PUBLIC': 'const',
    'classkit_import': 'function',
    'classkit_method_add': 'function',
    'classkit_method_copy': 'function',
    'classkit_method_redefine': 'function',
    'classkit_method_remove': 'function',
    'classkit_method_rename': 'function',
    'ctype_alnum': 'function',
    'ctype_alpha': 'function',
    'ctype_cntrl': 'function',
    'ctype_digit': 'function',
    'ctype_graph': 'function',
    'ctype_lower': 'function',
    'ctype_print': 'function',
    'ctype_punct': 'function',
    'ctype_space': 'function',
    'ctype_upper': 'function',
    'ctype_xdigit': 'function',
    'INPUT_POST': 'const',
    'INPUT_GET': 'const',
    'INPUT_COOKIE': 'const',
    'INPUT_ENV': 'const',
    'INPUT_SERVER': 'const',
    'INPUT_SESSION': 'const',
    'INPUT_REQUEST': 'const',
    'FILTER_FLAG_NONE': 'const',
    'FILTER_REQUIRE_SCALAR': 'const',
    'FILTER_REQUIRE_ARRAY': 'const',
    'FILTER_FORCE_ARRAY': 'const',
    'FILTER_NULL_ON_FAILURE': 'const',
    'FILTER_VALIDATE_INT': 'const',
    'FILTER_VALIDATE_BOOLEAN': 'const',
    'FILTER_VALIDATE_FLOAT': 'const',
    'FILTER_VALIDATE_REGEXP': 'const',
    'FILTER_VALIDATE_URL': 'const',
    'FILTER_VALIDATE_EMAIL': 'const',
    'FILTER_VALIDATE_IP': 'const',
    'FILTER_DEFAULT': 'const',
    'FILTER_UNSAFE_RAW': 'const',
    'FILTER_SANITIZE_STRING': 'const',
    'FILTER_SANITIZE_STRIPPED': 'const',
    'FILTER_SANITIZE_ENCODED': 'const',
    'FILTER_SANITIZE_SPECIAL_CHARS': 'const',
    'FILTER_SANITIZE_EMAIL': 'const',
    'FILTER_SANITIZE_URL': 'const',
    'FILTER_SANITIZE_NUMBER_INT': 'const',
    'FILTER_SANITIZE_NUMBER_FLOAT': 'const',
    'FILTER_SANITIZE_MAGIC_QUOTES': 'const',
    'FILTER_CALLBACK': 'const',
    'FILTER_FLAG_ALLOW_OCTAL': 'const',
    'FILTER_FLAG_ALLOW_HEX': 'const',
    'FILTER_FLAG_STRIP_LOW': 'const',
    'FILTER_FLAG_STRIP_HIGH': 'const',
    'FILTER_FLAG_ENCODE_LOW': 'const',
    'FILTER_FLAG_ENCODE_HIGH': 'const',
    'FILTER_FLAG_ENCODE_AMP': 'const',
    'FILTER_FLAG_NO_ENCODE_QUOTES': 'const',
    'FILTER_FLAG_EMPTY_STRING_NULL': 'const',
    'FILTER_FLAG_ALLOW_FRACTION': 'const',
    'FILTER_FLAG_ALLOW_THOUSAND': 'const',
    'FILTER_FLAG_ALLOW_SCIENTIFIC': 'const',
    'FILTER_FLAG_PATH_REQUIRED': 'const',
    'FILTER_FLAG_QUERY_REQUIRED': 'const',
    'FILTER_FLAG_IPV4': 'const',
    'FILTER_FLAG_IPV6': 'const',
    'FILTER_FLAG_NO_RES_RANGE': 'const',
    'FILTER_FLAG_NO_PRIV_RANGE': 'const',
    'filter_has_var': 'function',
    'filter_id': 'function',
    'filter_input_array': 'function',
    'filter_input': 'function',
    'filter_list': 'function',
    'filter_var_array': 'function',
    'filter_var': 'function',
    'aggregate_infoh': 'function',
    'aggregate_methods_by_list': 'function',
    'aggregate_methods_by_regexp': 'function',
    'aggregate_methods': 'function',
    'aggregate_properties_by_list': 'function',
    'aggregate_properties_by_regexp': 'function',
    'aggregate_properties': 'function',
    'aggregate': 'function',
    'aggregation_info': 'function',
    'deaggregate': 'function',
    'QuickHashIntSet': 'class',
    'QuickHashIntHash': 'class',
    'QuickHashStringIntHash': 'class',
    'QuickHashIntStringHash': 'class',
    'Reflection': 'class',
    'ReflectionClass': 'class',
    'ReflectionZendExtension': 'class',
    'ReflectionExtension': 'class',
    'ReflectionFunction': 'class',
    'ReflectionFunctionAbstract': 'class',
    'ReflectionMethod': 'class',
    'ReflectionObject': 'class',
    'ReflectionParameter': 'class',
    'ReflectionProperty': 'class',
    'Reflector': 'class',
    'ReflectionException': 'class',
    'boolval': 'function',
    'debug_zval_dump': 'function',
    'doubleval': 'function',
    'empty': 'function',
    'floatval': 'function',
    'get_defined_vars': 'function',
    'get_resource_type': 'function',
    'gettype': 'function',
    'import_request_variables': 'function',
    'intval': 'function',
    'is_array': 'function',
    'is_bool': 'function',
    'is_callable': 'function',
    'is_double': 'function',
    'is_float': 'function',
    'is_int': 'function',
    'is_integer': 'function',
    'is_long': 'function',
    'is_null': 'function',
    'is_numeric': 'function',
    'is_object': 'function',
    'is_real': 'function',
    'is_resource': 'function',
    'is_scalar': 'function',
    'is_string': 'function',
    'isset': 'function',
    'print_r': 'function',
    'serialize': 'function',
    'settype': 'function',
    'strval': 'function',
    'unserialize': 'function',
    'unset': 'function',
    'var_dump': 'function',
    'var_export': 'function',

    /* Date and Time Related Extensions */
    'CAL_GREGORIAN': 'const',
    'CAL_JULIAN': 'const',
    'CAL_JEWISH': 'const',
    'CAL_FRENCH': 'const',
    'CAL_NUM_CALS': 'const',
    'CAL_DOW_DAYNO': 'const',
    'CAL_DOW_SHORT': 'const',
    'CAL_DOW_LONG': 'const',
    'CAL_MONTH_GREGORIAN_SHORT': 'const',
    'CAL_MONTH_GREGORIAN_LONG': 'const',
    'CAL_MONTH_JULIAN_SHORT': 'const',
    'CAL_MONTH_JULIAN_LONG': 'const',
    'CAL_MONTH_JEWISH': 'const',
    'CAL_MONTH_FRENCH': 'const',
    'CAL_EASTER_DEFAULT': 'const',
    'CAL_EASTER_ROMAN': 'const',
    'CAL_EASTER_ALWAYS_GREGORIAN': 'const',
    'CAL_EASTER_ALWAYS_JULIAN': 'const',
    'CAL_JEWISH_ADD_ALAFIM_GERESH': 'const',
    'CAL_JEWISH_ADD_ALAFIM': 'const',
    'CAL_JEWISH_ADD_GERESHAYIM  ': 'const',
    'cal_days_in_month': 'function',
    'cal_from_jd': 'function',
    'cal_info': 'function',
    'cal_to_jd': 'function',
    'easter_date': 'function',
    'easter_days': 'function',
    'frenchtojd': 'function',
    'gregoriantojd': 'function',
    'jddayofweek': 'function',
    'jdmonthname': 'function',
    'jdtofrench': 'function',
    'jdtogregorian': 'function',
    'jdtojewish': 'function',
    'jdtojulian': 'function',
    'jdtounix': 'function',
    'jewishtojd': 'function',
    'juliantojd': 'function',
    'unixtojd': 'function',
    'DateTime': 'class',
    'DateTimeImmutable': 'class',
    'DateTimeInterface': 'class',
    'DateTimeZone': 'class',
    'DateInterval': 'class',
    'DatePeriod': 'class',
    'SUNFUNCS_RET_TIMESTAMP': 'const',
    'SUNFUNCS_RET_STRING': 'const',
    'SUNFUNCS_RET_DOUBLE': 'const',
    'checkdate': 'function',
    'date_add': 'function',
    'date_create_from_format': 'function',
    'date_create_immutable_from_format': 'function',
    'date_create_immutable': 'function',
    'date_create': 'function',
    'date_date_set': 'function',
    'date_default_timezone_get': 'function',
    'date_default_timezone_set': 'function',
    'date_diff': 'function',
    'date_format': 'function',
    'date_get_last_errors': 'function',
    'date_interval_create_from_date_string': 'function',
    'date_interval_format': 'function',
    'date_isodate_set': 'function',
    'date_modify': 'function',
    'date_offset_get': 'function',
    'date_parse_from_format': 'function',
    'date_parse': 'function',
    'date_sub': 'function',
    'date_sun_info': 'function',
    'date_sunrise': 'function',
    'date_sunset': 'function',
    'date_time_set': 'function',
    'date_timestamp_get': 'function',
    'date_timestamp_set': 'function',
    'date_timezone_get': 'function',
    'date_timezone_set': 'function',
    'date': 'function',
    'getdate': 'function',
    'gettimeofday': 'function',
    'gmdate': 'function',
    'gmmktime': 'function',
    'gmstrftime': 'function',
    'idate': 'function',
    'localtime': 'function',
    'microtime': 'function',
    'mktime': 'function',
    'strftime': 'function',
    'strptime': 'function',
    'strtotime': 'function',
    'time': 'function',
    'timezone_abbreviations_list': 'function',
    'timezone_identifiers_list': 'function',
    'timezone_location_get': 'function',
    'timezone_name_from_abbr': 'function',
    'timezone_name_get': 'function',
    'timezone_offset_get': 'function',
    'timezone_open': 'function',
    'timezone_transitions_get': 'function',
    'timezone_version_get': 'function',

    /* File System Related Extensions */
    'F_DUPFD': 'const',
    'F_GETFD': 'const',
    'F_GETFL': 'const',
    'F_GETLK': 'const',
    'F_GETOWN': 'const',
    'F_RDLCK': 'const',
    'F_SETFL': 'const',
    'F_SETLK': 'const',
    'F_SETLKW': 'const',
    'F_SETOWN': 'const',
    'F_UNLCK': 'const',
    'F_WRLCK': 'const',
    'O_APPEND': 'const',
    'O_ASYNC': 'const',
    'O_CREAT': 'const',
    'O_EXCL': 'const',
    'O_NDELAY': 'const',
    'O_NOCTTY': 'const',
    'O_NONBLOCK': 'const',
    'O_RDONLY': 'const',
    'O_RDWR': 'const',
    'O_SYNC': 'const',
    'O_TRUNC': 'const',
    'O_WRONLY': 'const',
    'S_IRGRP': 'const',
    'S_IROTH': 'const',
    'S_IRUSR': 'const',
    'S_IRWXG': 'const',
    'S_IRWXO': 'const',
    'S_IRWXU': 'const',
    'S_IWGRP': 'const',
    'S_IWOTH': 'const',
    'S_IWUSR': 'const',
    'S_IXGRP': 'const',
    'S_IXOTH': 'const',
    'S_IXUSR': 'const',
    'dio_close': 'function',
    'dio_fcntl': 'function',
    'dio_open': 'function',
    'dio_read': 'function',
    'dio_seek': 'function',
    'dio_stat': 'function',
    'dio_tcsetattr': 'function',
    'dio_truncate': 'function',
    'dio_write': 'function',
    'DIRECTORY_SEPARATOR': 'const',
    'PATH_SEPARATOR': 'const',
    'SCANDIR_SORT_ASCENDING': 'const',
    'SCANDIR_SORT_DESCENDING': 'const',
    'SCANDIR_SORT_NONE': 'const',
    "Directory": "class",
    'chdir': 'function',
    'chroot': 'function',
    'closedir': 'function',
    'dir': 'function',
    'getcwd': 'function',
    'opendir': 'function',
    'readdir': 'function',
    'rewinddir': 'function',
    'scandir': 'function',
    'FILEINFO_NONE': 'const',
    'FILEINFO_SYMLINK': 'const',
    'FILEINFO_MIME_TYPE': 'const',
    'FILEINFO_MIME_ENCODING': 'const',
    'FILEINFO_MIME': 'const',
    'FILEINFO_COMPRESS': 'const',
    'FILEINFO_DEVICES': 'const',
    'FILEINFO_CONTINUE': 'const',
    'FILEINFO_PRESERVE_ATIME': 'const',
    'FILEINFO_RAW': 'const',
    'finfo_close': 'function',
    'finfo_file': 'function',
    'finfo_open': 'function',
    'finfo_set_flags': 'function',
    'mime_content_type': 'function',
    'SEEK_SET': 'const',
    'SEEK_CUR': 'const',
    'SEEK_END': 'const',
    'LOCK_SH': 'const',
    'LOCK_EX': 'const',
    'LOCK_UN': 'const',
    'LOCK_NB': 'const',
    'GLOB_BRACE': 'const',
    'GLOB_ONLYDIR': 'const',
    'GLOB_MARK': 'const',
    'GLOB_NOSORT': 'const',
    'GLOB_NOCHECK': 'const',
    'GLOB_NOESCAPE': 'const',
    'GLOB_AVAILABLE_FLAGS': 'const',
    'PATHINFO_DIRNAME': 'const',
    'PATHINFO_BASENAME': 'const',
    'PATHINFO_EXTENSION': 'const',
    'PATHINFO_FILENAME': 'const',
    'FILE_USE_INCLUDE_PATH': 'const',
    'FILE_NO_DEFAULT_CONTEXT': 'const',
    'FILE_APPEND': 'const',
    'FILE_IGNORE_NEW_LINES': 'const',
    'FILE_SKIP_EMPTY_LINES': 'const',
    'FILE_BINARY': 'const',
    'FILE_TEXT': 'const',
    'INI_SCANNER_NORMAL': 'const',
    'INI_SCANNER_RAW': 'const',
    'FNM_NOESCAPE': 'const',
    'FNM_PATHNAME': 'const',
    'FNM_PERIOD': 'const',
    'FNM_CASEFOLD': 'const',
    'basename': 'function',
    'chgrp': 'function',
    'chmod': 'function',
    'chown': 'function',
    'clearstatcache': 'function',
    'copy': 'function',
    'delete': 'function',
    'dirname': 'function',
    'disk_free_space': 'function',
    'disk_total_space': 'function',
    'diskfreespace': 'function',
    'fclose': 'function',
    'feof': 'function',
    'fflush': 'function',
    'fgetc': 'function',
    'fgetcsv': 'function',
    'fgets': 'function',
    'fgetss': 'function',
    'file_exists': 'function',
    'file_get_contents': 'function',
    'file_put_contents': 'function',
    'file': 'function',
    'fileatime': 'function',
    'filectime': 'function',
    'filegroup': 'function',
    'fileinode': 'function',
    'filemtime': 'function',
    'fileowner': 'function',
    'fileperms': 'function',
    'filesize': 'function',
    'filetype': 'function',
    'flock': 'function',
    'fnmatch': 'function',
    'fopen': 'function',
    'fpassthru': 'function',
    'fputcsv': 'function',
    'fputs': 'function',
    'fread': 'function',
    'fscanf': 'function',
    'fseek': 'function',
    'fstat': 'function',
    'ftell': 'function',
    'ftruncate': 'function',
    'fwrite': 'function',
    'glob': 'function',
    'is_dir': 'function',
    'is_executable': 'function',
    'is_file': 'function',
    'is_link': 'function',
    'is_readable': 'function',
    'is_uploaded_file': 'function',
    'is_writable': 'function',
    'is_writeable': 'function',
    'lchgrp': 'function',
    'lchown': 'function',
    'link': 'function',
    'linkinfo': 'function',
    'lstat': 'function',
    'mkdir': 'function',
    'move_uploaded_file': 'function',
    'parse_ini_file': 'function',
    'parse_ini_string': 'function',
    'pathinfo': 'function',
    'pclose': 'function',
    'popen': 'function',
    'readfile': 'function',
    'readlink': 'function',
    'realpath_cache_get': 'function',
    'realpath_cache_size': 'function',
    'realpath': 'function',
    'rename': 'function',
    'rewind': 'function',
    'rmdir': 'function',
    'set_file_buffer': 'function',
    'stat': 'function',
    'symlink': 'function',
    'tempnam': 'function',
    'tmpfile': 'function',
    'touch': 'function',
    'umask': 'function',
    'unlink': 'function',
    'IN_ACCESS': 'const',
    'IN_MODIFY': 'const',
    'IN_ATTRIB': 'const',
    'IN_CLOSE_WRITE': 'const',
    'IN_CLOSE_NOWRITE': 'const',
    'IN_OPEN': 'const',
    'IN_MOVED_TO': 'const',
    'IN_MOVED_FROM': 'const',
    'IN_CREATE': 'const',
    'IN_DELETE': 'const',
    'IN_DELETE_SELF': 'const',
    'IN_MOVE_SELF': 'const',
    'IN_CLOSE': 'const',
    'IN_MOVE': 'const',
    'IN_ALL_EVENTS': 'const',
    'IN_UNMOUNT': 'const',
    'IN_Q_OVERFLOW': 'const',
    'IN_IGNORED': 'const',
    'IN_ISDIR': 'const',
    'IN_ONLYDIR': 'const',
    'IN_DONT_FOLLOW': 'const',
    'IN_MASK_ADD': 'const',
    'IN_ONESHOT': 'const',
    'inotify_add_watch': 'function',
    'inotify_init': 'function',
    'inotify_queue_len': 'function',
    'inotify_read': 'function',
    'inotify_rm_watch': 'function',
    'setproctitle': 'function',
    'setthreadtitle': 'function',
    'XATTR_ROOT': 'const',
    'XATTR_DONTFOLLOW': 'const',
    'XATTR_CREATE': 'const',
    'XATTR_REPLACE': 'const',
    'xattr_get': 'function',
    'xattr_list': 'function',
    'xattr_remove': 'function',
    'xattr_set': 'function',
    'xattr_supported': 'function',
    'XDIFF_PATCH_NORMAL': 'const',
    'XDIFF_PATCH_REVERSE': 'const',
    'xdiff_file_bdiff_size': 'function',
    'xdiff_file_bdiff': 'function',
    'xdiff_file_bpatch': 'function',
    'xdiff_file_diff_binary': 'function',
    'xdiff_file_diff': 'function',
    'xdiff_file_merge3': 'function',
    'xdiff_file_patch_binary': 'function',
    'xdiff_file_patch': 'function',
    'xdiff_file_rabdiff': 'function',
    'xdiff_string_bdiff_size': 'function',
    'xdiff_string_bdiff': 'function',
    'xdiff_string_bpatch': 'function',
    'xdiff_string_diff_binary': 'function',
    'xdiff_string_diff': 'function',
    'xdiff_string_merge3': 'function',
    'xdiff_string_patch_binary': 'function',
    'xdiff_string_patch': 'function',
    'xdiff_string_rabdiff': 'function',

    /* Image Processing and Generation */
    'CAIRO_STATUS_SUCCESS': 'const',
    'CAIRO_STATUS_NO_MEMORY': 'const',
    'CAIRO_STATUS_INVALID_RESTORE': 'const',
    'CAIRO_STATUS_INVALID_POP_GROUP': 'const',
    'CAIRO_STATUS_NO_CURRENT_POINT': 'const',
    'CAIRO_STATUS_INVALID_MATRIX': 'const',
    'CAIRO_STATUS_INVALID_STATUS': 'const',
    'CAIRO_STATUS_NULL_POINTER': 'const',
    'CAIRO_STATUS_INVALID_STRING': 'const',
    'CAIRO_STATUS_INVALID_PATH_DATA': 'const',
    'CAIRO_STATUS_READ_ERROR': 'const',
    'CAIRO_STATUS_WRITE_ERROR': 'const',
    'CAIRO_STATUS_SURFACE_FINISHED': 'const',
    'CAIRO_STATUS_SURFACE_TYPE_MISMATCH': 'const',
    'CAIRO_STATUS_PATTERN_TYPE_MISMATCH': 'const',
    'CAIRO_STATUS_INVALID_CONTENT': 'const',
    'CAIRO_STATUS_INVALID_FORMAT': 'const',
    'CAIRO_STATUS_INVALID_VISUAL': 'const',
    'CAIRO_STATUS_FILE_NOT_FOUND': 'const',
    'CAIRO_STATUS_INVALID_DASH': 'const',
    'CAIRO_STATUS_INVALID_DSC_COMMENT': 'const',
    'CAIRO_STATUS_INVALID_INDEX': 'const',
    'CAIRO_STATUS_CLIP_NOT_REPRESENTABLE': 'const',
    'CAIRO_STATUS_TEMP_FILE_ERROR': 'const',
    'CAIRO_STATUS_INVALID_STRIDE': 'const',
    'CAIRO_ANTIALIAS_DEFAULT': 'const',
    'CAIRO_ANTIALIAS_NONE': 'const',
    'CAIRO_ANTIALIAS_GRAY': 'const',
    'CAIRO_ANTIALIAS_SUBPIXEL': 'const',
    'CAIRO_SUBPIXEL_ORDER_DEFAULT': 'const',
    'CAIRO_SUBPIXEL_ORDER_RGB': 'const',
    'CAIRO_SUBPIXEL_ORDER_BGR': 'const',
    'CAIRO_SUBPIXEL_ORDER_VRGB': 'const',
    'CAIRO_SUBPIXEL_ORDER_VBGR': 'const',
    'CAIRO_FILL_RULE_WINDING': 'const',
    'CAIRO_FILL_RULE_EVEN_ODD': 'const',
    'CAIRO_LINE_CAP_BUTT': 'const',
    'CAIRO_LINE_CAP_ROUND': 'const',
    'CAIRO_LINE_CAP_SQUARE': 'const',
    'CAIRO_LINE_JOIN_MITER': 'const',
    'CAIRO_LINE_JOIN_ROUND': 'const',
    'CAIRO_LINE_JOIN_BEVEL': 'const',
    'CAIRO_OPERATOR_CLEAR': 'const',
    'CAIRO_OPERATOR_SOURCE': 'const',
    'CAIRO_OPERATOR_OVER': 'const',
    'CAIRO_OPERATOR_IN': 'const',
    'CAIRO_OPERATOR_OUT': 'const',
    'CAIRO_OPERATOR_ATOP': 'const',
    'CAIRO_OPERATOR_DEST': 'const',
    'CAIRO_OPERATOR_DEST_OVER': 'const',
    'CAIRO_OPERATOR_DEST_IN': 'const',
    'CAIRO_OPERATOR_DEST_OUT': 'const',
    'CAIRO_OPERATOR_DEST_ATOP': 'const',
    'CAIRO_OPERATOR_XOR': 'const',
    'CAIRO_OPERATOR_ADD': 'const',
    'CAIRO_OPERATOR_SATURATE': 'const',
    'CAIRO_PATTERN_TYPE_SOLID': 'const',
    'CAIRO_PATTERN_TYPE_SURFACE': 'const',
    'CAIRO_PATTERN_TYPE_LINEAR': 'const',
    'CAIRO_PATTERN_TYPE_RADIAL': 'const',
    'CAIRO_EXTEND_NONE': 'const',
    'CAIRO_EXTEND_REPEAT': 'const',
    'CAIRO_EXTEND_REFLECT': 'const',
    'CAIRO_EXTEND_PAD': 'const',
    'CAIRO_FILTER_FAST': 'const',
    'CAIRO_FILTER_GOOD': 'const',
    'CAIRO_FILTER_BEST': 'const',
    'CAIRO_FILTER_NEAREST': 'const',
    'CAIRO_FILTER_BILINEAR': 'const',
    'CAIRO_FILTER_GAUSSIAN': 'const',
    'CAIRO_HINT_STYLE_DEFAULT': 'const',
    'CAIRO_HINT_STYLE_NONE': 'const',
    'CAIRO_HINT_STYLE_SLIGHT': 'const',
    'CAIRO_HINT_STYLE_MEDIUM': 'const',
    'CAIRO_HINT_STYLE_FULL': 'const',
    'CAIRO_HINT_METRICS_DEFAULT': 'const',
    'CAIRO_HINT_METRICS_OFF': 'const',
    'CAIRO_HINT_METRICS_ON': 'const',
    'CAIRO_FONT_TYPE_TOY': 'const',
    'CAIRO_FONT_TYPE_FT': 'const',
    'CAIRO_FONT_TYPE_WIN32': 'const',
    'CAIRO_FONT_TYPE_QUARTZ': 'const',
    'CAIRO_FONT_SLANT_NORMAL': 'const',
    'CAIRO_FONT_SLANT_ITALIC': 'const',
    'CAIRO_FONT_SLANT_OBLIQUE': 'const',
    'CAIRO_FONT_WEIGHT_NORMAL': 'const',
    'CAIRO_FONT_WEIGHT_BOLD': 'const',
    'CAIRO_CONTENT_COLOR': 'const',
    'CAIRO_CONTENT_ALPHA': 'const',
    'CAIRO_CONTENT_COLOR_ALPHA': 'const',
    'CAIRO_SURFACE_TYPE_IMAGE': 'const',
    'CAIRO_SURFACE_TYPE_PDF': 'const',
    'CAIRO_SURFACE_TYPE_PS': 'const',
    'CAIRO_SURFACE_TYPE_XLIB': 'const',
    'CAIRO_SURFACE_TYPE_XCB': 'const',
    'CAIRO_SURFACE_TYPE_GLITZ': 'const',
    'CAIRO_SURFACE_TYPE_QUARTZ': 'const',
    'CAIRO_SURFACE_TYPE_WIN32': 'const',
    'CAIRO_SURFACE_TYPE_BEOS': 'const',
    'CAIRO_SURFACE_TYPE_DIRECTFB': 'const',
    'CAIRO_SURFACE_TYPE_SVG': 'const',
    'CAIRO_SURFACE_TYPE_OS2': 'const',
    'CAIRO_SURFACE_TYPE_WIN32_PRINTING': 'const',
    'CAIRO_SURFACE_TYPE_QUARTZ_IMAGE': 'const',
    'CAIRO_FORMAT_ARGB32': 'const',
    'CAIRO_FORMAT_RGB24': 'const',
    'CAIRO_FORMAT_A8': 'const',
    'CAIRO_FORMAT_A1': 'const',
    'CAIRO_PS_LEVEL_2': 'const',
    'CAIRO_PS_LEVEL_3': 'const',
    'CAIRO_SVG_VERSION_1_1': 'const',
    'CAIRO_SVG_VERSION_1_2': 'const',
    'cairo_create': 'function',
    'cairo_font_face_get_type': 'function',
    'cairo_font_face_status': 'function',
    'cairo_font_options_create': 'function',
    'cairo_font_options_equal': 'function',
    'cairo_font_options_get_antialias': 'function',
    'cairo_font_options_get_hint_metrics': 'function',
    'cairo_font_options_get_hint_style': 'function',
    'cairo_font_options_get_subpixel_order': 'function',
    'cairo_font_options_hash': 'function',
    'cairo_font_options_merge': 'function',
    'cairo_font_options_set_antialias': 'function',
    'cairo_font_options_set_hint_metrics': 'function',
    'cairo_font_options_set_hint_style': 'function',
    'cairo_font_options_set_subpixel_order': 'function',
    'cairo_font_options_status': 'function',
    'cairo_format_stride_for_width': 'function',
    'cairo_image_surface_create_for_data': 'function',
    'cairo_image_surface_create_from_png': 'function',
    'cairo_image_surface_create': 'function',
    'cairo_image_surface_get_data': 'function',
    'cairo_image_surface_get_format': 'function',
    'cairo_image_surface_get_height': 'function',
    'cairo_image_surface_get_stride': 'function',
    'cairo_image_surface_get_width': 'function',
    'cairo_matrix_create_scale': 'function',
    'cairo_matrix_create_translate': 'function',
    'cairo_matrix_invert': 'function',
    'cairo_matrix_multiply': 'function',
    'cairo_matrix_rotate': 'function',
    'cairo_matrix_transform_distance': 'function',
    'cairo_matrix_transform_point': 'function',
    'cairo_matrix_translate': 'function',
    'cairo_pattern_add_color_stop_rgb': 'function',
    'cairo_pattern_add_color_stop_rgba': 'function',
    'cairo_pattern_create_for_surface': 'function',
    'cairo_pattern_create_linear': 'function',
    'cairo_pattern_create_radial': 'function',
    'cairo_pattern_create_rgb': 'function',
    'cairo_pattern_create_rgba': 'function',
    'cairo_pattern_get_color_stop_count': 'function',
    'cairo_pattern_get_color_stop_rgba': 'function',
    'cairo_pattern_get_extend': 'function',
    'cairo_pattern_get_filter': 'function',
    'cairo_pattern_get_linear_points': 'function',
    'cairo_pattern_get_matrix': 'function',
    'cairo_pattern_get_radial_circles': 'function',
    'cairo_pattern_get_rgba': 'function',
    'cairo_pattern_get_surface': 'function',
    'cairo_pattern_get_type': 'function',
    'cairo_pattern_set_extend': 'function',
    'cairo_pattern_set_filter': 'function',
    'cairo_pattern_set_matrix': 'function',
    'cairo_pattern_status': 'function',
    'cairo_pdf_surface_create': 'function',
    'cairo_pdf_surface_set_size': 'function',
    'cairo_ps_get_levels': 'function',
    'cairo_ps_level_to_string': 'function',
    'cairo_ps_surface_create': 'function',
    'cairo_ps_surface_dsc_begin_page_setup': 'function',
    'cairo_ps_surface_dsc_begin_setup': 'function',
    'cairo_ps_surface_dsc_comment': 'function',
    'cairo_ps_surface_get_eps': 'function',
    'cairo_ps_surface_restrict_to_level': 'function',
    'cairo_ps_surface_set_eps': 'function',
    'cairo_ps_surface_set_size': 'function',
    'cairo_scaled_font_create': 'function',
    'cairo_scaled_font_extents': 'function',
    'cairo_scaled_font_get_ctm': 'function',
    'cairo_scaled_font_get_font_face': 'function',
    'cairo_scaled_font_get_font_matrix': 'function',
    'cairo_scaled_font_get_font_options': 'function',
    'cairo_scaled_font_get_scale_matrix': 'function',
    'cairo_scaled_font_get_type': 'function',
    'cairo_scaled_font_glyph_extents': 'function',
    'cairo_scaled_font_status': 'function',
    'cairo_scaled_font_text_extents': 'function',
    'cairo_surface_copy_page': 'function',
    'cairo_surface_create_similar': 'function',
    'cairo_surface_finish': 'function',
    'cairo_surface_flush': 'function',
    'cairo_surface_get_content': 'function',
    'cairo_surface_get_device_offset': 'function',
    'cairo_surface_get_font_options': 'function',
    'cairo_surface_get_type': 'function',
    'cairo_surface_mark_dirty_rectangle': 'function',
    'cairo_surface_mark_dirty': 'function',
    'cairo_surface_set_device_offset': 'function',
    'cairo_surface_set_fallback_resolution': 'function',
    'cairo_surface_show_page': 'function',
    'cairo_surface_status': 'function',
    'cairo_surface_write_to_png': 'function',
    'cairo_svg_surface_create': 'function',
    'cairo_svg_surface_restrict_to_version': 'function',
    'cairo_svg_version_to_string': 'function',
    'Cairo': 'class',
    'CairoContext': 'class',
    'CairoException': 'class',
    'CairoStatus': 'class',
    'CairoSurface': 'class',
    'CairoSvgSurface': 'class',
    'CairoImageSurface': 'class',
    'CairoPdfSurface': 'class',
    'CairoPsSurface': 'class',
    'CairoSurfaceType': 'class',
    'CairoFontFace': 'class',
    'CairoFontOptions': 'class',
    'CairoFontSlant': 'class',
    'CairoFontType': 'class',
    'CairoFontWeight': 'class',
    'CairoScaledFont': 'class',
    'CairoToyFontFace': 'class',
    'CairoPatternType': 'class',
    'CairoPattern': 'class',
    'CairoGradientPattern': 'class',
    'CairoSolidPattern': 'class',
    'CairoSurfacePattern': 'class',
    'CairoLinearGradient': 'class',
    'CairoRadialGradient': 'class',
    'CairoAntialias': 'class',
    'CairoContent': 'class',
    'CairoExtend': 'class',
    'CairoFormat': 'class',
    'CairoFillRule': 'class',
    'CairoFilter': 'class',
    'CairoHintMetrics': 'class',
    'CairoHintStyle': 'class',
    'CairoLineCap': 'class',
    'CairoLineJoin': 'class',
    'CairoMatrix': 'class',
    'CairoOperator': 'class',
    'CairoPath': 'class',
    'CairoPsLevel': 'class',
    'CairoSubpixelOrder': 'class',
    'CairoSvgVersion': 'class',
    'EXIF_USE_MBSTRING': 'const',
    'IMAGETYPE_GIF': 'const',
    'IMAGETYPE_JPEG': 'const',
    'IMAGETYPE_PNG': 'const',
    'IMAGETYPE_SWF': 'const',
    'IMAGETYPE_PSD': 'const',
    'IMAGETYPE_BMP': 'const',
    'IMAGETYPE_TIFF_II': 'const',
    'IMAGETYPE_TIFF_MM': 'const',
    'IMAGETYPE_JPC': 'const',
    'IMAGETYPE_JP2': 'const',
    'IMAGETYPE_JPX': 'const',
    'IMAGETYPE_JB2': 'const',
    'IMAGETYPE_SWC': 'const',
    'IMAGETYPE_IFF': 'const',
    'IMAGETYPE_WBMP': 'const',
    'IMAGETYPE_XBM': 'const',
    'IMAGETYPE_ICO': 'const',
    'exif_imagetype': 'function',
    'exif_read_data': 'function',
    'exif_tagname': 'function',
    'exif_thumbnail': 'function',
    'read_exif_data': 'function',
    'GD_VERSION': 'const',
    'GD_MAJOR_VERSION': 'const',
    'GD_MINOR_VERSION': 'const',
    'GD_RELEASE_VERSION': 'const',
    'GD_EXTRA_VERSION': 'const',
    'GD_BUNDLED': 'const',
    'IMG_GIF': 'const',
    'IMG_JPG': 'const',
    'IMG_JPEG': 'const',
    'IMG_PNG': 'const',
    'IMG_WBMP': 'const',
    'IMG_XPM': 'const',
    'IMG_COLOR_TILED': 'const',
    'IMG_COLOR_STYLED': 'const',
    'IMG_COLOR_BRUSHED': 'const',
    'IMG_COLOR_STYLEDBRUSHED': 'const',
    'IMG_COLOR_TRANSPARENT': 'const',
    'IMG_ARC_ROUNDED': 'const',
    'IMG_ARC_PIE': 'const',
    'IMG_ARC_CHORD': 'const',
    'IMG_ARC_NOFILL': 'const',
    'IMG_ARC_EDGED': 'const',
    'IMG_GD2_RAW': 'const',
    'IMG_GD2_COMPRESSED': 'const',
    'IMG_EFFECT_REPLACE': 'const',
    'IMG_EFFECT_ALPHABLEND': 'const',
    'IMG_EFFECT_NORMAL': 'const',
    'IMG_EFFECT_OVERLAY': 'const',
    'IMG_FILTER_NEGATE': 'const',
    'IMG_FILTER_GRAYSCALE': 'const',
    'IMG_FILTER_BRIGHTNESS': 'const',
    'IMG_FILTER_CONTRAST': 'const',
    'IMG_FILTER_COLORIZE': 'const',
    'IMG_FILTER_EDGEDETECT': 'const',
    'IMG_FILTER_GAUSSIAN_BLUR': 'const',
    'IMG_FILTER_SELECTIVE_BLUR': 'const',
    'IMG_FILTER_EMBOSS': 'const',
    'IMG_FILTER_MEAN_REMOVAL': 'const',
    'IMG_FILTER_SMOOTH': 'const',
    'IMG_FILTER_PIXELATE': 'const',
    'IMAGETYPE_GIF': 'const',
    'IMAGETYPE_JPEG': 'const',
    'IMAGETYPE_JPEG2000': 'const',
    'IMAGETYPE_PNG': 'const',
    'IMAGETYPE_SWF': 'const',
    'IMAGETYPE_PSD': 'const',
    'IMAGETYPE_BMP': 'const',
    'IMAGETYPE_WBMP': 'const',
    'IMAGETYPE_XBM': 'const',
    'IMAGETYPE_TIFF_II': 'const',
    'IMAGETYPE_TIFF_MM': 'const',
    'IMAGETYPE_IFF': 'const',
    'IMAGETYPE_JB2': 'const',
    'IMAGETYPE_JPC': 'const',
    'IMAGETYPE_JP2': 'const',
    'IMAGETYPE_JPX': 'const',
    'IMAGETYPE_SWC': 'const',
    'IMAGETYPE_ICO': 'const',
    'PNG_NO_FILTER': 'const',
    'PNG_FILTER_NONE': 'const',
    'PNG_FILTER_SUB': 'const',
    'PNG_FILTER_UP': 'const',
    'PNG_FILTER_AVG': 'const',
    'PNG_FILTER_PAETH': 'const',
    'PNG_ALL_FILTERS': 'const',
    'IMG_FLIP_VERTICAL': 'const',
    'IMG_FLIP_HORIZONTAL': 'const',
    'IMG_FLIP_BOTH': 'const',
    'IMG_BELL': 'const',
    'IMG_BESSEL': 'const',
    'IMG_BILINEAR_FIXED': 'const',
    'IMG_BICUBIC': 'const',
    'IMG_BICUBIC': 'const',
    'IMG_BLACKMAN': 'const',
    'IMG_BOX': 'const',
    'IMG_BSPLINE': 'const',
    'IMG_CATMULLROM': 'const',
    'IMG_GAUSSIAN': 'const',
    'IMG_GENERALIZED_CUBIC': 'const',
    'IMG_HERMITE': 'const',
    'IMG_HAMMING': 'const',
    'IMG_HANNING': 'const',
    'IMG_MITCHELL': 'const',
    'IMG_POWER': 'const',
    'IMG_QUADRATIC': 'const',
    'IMG_SINC': 'const',
    'IMG_NEAREST_NEIGHBOUR': 'const',
    'IMG_WEIGHTED4': 'const',
    'IMG_TRIANGLE': 'const',
    'gd_info': 'function',
    'getimagesize': 'function',
    'getimagesizefromstring': 'function',
    'image_type_to_extension': 'function',
    'image_type_to_mime_type': 'function',
    'image2wbmp': 'function',
    'imageaffine': 'function',
    'imageaffinematrixconcat': 'function',
    'imageaffinematrixget': 'function',
    'imagealphablending': 'function',
    'imageantialias': 'function',
    'imagearc': 'function',
    'imagechar': 'function',
    'imagecharup': 'function',
    'imagecolorallocate': 'function',
    'imagecolorallocatealpha': 'function',
    'imagecolorat': 'function',
    'imagecolorclosest': 'function',
    'imagecolorclosestalpha': 'function',
    'imagecolorclosesthwb': 'function',
    'imagecolordeallocate': 'function',
    'imagecolorexact': 'function',
    'imagecolorexactalpha': 'function',
    'imagecolormatch': 'function',
    'imagecolorresolve': 'function',
    'imagecolorresolvealpha': 'function',
    'imagecolorset': 'function',
    'imagecolorsforindex': 'function',
    'imagecolorstotal': 'function',
    'imagecolortransparent': 'function',
    'imageconvolution': 'function',
    'imagecopy': 'function',
    'imagecopymerge': 'function',
    'imagecopymergegray': 'function',
    'imagecopyresampled': 'function',
    'imagecopyresized': 'function',
    'imagecreate': 'function',
    'imagecreatefromgd2': 'function',
    'imagecreatefromgd2part': 'function',
    'imagecreatefromgd': 'function',
    'imagecreatefromgif': 'function',
    'imagecreatefromjpeg': 'function',
    'imagecreatefrompng': 'function',
    'imagecreatefromstring': 'function',
    'imagecreatefromwbmp': 'function',
    'imagecreatefromwebp': 'function',
    'imagecreatefromxbm': 'function',
    'imagecreatefromxpm': 'function',
    'imagecreatetruecolor': 'function',
    'imagecrop': 'function',
    'imagecropauto': 'function',
    'imagedashedline': 'function',
    'imagedestroy': 'function',
    'imageellipse': 'function',
    'imagefill': 'function',
    'imagefilledarc': 'function',
    'imagefilledellipse': 'function',
    'imagefilledpolygon': 'function',
    'imagefilledrectangle': 'function',
    'imagefilltoborder': 'function',
    'imagefilter': 'function',
    'imageflip': 'function',
    'imagefontheight': 'function',
    'imagefontwidth': 'function',
    'imageftbbox': 'function',
    'imagefttext': 'function',
    'imagegammacorrect': 'function',
    'imagegd2': 'function',
    'imagegd': 'function',
    'imagegif': 'function',
    'imagegrabscreen': 'function',
    'imagegrabwindow': 'function',
    'imageinterlace': 'function',
    'imageistruecolor': 'function',
    'imagejpeg': 'function',
    'imagelayereffect': 'function',
    'imageline': 'function',
    'imageloadfont': 'function',
    'imagepalettecopy': 'function',
    'imagepalettetotruecolor': 'function',
    'imagepng': 'function',
    'imagepolygon': 'function',
    'imagepsbbox': 'function',
    'imagepsencodefont': 'function',
    'imagepsextendfont': 'function',
    'imagepsfreefont': 'function',
    'imagepsloadfont': 'function',
    'imagepsslantfont': 'function',
    'imagepstext': 'function',
    'imagerectangle': 'function',
    'imagerotate': 'function',
    'imagesavealpha': 'function',
    'imagescale': 'function',
    'imagesetbrush': 'function',
    'imagesetinterpolation': 'function',
    'imagesetpixel': 'function',
    'imagesetstyle': 'function',
    'imagesetthickness': 'function',
    'imagesettile': 'function',
    'imagestring': 'function',
    'imagestringup': 'function',
    'imagesx': 'function',
    'imagesy': 'function',
    'imagetruecolortopalette': 'function',
    'imagettfbbox': 'function',
    'imagettftext': 'function',
    'imagetypes': 'function',
    'imagewbmp': 'function',
    'imagewebp': 'function',
    'imagexbm': 'function',
    'iptcembed': 'function',
    'iptcparse': 'function',
    'jpeg2wbmp': 'function',
    'png2wbmp': 'function',
    'Gmagick': 'class',
    'GmagickDraw': 'class',
    'GmagickPixel': 'class',
    'Imagick': 'class',
    'ImagickDraw': 'class',
    'ImagickPixel': 'class',
    'ImagickPixelIterator': 'class',
    'ImagickKernel': 'class',

    /* Compression and Archive Extensions */
    'bzclose': 'function',
    'bzcompress': 'function',
    'bzdecompress': 'function',
    'bzerrno': 'function',
    'bzerror': 'function',
    'bzerrstr': 'function',
    'bzflush': 'function',
    'bzopen': 'function',
    'bzread': 'function',
    'bzwrite': 'function',
    'lzf_compress': 'function',
    'lzf_decompress': 'function',
    'lzf_optimized_for': 'function',
    'Phar': 'class',
    'PharData': 'class',
    'PharFileInfo': 'class',
    'PharException': 'class',
    'RarArchive': 'class',
    'RarEntry': 'class',
    'RarException': 'class',
    'RAR_HOST_MSDOS': 'const',
    'RAR_HOST_OS2': 'const',
    'RAR_HOST_WIN32': 'const',
    'RAR_HOST_UNIX': 'const',
    'RAR_HOST_BEOS': 'const',
    'rar_wrapper_cache_stats': 'function',
    'ZipArchive': 'class',
    'zip_close': 'function',
    'zip_entry_close': 'function',
    'zip_entry_compressedsize': 'function',
    'zip_entry_compressionmethod': 'function',
    'zip_entry_filesize': 'function',
    'zip_entry_name': 'function',
    'zip_entry_open': 'function',
    'zip_entry_read': 'function',
    'zip_open': 'function',
    'zip_read': 'function',
    'FORCE_GZIP': 'const',
    'FORCE_DEFLATE': 'const',
    'gzclose': 'function',
    'gzcompress': 'function',
    'gzdecode': 'function',
    'gzdeflate': 'function',
    'gzencode': 'function',
    'gzeof': 'function',
    'gzfile': 'function',
    'gzgetc': 'function',
    'gzgets': 'function',
    'gzgetss': 'function',
    'gzinflate': 'function',
    'gzopen': 'function',
    'gzpassthru': 'function',
    'gzputs': 'function',
    'gzread': 'function',
    'gzrewind': 'function',
    'gzseek': 'function',
    'gztell': 'function',
    'gzuncompress': 'function',
    'gzwrite': 'function',
    'readgzfile': 'function',
    'zlib_decode': 'function',
    'zlib_encode': 'function',
    'zlib_get_coding_type': 'function',

    /* Cryptography Extensions */
    'crack_check': 'function',
    'crack_closedict': 'function',
    'crack_getlastmessage': 'function',
    'crack_opendict': 'function',
    'HASH_HMAC': 'const',
    'hash_algos': 'function',
    'hash_copy': 'function',
    'hash_file': 'function',
    'hash_final': 'function',
    'hash_hmac_file': 'function',
    'hash_hmac': 'function',
    'hash_init': 'function',
    'hash_pbkdf2': 'function',
    'hash_update_file': 'function',
    'hash_update_stream': 'function',
    'hash_update': 'function',
    'hash': 'function',
    'MCRYPT_MODE_ECB': 'const',
    'MCRYPT_MODE_CBC': 'const',
    'MCRYPT_MODE_CFB': 'const',
    'MCRYPT_MODE_OFB': 'const',
    'MCRYPT_MODE_NOFB': 'const',
    'MCRYPT_MODE_STREAM': 'const',
    'MCRYPT_ENCRYPT': 'const',
    'MCRYPT_DECRYPT': 'const',
    'MCRYPT_DEV_RANDOM': 'const',
    'MCRYPT_DEV_URANDOM': 'const',
    'MCRYPT_RAND': 'const',
    'mcrypt_cbc': 'function',
    'mcrypt_cfb': 'function',
    'mcrypt_create_iv': 'function',
    'mcrypt_decrypt': 'function',
    'mcrypt_ecb': 'function',
    'mcrypt_enc_get_algorithms_name': 'function',
    'mcrypt_enc_get_block_size': 'function',
    'mcrypt_enc_get_iv_size': 'function',
    'mcrypt_enc_get_key_size': 'function',
    'mcrypt_enc_get_modes_name': 'function',
    'mcrypt_enc_get_supported_key_sizes': 'function',
    'mcrypt_enc_is_block_algorithm_mode': 'function',
    'mcrypt_enc_is_block_algorithm': 'function',
    'mcrypt_enc_is_block_mode': 'function',
    'mcrypt_enc_self_test': 'function',
    'mcrypt_encrypt': 'function',
    'mcrypt_generic_deinit': 'function',
    'mcrypt_generic_end': 'function',
    'mcrypt_generic_init': 'function',
    'mcrypt_generic': 'function',
    'mcrypt_get_block_size': 'function',
    'mcrypt_get_cipher_name': 'function',
    'mcrypt_get_iv_size': 'function',
    'mcrypt_get_key_size': 'function',
    'mcrypt_list_algorithms': 'function',
    'mcrypt_list_modes': 'function',
    'mcrypt_module_close': 'function',
    'mcrypt_module_get_algo_block_size': 'function',
    'mcrypt_module_get_algo_key_size': 'function',
    'mcrypt_module_get_supported_key_sizes': 'function',
    'mcrypt_module_is_block_algorithm_mode': 'function',
    'mcrypt_module_is_block_algorithm': 'function',
    'mcrypt_module_is_block_mode': 'function',
    'mcrypt_module_open': 'function',
    'mcrypt_module_self_test': 'function',
    'mcrypt_ofb': 'function',
    'mdecrypt_generic': 'function',
    'MHASH_ADLER32': 'const',
    'MHASH_CRC32': 'const',
    'MHASH_CRC32B': 'const',
    'MHASH_GOST': 'const',
    'MHASH_HAVAL128': 'const',
    'MHASH_HAVAL160': 'const',
    'MHASH_HAVAL192': 'const',
    'MHASH_HAVAL224': 'const',
    'MHASH_HAVAL256': 'const',
    'MHASH_MD2': 'const',
    'MHASH_MD4': 'const',
    'MHASH_MD5': 'const',
    'MHASH_RIPEMD128': 'const',
    'MHASH_RIPEMD256': 'const',
    'MHASH_RIPEMD320': 'const',
    'MHASH_SHA1': 'const',
    'MHASH_SHA192': 'const',
    'MHASH_SHA224': 'const',
    'MHASH_SHA256': 'const',
    'MHASH_SHA384': 'const',
    'MHASH_SHA512': 'const',
    'MHASH_SNEFRU128': 'const',
    'MHASH_SNEFRU256': 'const',
    'MHASH_TIGER': 'const',
    'MHASH_TIGER128': 'const',
    'MHASH_TIGER160': 'const',
    'MHASH_WHIRLPOOL ': 'const',
    'mhash_count': 'function',
    'mhash_get_block_size': 'function',
    'mhash_get_hash_name': 'function',
    'mhash_keygen_s2k': 'function',
    'mhash': 'function',
    'X509_PURPOSE_SSL_CLIENT': 'const',
    'X509_PURPOSE_SSL_SERVER': 'const',
    'X509_PURPOSE_NS_SSL_SERVER': 'const',
    'X509_PURPOSE_SMIME_SIGN': 'const',
    'X509_PURPOSE_SMIME_ENCRYPT': 'const',
    'X509_PURPOSE_CRL_SIGN': 'const',
    'X509_PURPOSE_ANY': 'const',
    'OPENSSL_PKCS1_PADDING': 'const',
    'OPENSSL_SSLV23_PADDING': 'const',
    'OPENSSL_NO_PADDING': 'const',
    'OPENSSL_PKCS1_OAEP_PADDING': 'const',
    'OPENSSL_KEYTYPE_RSA': 'const',
    'OPENSSL_KEYTYPE_DSA': 'const',
    'OPENSSL_KEYTYPE_DH': 'const',
    'OPENSSL_KEYTYPE_EC': 'const',
    'OPENSSL_KEYTYPE_EC': 'const',
    'PKCS7_TEXT': 'const',
    'PKCS7_BINARY': 'const',
    'PKCS7_NOINTERN': 'const',
    'PKCS7_NOVERIFY': 'const',
    'PKCS7_NOCHAIN': 'const',
    'PKCS7_NOCERTS': 'const',
    'PKCS7_NOATTR': 'const',
    'PKCS7_DETACHED': 'const',
    'PKCS7_NOSIGS': 'const',
    'OPENSSL_ALGO_DSS1': 'const',
    'OPENSSL_ALGO_SHA1': 'const',
    'OPENSSL_ALGO_SHA224': 'const',
    'OPENSSL_ALGO_SHA256': 'const',
    'OPENSSL_ALGO_SHA384': 'const',
    'OPENSSL_ALGO_SHA512': 'const',
    'OPENSSL_ALGO_RMD160': 'const',
    'OPENSSL_ALGO_MD5': 'const',
    'OPENSSL_ALGO_MD4': 'const',
    'OPENSSL_ALGO_MD2': 'const',
    'OPENSSL_CIPHER_RC2_40': 'const',
    'OPENSSL_CIPHER_RC2_128': 'const',
    'OPENSSL_CIPHER_RC2_64': 'const',
    'OPENSSL_CIPHER_DES': 'const',
    'OPENSSL_CIPHER_3DES': 'const',
    'OPENSSL_CIPHER_AES_128_CBC': 'const',
    'OPENSSL_CIPHER_AES_192_CBC': 'const',
    'OPENSSL_CIPHER_AES_256_CBC': 'const',
    'OPENSSL_VERSION_TEXT': 'const',
    'OPENSSL_VERSION_NUMBER': 'const',
    'OPENSSL_TLSEXT_SERVER_NAME': 'const',
    'openssl_cipher_iv_length': 'function',
    'openssl_csr_export_to_file': 'function',
    'openssl_csr_export': 'function',
    'openssl_csr_get_public_key': 'function',
    'openssl_csr_get_subject': 'function',
    'openssl_csr_new': 'function',
    'openssl_csr_sign': 'function',
    'openssl_decrypt': 'function',
    'openssl_dh_compute_key': 'function',
    'openssl_digest': 'function',
    'openssl_encrypt': 'function',
    'openssl_error_string': 'function',
    'openssl_free_key': 'function',
    'openssl_get_cipher_methods': 'function',
    'openssl_get_md_methods': 'function',
    'openssl_get_privatekey': 'function',
    'openssl_get_publickey': 'function',
    'openssl_open': 'function',
    'openssl_pbkdf2': 'function',
    'openssl_pkcs12_export_to_file': 'function',
    'openssl_pkcs12_export': 'function',
    'openssl_pkcs12_read': 'function',
    'openssl_pkcs7_decrypt': 'function',
    'openssl_pkcs7_encrypt': 'function',
    'openssl_pkcs7_sign': 'function',
    'openssl_pkcs7_verify': 'function',
    'openssl_pkey_export_to_file': 'function',
    'openssl_pkey_export': 'function',
    'openssl_pkey_free': 'function',
    'openssl_pkey_get_details': 'function',
    'openssl_pkey_get_private': 'function',
    'openssl_pkey_get_public': 'function',
    'openssl_pkey_new': 'function',
    'openssl_private_decrypt': 'function',
    'openssl_private_encrypt': 'function',
    'openssl_public_decrypt': 'function',
    'openssl_public_encrypt': 'function',
    'openssl_random_pseudo_bytes': 'function',
    'openssl_seal': 'function',
    'openssl_sign': 'function',
    'openssl_spki_export_challenge': 'function',
    'openssl_spki_export': 'function',
    'openssl_spki_new': 'function',
    'openssl_spki_verify': 'function',
    'openssl_verify': 'function',
    'openssl_x509_check_private_key': 'function',
    'openssl_x509_checkpurpose': 'function',
    'openssl_x509_export_to_file': 'function',
    'openssl_x509_export': 'function',
    'openssl_x509_fingerprint': 'function',
    'openssl_x509_free': 'function',
    'openssl_x509_parse': 'function',
    'openssl_x509_read': 'function',
    'PASSWORD_BCRYPT': 'const',
    'PASSWORD_DEFAULT': 'const',
    'password_get_info': 'function',
    'password_hash': 'function',
    'password_needs_rehash': 'function',
    'password_verify': 'function',

    /* Affecting PHP's Behaviour */
    'APCIterator': 'class',
    'APC_BIN_VERIFY_CRC32': 'const',
    'APC_BIN_VERIFY_MD5': 'const',
    'APC_ITER_ALL': 'const',
    'APC_ITER_ATIME': 'const',
    'APC_ITER_CTIME': 'const',
    'APC_ITER_DEVICE': 'const',
    'APC_ITER_DTIME': 'const',
    'APC_ITER_FILENAME': 'const',
    'APC_ITER_INODE': 'const',
    'APC_ITER_KEY': 'const',
    'APC_ITER_MD5': 'const',
    'APC_ITER_MEM_SIZE': 'const',
    'APC_ITER_MTIME': 'const',
    'APC_ITER_NONE': 'const',
    'APC_ITER_NUM_HITS': 'const',
    'APC_ITER_REFCOUNT': 'const',
    'APC_ITER_TTL': 'const',
    'APC_ITER_TYPE': 'const',
    'APC_ITER_VALUE': 'const',
    'APC_LIST_ACTIVE': 'const',
    'APC_LIST_DELETED': 'const',
    'apc_add': 'function',
    'apc_bin_dump': 'function',
    'apc_bin_dumpfile': 'function',
    'apc_bin_load': 'function',
    'apc_bin_loadfile': 'function',
    'apc_cache_info': 'function',
    'apc_cas': 'function',
    'apc_clear_cache': 'function',
    'apc_compile_file': 'function',
    'apc_dec': 'function',
    'apc_define_constants': 'function',
    'apc_delete_file': 'function',
    'apc_delete': 'function',
    'apc_exists': 'function',
    'apc_fetch': 'function',
    'apc_inc': 'function',
    'apc_load_constants': 'function',
    'apc_sma_info': 'function',
    'apc_store': 'function',
    'E_ERROR': 'const',
    'E_WARNING': 'const',
    'E_PARSE': 'const',
    'E_NOTICE': 'const',
    'E_CORE_ERROR': 'const',
    'E_CORE_WARNING': 'const',
    'E_COMPILE_ERROR': 'const',
    'E_COMPILE_WARNING': 'const',
    'E_USER_ERROR': 'const',
    'E_USER_WARNING': 'const',
    'E_USER_NOTICE': 'const',
    'E_STRICT': 'const',
    'E_RECOVERABLE_ERROR': 'const',
    'E_DEPRECATED': 'const',
    'E_USER_DEPRECATED': 'const',
    'E_ALL': 'const',
    'debug_backtrace': 'function',
    'debug_print_backtrace': 'function',
    'error_clear_last': 'function',
    'error_get_last': 'function',
    'error_log': 'function',
    'error_reporting': 'function',
    'restore_error_handler': 'function',
    'restore_exception_handler': 'function',
    'set_error_handler': 'function',
    'set_exception_handler': 'function',
    'trigger_error': 'function',
    'user_error': 'function',
    'CREDITS_GROUP': 'const',
    'CREDITS_GENERAL': 'const',
    'CREDITS_SAPI': 'const',
    'CREDITS_MODULES': 'const',
    'CREDITS_DOCS': 'const',
    'CREDITS_FULLPAGE': 'const',
    'CREDITS_QA': 'const',
    'CREDITS_ALL': 'const',
    'INFO_GENERAL': 'const',
    'INFO_CREDITS': 'const',
    'INFO_CONFIGURATION': 'const',
    'INFO_MODULES': 'const',
    'INFO_ENVIRONMENT': 'const',
    'INFO_VARIABLES': 'const',
    'INFO_LICENSE': 'const',
    'INFO_ALL': 'const',
    'INI_USER': 'const',
    'INI_PERDIR': 'const',
    'INI_SYSTEM': 'const',
    'INI_ALL': 'const',
    'SSERT_ACTIVE': 'const',
    'ASSERT_CALLBACK': 'const',
    'ASSERT_BAIL': 'const',
    'ASSERT_WARNING': 'const',
    'ASSERT_QUIET_EVAL': 'const',
    'PHP_WINDOWS_VERSION_MAJOR': 'const',
    'PHP_WINDOWS_VERSION_MINOR': 'const',
    'PHP_WINDOWS_VERSION_BUILD': 'const',
    'PHP_WINDOWS_VERSION_PLATFORM': 'const',
    'PHP_WINDOWS_VERSION_SP_MAJOR': 'const',
    'PHP_WINDOWS_VERSION_SP_MINOR': 'const',
    'PHP_WINDOWS_VERSION_SUITEMASK': 'const',
    'PHP_WINDOWS_VERSION_PRODUCTTYPE': 'const',
    'PHP_WINDOWS_NT_DOMAIN_CONTROLLER': 'const',
    'PHP_WINDOWS_NT_SERVER': 'const',
    'PHP_WINDOWS_NT_WORKSTATION': 'const',
    'assert_options': 'function',
    'assert': 'function',
    'cli_get_process_title': 'function',
    'cli_set_process_title': 'function',
    'dl': 'function',
    'extension_loaded': 'function',
    'gc_collect_cycles': 'function',
    'gc_disable': 'function',
    'gc_enable': 'function',
    'gc_enabled': 'function',
    'get_cfg_var': 'function',
    'get_current_user': 'function',
    'get_defined_constants': 'function',
    'get_extension_funcs': 'function',
    'get_include_path': 'function',
    'get_included_files': 'function',
    'get_loaded_extensions': 'function',
    'get_magic_quotes_gpc': 'function',
    'get_magic_quotes_runtime': 'function',
    'get_required_files': 'function',
    'getenv': 'function',
    'getlastmod': 'function',
    'getmygid': 'function',
    'getmyinode': 'function',
    'getmypid': 'function',
    'getmyuid': 'function',
    'getopt': 'function',
    'getrusage': 'function',
    'ini_alter': 'function',
    'ini_get_all': 'function',
    'ini_get': 'function',
    'ini_restore': 'function',
    'ini_set': 'function',
    'magic_quotes_runtime': 'function',
    'main': 'function',
    'memory_get_peak_usage': 'function',
    'memory_get_usage': 'function',
    'php_ini_loaded_file': 'function',
    'php_ini_scanned_files': 'function',
    'php_logo_guid': 'function',
    'php_sapi_name': 'function',
    'php_uname': 'function',
    'phpcredits': 'function',
    'phpinfo': 'function',
    'phpversion': 'function',
    'putenv': 'function',
    'restore_include_path': 'function',
    'set_include_path': 'function',
    'set_magic_quotes_runtime': 'function',
    'set_time_limit': 'function',
    'sys_get_temp_dir': 'function',
    'version_compare': 'function',
    'zend_logo_guid': 'function',
    'zend_thread_id': 'function',
    'zend_version': 'function',

    /* Text Processing */
    'BBCODE_TYPE_NOARG': 'const',
    'BBCODE_TYPE_SINGLE': 'const',
    'BBCODE_TYPE_ARG': 'const',
    'BBCODE_TYPE_OPTARG': 'const',
    'BBCODE_TYPE_ROOT': 'const',
    'BBCODE_FLAGS_ARG_PARSING': 'const',
    'BBCODE_FLAGS_CDATA_NOT_ALLOWED': 'const',
    'BBCODE_FLAGS_SMILEYS_ON': 'const',
    'BBCODE_FLAGS_SMILEYS_OFF': 'const',
    'BBCODE_FLAGS_ONE_OPEN_PER_LEVEL': 'const',
    'BBCODE_FLAGS_REMOVE_IF_EMPTY': 'const',
    'BBCODE_FLAGS_DENY_REOPEN_CHILD': 'const',
    'BBCODE_ARG_DOUBLE_QUOTE': 'const',
    'BBCODE_ARG_SINGLE_QUOTE': 'const',
    'BBCODE_ARG_HTML_QUOTE': 'const',
    'BBCODE_ARG_QUOTE_ESCAPING': 'const',
    'BBCODE_AUTO_CORRECT': 'const',
    'BBCODE_CORRECT_REOPEN_TAGS': 'const',
    'BBCODE_DISABLE_TREE_BUILD': 'const',
    'BBCODE_DEFAULT_SMILEYS_ON': 'const',
    'BBCODE_DEFAULT_SMILEYS_OFF': 'const',
    'BBCODE_FORCE_SMILEYS_OFF': 'const',
    'BBCODE_SMILEYS_CASE_INSENSITIVE': 'const',
    'BBCODE_SET_FLAGS_SET': 'const',
    'BBCODE_SET_FLAGS_ADD': 'const',
    'BBCODE_SET_FLAGS_REMOVE': 'const',
    'bbcode_add_element': 'function',
    'bbcode_add_smiley': 'function',
    'bbcode_create': 'function',
    'bbcode_destroy': 'function',
    'bbcode_parse': 'function',
    'bbcode_set_arg_parser': 'function',
    'bbcode_set_flags': 'function',
    'PREG_PATTERN_ORDER': 'const',
    'PREG_SET_ORDER': 'const',
    'PREG_OFFSET_CAPTURE': 'const',
    'PREG_SPLIT_NO_EMPTY': 'const',
    'PREG_SPLIT_DELIM_CAPTURE': 'const',
    'PREG_SPLIT_OFFSET_CAPTURE': 'const',
    'PREG_NO_ERROR': 'const',
    'PREG_INTERNAL_ERROR': 'const',
    'PREG_BACKTRACK_LIMIT_ERROR': 'const',
    'PREG_RECURSION_LIMIT_ERROR': 'const',
    'PREG_BAD_UTF8_ERROR': 'const',
    'PREG_BAD_UTF8_OFFSET_ERROR': 'const',
    'PCRE_VERSION': 'const',
    'preg_filter': 'function',
    'preg_grep': 'function',
    'preg_last_error': 'function',
    'preg_match_all': 'function',
    'preg_match': 'function',
    'preg_quote': 'function',
    'preg_replace_callback_array': 'function',
    'preg_replace_callback': 'function',
    'preg_replace': 'function',
    'preg_split': 'function',
    'ereg_replace': 'function',
    'ereg': 'function',
    'eregi_replace': 'function',
    'eregi': 'function',
    'split': 'function',
    'spliti': 'function',
    'sql_regcase': 'function',
    'ssdeep_fuzzy_compare': 'function',
    'ssdeep_fuzzy_hash_filename': 'function',
    'ssdeep_fuzzy_hash': 'function',
    'CRYPT_SALT_LENGTH': 'const',
    'CRYPT_STD_DES': 'const',
    'CRYPT_EXT_DES': 'const',
    'CRYPT_MD5': 'const',
    'CRYPT_BLOWFISH': 'const',
    'HTML_SPECIALCHARS': 'const',
    'HTML_ENTITIES': 'const',
    'ENT_COMPAT': 'const',
    'ENT_QUOTES': 'const',
    'ENT_NOQUOTES': 'const',
    'ENT_IGNORE': 'const',
    'ENT_SUBSTITUTE': 'const',
    'ENT_DISALLOWED': 'const',
    'ENT_HTML401': 'const',
    'ENT_XML1': 'const',
    'ENT_XHTML': 'const',
    'ENT_HTML5': 'const',
    'CHAR_MAX': 'const',
    'LC_CTYPE': 'const',
    'LC_NUMERIC': 'const',
    'LC_TIME': 'const',
    'LC_COLLATE': 'const',
    'LC_MONETARY': 'const',
    'LC_ALL': 'const',
    'LC_MESSAGES': 'const',
    'STR_PAD_LEFT': 'const',
    'STR_PAD_RIGHT': 'const',
    'STR_PAD_BOTH': 'const',
    'addcslashes': 'function',
    'addslashes': 'function',
    'bin2hex': 'function',
    'chop': 'function',
    'chr': 'function',
    'chunk_split': 'function',
    'convert_cyr_string': 'function',
    'convert_uudecode': 'function',
    'convert_uuencode': 'function',
    'count_chars': 'function',
    'crc32': 'function',
    'crypt': 'function',
    'echo': 'function',
    'explode': 'function',
    'fprintf': 'function',
    'get_html_translation_table': 'function',
    'hebrev': 'function',
    'hebrevc': 'function',
    'hex2bin': 'function',
    'html_entity_decode': 'function',
    'htmlentities': 'function',
    'htmlspecialchars_decode': 'function',
    'htmlspecialchars': 'function',
    'implode': 'function',
    'join': 'function',
    'lcfirst': 'function',
    'levenshtein': 'function',
    'localeconv': 'function',
    'ltrim': 'function',
    'md5_file': 'function',
    'md5': 'function',
    'metaphone': 'function',
    'money_format': 'function',
    'nl_langinfo': 'function',
    'nl2br': 'function',
    'number_format': 'function',
    'ord': 'function',
    'parse_str': 'function',
    'print': 'function',
    'printf': 'function',
    'quoted_printable_decode': 'function',
    'quoted_printable_encode': 'function',
    'quotemeta': 'function',
    'rtrim': 'function',
    'setlocale': 'function',
    'sha1_file': 'function',
    'sha1': 'function',
    'similar_text': 'function',
    'soundex': 'function',
    'sprintf': 'function',
    'sscanf': 'function',
    'str_getcsv': 'function',
    'str_ireplace': 'function',
    'str_pad': 'function',
    'str_repeat': 'function',
    'str_replace': 'function',
    'str_rot13': 'function',
    'str_shuffle': 'function',
    'str_split': 'function',
    'str_word_count': 'function',
    'strcasecmp': 'function',
    'strchr': 'function',
    'strcmp': 'function',
    'strcoll': 'function',
    'strcspn': 'function',
    'strip_tags': 'function',
    'stripcslashes': 'function',
    'stripos': 'function',
    'stripslashes': 'function',
    'stristr': 'function',
    'strlen': 'function',
    'strnatcasecmp': 'function',
    'strnatcmp': 'function',
    'strncasecmp': 'function',
    'strncmp': 'function',
    'strpbrk': 'function',
    'strpos': 'function',
    'strrchr': 'function',
    'strrev': 'function',
    'strripos': 'function',
    'strrpos': 'function',
    'strspn': 'function',
    'strstr': 'function',
    'strtok': 'function',
    'strtolower': 'function',
    'strtoupper': 'function',
    'strtr': 'function',
    'substr_compare': 'function',
    'substr_count': 'function',
    'substr_replace': 'function',
    'substr': 'function',
    'trim': 'function',
    'ucfirst': 'function',
    'ucwords': 'function',
    'vfprintf': 'function',
    'vprintf': 'function',
    'vsprintf': 'function',
    'wordwrap': 'function',

    /* Mail Related Extensions */
    'CYRUS_CONN_NONSYNCLITERAL': 'const',
    'CYRUS_CONN_INITIALRESPONSE': 'const',
    'CYRUS_CALLBACK_NUMBERED': 'const',
    'CYRUS_CALLBACK_NOLITERAL': 'const',
    'cyrus_authenticate': 'function',
    'cyrus_bind': 'function',
    'cyrus_close': 'function',
    'cyrus_connect': 'function',
    'cyrus_query': 'function',
    'cyrus_unbind': 'function',
    'NIL': 'const',
    'OP_DEBUG': 'const',
    'OP_READONLY': 'const',
    'OP_ANONYMOUS': 'const',
    'OP_SHORTCACHE': 'const',
    'OP_SILENT': 'const',
    'OP_PROTOTYPE': 'const',
    'OP_HALFOPEN': 'const',
    'OP_EXPUNGE': 'const',
    'OP_SECURE': 'const',
    'CL_EXPUNGE': 'const',
    'FT_UID': 'const',
    'FT_PEEK': 'const',
    'FT_NOT': 'const',
    'FT_INTERNAL': 'const',
    'FT_PREFETCHTEXT': 'const',
    'ST_UID': 'const',
    'ST_SILENT': 'const',
    'ST_SET': 'const',
    'CP_UID': 'const',
    'CP_MOVE': 'const',
    'SE_UID': 'const',
    'SE_FREE': 'const',
    'SE_NOPREFETCH': 'const',
    'SO_FREE': 'const',
    'SO_NOSERVER': 'const',
    'SA_MESSAGES': 'const',
    'SA_RECENT': 'const',
    'SA_UNSEEN': 'const',
    'SA_UIDNEXT': 'const',
    'SA_UIDVALIDITY': 'const',
    'SA_ALL': 'const',
    'LATT_NOINFERIORS': 'const',
    'LATT_NOSELECT': 'const',
    'LATT_MARKED': 'const',
    'LATT_UNMARKED': 'const',
    'SORTDATE': 'const',
    'SORTARRIVAL': 'const',
    'SORTFROM': 'const',
    'SORTSUBJECT': 'const',
    'SORTTO': 'const',
    'SORTCC': 'const',
    'SORTSIZE': 'const',
    'TYPETEXT': 'const',
    'TYPEMULTIPART': 'const',
    'TYPEMESSAGE': 'const',
    'TYPEAPPLICATION': 'const',
    'TYPEAUDIO': 'const',
    'TYPEIMAGE': 'const',
    'TYPEVIDEO': 'const',
    'TYPEMODEL': 'const',
    'TYPEOTHER': 'const',
    'ENC7BIT': 'const',
    'ENC8BIT': 'const',
    'ENCBINARY': 'const',
    'ENCBASE64': 'const',
    'ENCQUOTEDPRINTABLE': 'const',
    'ENCOTHER': 'const',
    'IMAP_OPENTIMEOUT': 'const',
    'IMAP_READTIMEOUT': 'const',
    'IMAP_WRITETIMEOUT': 'const',
    'IMAP_CLOSETIMEOUT': 'const',
    'LATT_REFERRAL': 'const',
    'LATT_HASCHILDREN': 'const',
    'LATT_HASNOCHILDREN': 'const',
    'IMAP_GC_ELT': 'const',
    'IMAP_GC_ENV': 'const',
    'IMAP_GC_TEXTS': 'const',
    'imap_8bit': 'function',
    'imap_alerts': 'function',
    'imap_append': 'function',
    'imap_base64': 'function',
    'imap_binary': 'function',
    'imap_body': 'function',
    'imap_bodystruct': 'function',
    'imap_check': 'function',
    'imap_clearflag_full': 'function',
    'imap_close': 'function',
    'imap_create': 'function',
    'imap_createmailbox': 'function',
    'imap_delete': 'function',
    'imap_deletemailbox': 'function',
    'imap_errors': 'function',
    'imap_expunge': 'function',
    'imap_fetch_overview': 'function',
    'imap_fetchbody': 'function',
    'imap_fetchheader': 'function',
    'imap_fetchmime': 'function',
    'imap_fetchstructure': 'function',
    'imap_fetchtext': 'function',
    'imap_gc': 'function',
    'imap_get_quota': 'function',
    'imap_get_quotaroot': 'function',
    'imap_getacl': 'function',
    'imap_getmailboxes': 'function',
    'imap_getsubscribed': 'function',
    'imap_header': 'function',
    'imap_headerinfo': 'function',
    'imap_headers': 'function',
    'imap_last_error': 'function',
    'imap_list': 'function',
    'imap_listmailbox': 'function',
    'imap_listscan': 'function',
    'imap_listsubscribed': 'function',
    'imap_lsub': 'function',
    'imap_mail_compose': 'function',
    'imap_mail_copy': 'function',
    'imap_mail_move': 'function',
    'imap_mail': 'function',
    'imap_mailboxmsginfo': 'function',
    'imap_mime_header_decode': 'function',
    'imap_msgno': 'function',
    'imap_num_msg': 'function',
    'imap_num_recent': 'function',
    'imap_open': 'function',
    'imap_ping': 'function',
    'imap_qprint': 'function',
    'imap_rename': 'function',
    'imap_renamemailbox': 'function',
    'imap_reopen': 'function',
    'imap_rfc822_parse_adrlist': 'function',
    'imap_rfc822_parse_headers': 'function',
    'imap_rfc822_write_address': 'function',
    'imap_savebody': 'function',
    'imap_scan': 'function',
    'imap_scanmailbox': 'function',
    'imap_search': 'function',
    'imap_set_quota': 'function',
    'imap_setacl': 'function',
    'imap_setflag_full': 'function',
    'imap_sort': 'function',
    'imap_status': 'function',
    'imap_subscribe': 'function',
    'imap_thread': 'function',
    'imap_timeout': 'function',
    'imap_uid': 'function',
    'imap_undelete': 'function',
    'imap_unsubscribe': 'function',
    'imap_utf7_decode': 'function',
    'imap_utf7_encode': 'function',
    'imap_utf8': 'function',
    'ezmlm_hash': 'function',
    'mail': 'function',
    'MAILPARSE_EXTRACT_OUTPUT': 'const',
    'MAILPARSE_EXTRACT_STREAM': 'const',
    'MAILPARSE_EXTRACT_RETURN': 'const',
    'mailparse_determine_best_xfer_encoding': 'function',
    'mailparse_msg_create': 'function',
    'mailparse_msg_extract_part_file': 'function',
    'mailparse_msg_extract_part': 'function',
    'mailparse_msg_extract_whole_part_file': 'function',
    'mailparse_msg_free': 'function',
    'mailparse_msg_get_part_data': 'function',
    'mailparse_msg_get_part': 'function',
    'mailparse_msg_get_structure': 'function',
    'mailparse_msg_parse_file': 'function',
    'mailparse_msg_parse': 'function',
    'mailparse_rfc822_parse_addresses': 'function',
    'mailparse_stream_encode': 'function',
    'mailparse_uudecode_all': 'function',
    'vpopmail_add_alias_domain_ex': 'function',
    'vpopmail_add_alias_domain': 'function',
    'vpopmail_add_domain_ex': 'function',
    'vpopmail_add_domain': 'function',
    'vpopmail_add_user': 'function',
    'vpopmail_alias_add': 'function',
    'vpopmail_alias_del_domain': 'function',
    'vpopmail_alias_del': 'function',
    'vpopmail_alias_get_all': 'function',
    'vpopmail_alias_get': 'function',
    'vpopmail_auth_user': 'function',
    'vpopmail_del_domain_ex': 'function',
    'vpopmail_del_domain': 'function',
    'vpopmail_del_user': 'function',
    'vpopmail_error': 'function',
    'vpopmail_passwd': 'function',
    'vpopmail_set_user_quota': 'function',

    /* Mathematical Extensions */
    'M_PI': 'const',
    'M_E': 'const',
    'M_LOG2E': 'const',
    'M_LOG10E': 'const',
    'M_LN2': 'const',
    'M_LN10': 'const',
    'M_PI_2': 'const',
    'M_PI_4': 'const',
    'M_1_PI': 'const',
    'M_2_PI': 'const',
    'M_SQRTPI': 'const',
    'M_2_SQRTPI': 'const',
    'M_SQRT2': 'const',
    'M_SQRT3': 'const',
    'M_SQRT1_2': 'const',
    'M_LNPI': 'const',
    'M_EULER': 'const',
    'PHP_ROUND_HALF_UP': 'const',
    'PHP_ROUND_HALF_DOWN': 'const',
    'PHP_ROUND_HALF_EVEN': 'const',
    'PHP_ROUND_HALF_ODD': 'const',
    'NAN': 'const',
    'INF': 'const',
    'abs': 'function',
    'acos': 'function',
    'acosh': 'function',
    'asin': 'function',
    'asinh': 'function',
    'atan2': 'function',
    'atan': 'function',
    'atanh': 'function',
    'base_convert': 'function',
    'bindec': 'function',
    'ceil': 'function',
    'cos': 'function',
    'cosh': 'function',
    'decbin': 'function',
    'dechex': 'function',
    'decoct': 'function',
    'deg2rad': 'function',
    'exp': 'function',
    'expm1': 'function',
    'floor': 'function',
    'fmod': 'function',
    'getrandmax': 'function',
    'hexdec': 'function',
    'hypot': 'function',
    'intdiv': 'function',
    'is_finite': 'function',
    'is_infinite': 'function',
    'is_nan': 'function',
    'lcg_value': 'function',
    'log10': 'function',
    'log1p': 'function',
    'log': 'function',
    'max': 'function',
    'min': 'function',
    'mt_getrandmax': 'function',
    'mt_rand': 'function',
    'mt_srand': 'function',
    'octdec': 'function',
    'pi': 'function',
    'pow': 'function',
    'rad2deg': 'function',
    'rand': 'function',
    'round': 'function',
    'sin': 'function',
    'sinh': 'function',
    'sqrt': 'function',
    'srand': 'function',
    'tan': 'function',
    'tanh': 'function',

    /* Other Basic Extensions */
    'GEOIP_COUNTRY_EDITION': 'const',
    'GEOIP_REGION_EDITION_REV0': 'const',
    'GEOIP_CITY_EDITION_REV0': 'const',
    'GEOIP_ORG_EDITION': 'const',
    'GEOIP_ISP_EDITION': 'const',
    'GEOIP_CITY_EDITION_REV1': 'const',
    'GEOIP_REGION_EDITION_REV1': 'const',
    'GEOIP_PROXY_EDITION': 'const',
    'GEOIP_ASNUM_EDITION': 'const',
    'GEOIP_NETSPEED_EDITION': 'const',
    'GEOIP_DOMAIN_EDITION': 'const',
    'GEOIP_UNKNOWN_SPEED': 'const',
    'GEOIP_DIALUP_SPEED': 'const',
    'GEOIP_CABLEDSL_SPEED': 'const',
    'GEOIP_CORPORATE_SPEED': 'const',
    'geoip_asnum_by_name': 'function',
    'geoip_continent_code_by_name': 'function',
    'geoip_country_code_by_name': 'function',
    'geoip_country_code3_by_name': 'function',
    'geoip_country_name_by_name': 'function',
    'geoip_database_info': 'function',
    'geoip_db_avail': 'function',
    'geoip_db_filename': 'function',
    'geoip_db_get_all_info': 'function',
    'geoip_domain_by_name': 'function',
    'geoip_id_by_name': 'function',
    'geoip_isp_by_name': 'function',
    'geoip_netspeedcell_by_name': 'function',
    'geoip_org_by_name': 'function',
    'geoip_record_by_name': 'function',
    'geoip_region_by_name': 'function',
    'geoip_region_name_by_code': 'function',
    'geoip_setup_custom_directory': 'function',
    'geoip_time_zone_by_country_and_region': 'function',
    'JsonSerializable': 'class',
    'JSON_ERROR_NONE': 'const',
    'JSON_ERROR_DEPTH': 'const',
    'JSON_ERROR_STATE_MISMATCH': 'const',
    'JSON_ERROR_CTRL_CHAR': 'const',
    'JSON_ERROR_SYNTAX': 'const',
    'JSON_ERROR_UTF8': 'const',
    'JSON_ERROR_RECURSION': 'const',
    'JSON_ERROR_INF_OR_NAN': 'const',
    'JSON_ERROR_UNSUPPORTED_TYPE': 'const',
    'JSON_HEX_TAG': 'const',
    'JSON_HEX_AMP': 'const',
    'JSON_HEX_APOS': 'const',
    'JSON_HEX_QUOT': 'const',
    'JSON_FORCE_OBJECT': 'const',
    'JSON_NUMERIC_CHECK': 'const',
    'JSON_BIGINT_AS_STRING': 'const',
    'JSON_PRETTY_PRINT': 'const',
    'JSON_UNESCAPED_SLASHES': 'const',
    'JSON_UNESCAPED_UNICODE': 'const',
    'JSON_PARTIAL_OUTPUT_ON_ERROR': 'const',
    'JSON_PRESERVE_ZERO_FRACTION': 'const',
    'json_decode': 'function',
    'json_encode': 'function',
    'json_last_error_msg': 'function',
    'json_last_error': 'function',
    'PHP_URL_SCHEME': 'const',
    'PHP_URL_HOST': 'const',
    'PHP_URL_PORT': 'const',
    'PHP_URL_USER': 'const',
    'PHP_URL_PASS': 'const',
    'PHP_URL_PATH': 'const',
    'PHP_URL_QUERY': 'const',
    'PHP_URL_FRAGMENT': 'const',
    'PHP_QUERY_RFC1738': 'const',
    'PHP_QUERY_RFC3986': 'const',
    'base64_decode': 'function',
    'base64_encode': 'function',
    'get_headers': 'function',
    'get_meta_tags': 'function',
    'http_build_query': 'function',
    'parse_url': 'function',
    'rawurldecode': 'function',
    'rawurlencode': 'function',
    'urldecode': 'function',
    'urlencode': 'function',
    'YAML_ANY_SCALAR_STYLE': 'const',
    'YAML_PLAIN_SCALAR_STYLE': 'const',
    'YAML_SINGLE_QUOTED_SCALAR_STYLE': 'const',
    'YAML_DOUBLE_QUOTED_SCALAR_STYLE': 'const',
    'YAML_LITERAL_SCALAR_STYLE': 'const',
    'YAML_FOLDED_SCALAR_STYLE': 'const',
    'YAML_NULL_TAG': 'const',
    'YAML_BOOL_TAG': 'const',
    'YAML_STR_TAG': 'const',
    'YAML_INT_TAG': 'const',
    'YAML_FLOAT_TAG': 'const',
    'YAML_TIMESTAMP_TAG': 'const',
    'YAML_SEQ_TAG': 'const',
    'YAML_MAP_TAG': 'const',
    'YAML_PHP_TAG': 'const',
    'YAML_ANY_ENCODING': 'const',
    'YAML_UTF8_ENCODING': 'const',
    'YAML_UTF16LE_ENCODING': 'const',
    'YAML_UTF16BE_ENCODING': 'const',
    'YAML_ANY_BREAK': 'const',
    'YAML_CR_BREAK': 'const',
    'YAML_LN_BREAK': 'const',
    'YAML_CRLN_BREAK': 'const',
    'yaml_emit_file': 'function',
    'yaml_emit': 'function',
    'yaml_parse_file': 'function',
    'yaml_parse_url': 'function',
    'yaml_parse': 'function',

    /* Other Services */
    'CURLFile': 'class',
    'CURLOPT_AUTOREFERER': 'const',
    'CURLOPT_COOKIESESSION': 'const',
    'CURLOPT_DNS_USE_GLOBAL_CACHE': 'const',
    'CURLOPT_DNS_CACHE_TIMEOUT': 'const',
    'CURLOPT_FTP_SSL': 'const',
    'CURLFTPSSL_TRY': 'const',
    'CURLFTPSSL_ALL': 'const',
    'CURLFTPSSL_CONTROL': 'const',
    'CURLFTPSSL_NONE': 'const',
    'CURLOPT_PRIVATE': 'const',
    'CURLOPT_FTPSSLAUTH': 'const',
    'CURLOPT_PORT': 'const',
    'CURLOPT_FILE': 'const',
    'CURLOPT_INFILE': 'const',
    'CURLOPT_INFILESIZE': 'const',
    'CURLOPT_URL': 'const',
    'CURLOPT_PROXY': 'const',
    'CURLOPT_VERBOSE': 'const',
    'CURLOPT_HEADER': 'const',
    'CURLOPT_HTTPHEADER': 'const',
    'CURLOPT_NOPROGRESS': 'const',
    'CURLOPT_NOBODY': 'const',
    'CURLOPT_FAILONERROR': 'const',
    'CURLOPT_UPLOAD': 'const',
    'CURLOPT_POST': 'const',
    'CURLOPT_FTPLISTONLY': 'const',
    'CURLOPT_FTPAPPEND': 'const',
    'CURLOPT_FTP_CREATE_MISSING_DIRS': 'const',
    'CURLOPT_NETRC': 'const',
    'CURLOPT_FOLLOWLOCATION': 'const',
    'CURLOPT_FTPASCII': 'const',
    'CURLOPT_PUT': 'const',
    'CURLOPT_MUTE': 'const',
    'CURLOPT_USERPWD': 'const',
    'CURLOPT_PROXYUSERPWD': 'const',
    'CURLOPT_RANGE': 'const',
    'CURLOPT_TIMEOUT': 'const',
    'CURLOPT_TIMEOUT_MS': 'const',
    'CURLOPT_TCP_NODELAY': 'const',
    'CURLOPT_POSTFIELDS': 'const',
    'CURLOPT_PROGRESSFUNCTION': 'const',
    'CURLOPT_REFERER': 'const',
    'CURLOPT_USERAGENT': 'const',
    'CURLOPT_FTPPORT': 'const',
    'CURLOPT_FTP_USE_EPSV': 'const',
    'CURLOPT_LOW_SPEED_LIMIT': 'const',
    'CURLOPT_LOW_SPEED_TIME': 'const',
    'CURLOPT_RESUME_FROM': 'const',
    'CURLOPT_COOKIE': 'const',
    'CURLOPT_SSLCERT': 'const',
    'CURLOPT_SSLCERTPASSWD': 'const',
    'CURLOPT_WRITEHEADER': 'const',
    'CURLOPT_SSL_VERIFYHOST': 'const',
    'CURLOPT_COOKIEFILE': 'const',
    'CURLOPT_SSLVERSION': 'const',
    'CURL_SSLVERSION_DEFAULT': 'const',
    'CURL_SSLVERSION_TLSv1': 'const',
    'CURL_SSLVERSION_SSLv2': 'const',
    'CURL_SSLVERSION_SSLv3': 'const',
    'CURL_SSLVERSION_TLSv1_0': 'const',
    'CURL_SSLVERSION_TLSv1_1': 'const',
    'CURL_SSLVERSION_TLSv1_2': 'const',
    'CURLOPT_TIMECONDITION': 'const',
    'CURLOPT_TIMEVALUE': 'const',
    'CURLOPT_CUSTOMREQUEST': 'const',
    'CURLOPT_STDERR': 'const',
    'CURLOPT_TRANSFERTEXT': 'const',
    'CURLOPT_RETURNTRANSFER': 'const',
    'CURLOPT_QUOTE': 'const',
    'CURLOPT_POSTQUOTE': 'const',
    'CURLOPT_INTERFACE': 'const',
    'CURLOPT_KRB4LEVEL': 'const',
    'CURLOPT_HTTPPROXYTUNNEL': 'const',
    'CURLOPT_FILETIME': 'const',
    'CURLOPT_WRITEFUNCTION': 'const',
    'CURLOPT_READFUNCTION': 'const',
    'CURLOPT_PASSWDFUNCTION': 'const',
    'CURLOPT_HEADERFUNCTION': 'const',
    'CURLOPT_MAXREDIRS': 'const',
    'CURLOPT_MAXCONNECTS': 'const',
    'CURLOPT_CLOSEPOLICY': 'const',
    'CURLOPT_FRESH_CONNECT': 'const',
    'CURLOPT_FORBID_REUSE': 'const',
    'CURLOPT_RANDOM_FILE': 'const',
    'CURLOPT_EGDSOCKET': 'const',
    'CURLOPT_CONNECTTIMEOUT': 'const',
    'CURLOPT_CONNECTTIMEOUT_MS': 'const',
    'CURLOPT_SSL_VERIFYPEER': 'const',
    'CURLOPT_CAINFO': 'const',
    'CURLOPT_CAPATH': 'const',
    'CURLOPT_COOKIEJAR': 'const',
    'CURLOPT_SSL_CIPHER_LIST': 'const',
    'CURLOPT_BINARYTRANSFER': 'const',
    'CURLOPT_NOSIGNAL': 'const',
    'CURLOPT_PROXYTYPE': 'const',
    'CURLOPT_BUFFERSIZE': 'const',
    'CURLOPT_HTTPGET': 'const',
    'CURLOPT_HTTP_VERSION': 'const',
    'CURLOPT_SSLKEY': 'const',
    'CURLOPT_SSLKEYTYPE': 'const',
    'CURLOPT_SSLKEYPASSWD': 'const',
    'CURLOPT_SSLENGINE': 'const',
    'CURLOPT_SSLENGINE_DEFAULT': 'const',
    'CURLOPT_SSLCERTTYPE': 'const',
    'CURLOPT_CRLF': 'const',
    'CURLOPT_ENCODING': 'const',
    'CURLOPT_PROXYPORT': 'const',
    'CURLOPT_UNRESTRICTED_AUTH': 'const',
    'CURLOPT_FTP_USE_EPRT': 'const',
    'CURLOPT_HTTP200ALIASES': 'const',
    'CURLOPT_HTTPAUTH': 'const',
    'CURLAUTH_BASIC': 'const',
    'CURLAUTH_DIGEST': 'const',
    'CURLAUTH_GSSNEGOTIATE': 'const',
    'CURLAUTH_NTLM': 'const',
    'CURLAUTH_ANY': 'const',
    'CURLAUTH_ANYSAFE': 'const',
    'CURLOPT_PROXYAUTH': 'const',
    'CURLOPT_MAX_RECV_SPEED_LARGE': 'const',
    'CURLOPT_MAX_SEND_SPEED_LARGE': 'const',
    'CURLCLOSEPOLICY_LEAST_RECENTLY_USED': 'const',
    'CURLCLOSEPOLICY_LEAST_TRAFFIC': 'const',
    'CURLCLOSEPOLICY_SLOWEST': 'const',
    'CURLCLOSEPOLICY_CALLBACK': 'const',
    'CURLCLOSEPOLICY_OLDEST': 'const',
    'CURLINFO_PRIVATE': 'const',
    'CURLINFO_EFFECTIVE_URL': 'const',
    'CURLINFO_HTTP_CODE': 'const',
    'CURLINFO_HEADER_OUT': 'const',
    'CURLINFO_HEADER_SIZE': 'const',
    'CURLINFO_REQUEST_SIZE': 'const',
    'CURLINFO_TOTAL_TIME': 'const',
    'CURLINFO_NAMELOOKUP_TIME': 'const',
    'CURLINFO_CONNECT_TIME': 'const',
    'CURLINFO_PRETRANSFER_TIME': 'const',
    'CURLINFO_SIZE_UPLOAD': 'const',
    'CURLINFO_SIZE_DOWNLOAD': 'const',
    'CURLINFO_SPEED_DOWNLOAD': 'const',
    'CURLINFO_SPEED_UPLOAD': 'const',
    'CURLINFO_FILETIME': 'const',
    'CURLINFO_SSL_VERIFYRESULT': 'const',
    'CURLINFO_CONTENT_LENGTH_DOWNLOAD': 'const',
    'CURLINFO_CONTENT_LENGTH_UPLOAD': 'const',
    'CURLINFO_STARTTRANSFER_TIME': 'const',
    'CURLINFO_CONTENT_TYPE': 'const',
    'CURLINFO_REDIRECT_TIME': 'const',
    'CURLINFO_REDIRECT_COUNT': 'const',
    'CURLINFO_REDIRECT_URL': 'const',
    'CURLINFO_PRIMARY_IP': 'const',
    'CURLINFO_PRIMARY_PORT': 'const',
    'CURLINFO_LOCAL_IP': 'const',
    'CURLINFO_LOCAL_PORT': 'const',
    'CURL_TIMECOND_IFMODSINCE': 'const',
    'CURL_TIMECOND_IFUNMODSINCE': 'const',
    'CURL_TIMECOND_LASTMOD': 'const',
    'CURL_VERSION_IPV6': 'const',
    'CURL_VERSION_KERBEROS4': 'const',
    'CURL_VERSION_SSL': 'const',
    'CURL_VERSION_LIBZ': 'const',
    'CURLVERSION_NOW': 'const',
    'CURLE_OK': 'const',
    'CURLE_UNSUPPORTED_PROTOCOL': 'const',
    'CURLE_FAILED_INIT': 'const',
    'CURLE_URL_MALFORMAT': 'const',
    'CURLE_URL_MALFORMAT_USER': 'const',
    'CURLE_COULDNT_RESOLVE_PROXY': 'const',
    'CURLE_COULDNT_RESOLVE_HOST': 'const',
    'CURLE_COULDNT_CONNECT': 'const',
    'CURLE_FTP_WEIRD_SERVER_REPLY': 'const',
    'CURLE_FTP_ACCESS_DENIED': 'const',
    'CURLE_FTP_USER_PASSWORD_INCORRECT': 'const',
    'CURLE_FTP_WEIRD_PASS_REPLY': 'const',
    'CURLE_FTP_WEIRD_USER_REPLY': 'const',
    'CURLE_FTP_WEIRD_PASV_REPLY': 'const',
    'CURLE_FTP_WEIRD_227_FORMAT': 'const',
    'CURLE_FTP_CANT_GET_HOST': 'const',
    'CURLE_FTP_CANT_RECONNECT': 'const',
    'CURLE_FTP_COULDNT_SET_BINARY': 'const',
    'CURLE_PARTIAL_FILE': 'const',
    'CURLE_FTP_COULDNT_RETR_FILE': 'const',
    'CURLE_FTP_WRITE_ERROR': 'const',
    'CURLE_FTP_QUOTE_ERROR': 'const',
    'CURLE_HTTP_NOT_FOUND': 'const',
    'CURLE_WRITE_ERROR': 'const',
    'CURLE_MALFORMAT_USER': 'const',
    'CURLE_FTP_COULDNT_STOR_FILE': 'const',
    'CURLE_READ_ERROR': 'const',
    'CURLE_OUT_OF_MEMORY': 'const',
    'CURLE_OPERATION_TIMEOUTED': 'const',
    'CURLE_FTP_COULDNT_SET_ASCII': 'const',
    'CURLE_FTP_PORT_FAILED': 'const',
    'CURLE_FTP_COULDNT_USE_REST': 'const',
    'CURLE_FTP_COULDNT_GET_SIZE': 'const',
    'CURLE_HTTP_RANGE_ERROR': 'const',
    'CURLE_HTTP_POST_ERROR': 'const',
    'CURLE_SSL_CONNECT_ERROR': 'const',
    'CURLE_FTP_BAD_DOWNLOAD_RESUME': 'const',
    'CURLE_FILE_COULDNT_READ_FILE': 'const',
    'CURLE_LDAP_CANNOT_BIND': 'const',
    'CURLE_LDAP_SEARCH_FAILED': 'const',
    'CURLE_LIBRARY_NOT_FOUND': 'const',
    'CURLE_FUNCTION_NOT_FOUND': 'const',
    'CURLE_ABORTED_BY_CALLBACK': 'const',
    'CURLE_BAD_FUNCTION_ARGUMENT': 'const',
    'CURLE_BAD_CALLING_ORDER': 'const',
    'CURLE_HTTP_PORT_FAILED': 'const',
    'CURLE_BAD_PASSWORD_ENTERED': 'const',
    'CURLE_TOO_MANY_REDIRECTS': 'const',
    'CURLE_UNKNOWN_TELNET_OPTION': 'const',
    'CURLE_TELNET_OPTION_SYNTAX': 'const',
    'CURLE_OBSOLETE': 'const',
    'CURLE_SSL_PEER_CERTIFICATE': 'const',
    'CURLE_GOT_NOTHING': 'const',
    'CURLE_SSL_ENGINE_NOTFOUND': 'const',
    'CURLE_SSL_ENGINE_SETFAILED': 'const',
    'CURLE_SEND_ERROR': 'const',
    'CURLE_RECV_ERROR': 'const',
    'CURLE_SHARE_IN_USE': 'const',
    'CURLE_SSL_CERTPROBLEM': 'const',
    'CURLE_SSL_CIPHER': 'const',
    'CURLE_SSL_CACERT': 'const',
    'CURLE_BAD_CONTENT_ENCODING': 'const',
    'CURLE_LDAP_INVALID_URL': 'const',
    'CURLE_FILESIZE_EXCEEDED': 'const',
    'CURLE_FTP_SSL_FAILED': 'const',
    'CURLE_SSH': 'const',
    'CURLFTPAUTH_DEFAULT': 'const',
    'CURLFTPAUTH_SSL': 'const',
    'CURLFTPAUTH_TLS': 'const',
    'CURLPROXY_HTTP': 'const',
    'CURLPROXY_SOCKS4': 'const',
    'CURLPROXY_SOCKS5': 'const',
    'CURL_NETRC_OPTIONAL': 'const',
    'CURL_NETRC_IGNORED': 'const',
    'CURL_NETRC_REQUIRED': 'const',
    'CURL_HTTP_VERSION_NONE': 'const',
    'CURL_HTTP_VERSION_1_0': 'const',
    'CURL_HTTP_VERSION_1_1': 'const',
    'CURLM_CALL_MULTI_PERFORM': 'const',
    'CURLM_OK': 'const',
    'CURLM_BAD_HANDLE': 'const',
    'CURLM_BAD_EASY_HANDLE': 'const',
    'CURLM_OUT_OF_MEMORY': 'const',
    'CURLM_INTERNAL_ERROR': 'const',
    'CURLMSG_DONE': 'const',
    'CURLOPT_KEYPASSWD': 'const',
    'CURLOPT_SSH_AUTH_TYPES': 'const',
    'CURLOPT_SSH_HOST_PUBLIC_KEY_MD5': 'const',
    'CURLOPT_SSH_PRIVATE_KEYFILE': 'const',
    'CURLOPT_SSH_PUBLIC_KEYFILE': 'const',
    'CURLMOPT_PIPELINING': 'const',
    'CURLMOPT_MAXCONNECTS': 'const',
    'CURLSSH_AUTH_ANY': 'const',
    'CURLSSH_AUTH_DEFAULT': 'const',
    'CURLSSH_AUTH_HOST': 'const',
    'CURLSSH_AUTH_KEYBOARD': 'const',
    'CURLSSH_AUTH_NONE': 'const',
    'CURLSSH_AUTH_PASSWORD': 'const',
    'CURLSSH_AUTH_PUBLICKEY': 'const',
    'CURL_WRAPPERS_ENABLED': 'const',
    'CURLPAUSE_ALL': 'const',
    'CURLPAUSE_CONT': 'const',
    'CURLPAUSE_RECV': 'const',
    'CURLPAUSE_RECV_CONT': 'const',
    'CURLPAUSE_SEND': 'const',
    'CURLPAUSE_SEND_CONT': 'const',
    'CURLPIPE_NOTHING': 'const',
    'CURLPIPE_HTTP1': 'const',
    'CURLPIPE_MULTIPLEX': 'const',
    'CURLPROXY_SOCKS4A': 'const',
    'CURLPROXY_SOCKS5_HOSTNAME': 'const',
    'curl_close': 'function',
    'curl_copy_handle': 'function',
    'curl_errno': 'function',
    'curl_error': 'function',
    'curl_escape': 'function',
    'curl_exec': 'function',
    'curl_file_create': 'function',
    'curl_getinfo': 'function',
    'curl_init': 'function',
    'curl_multi_add_handle': 'function',
    'curl_multi_close': 'function',
    'curl_multi_exec': 'function',
    'curl_multi_getcontent': 'function',
    'curl_multi_info_read': 'function',
    'curl_multi_init': 'function',
    'curl_multi_remove_handle': 'function',
    'curl_multi_select': 'function',
    'curl_multi_setopt': 'function',
    'curl_multi_strerror': 'function',
    'curl_pause': 'function',
    'curl_reset': 'function',
    'curl_setopt_array': 'function',
    'curl_setopt': 'function',
    'curl_share_close': 'function',
    'curl_share_init': 'function',
    'curl_share_setopt': 'function',
    'curl_strerror': 'function',
    'curl_unescape': 'function',
    'curl_version': 'function',
    'FTP_ASCII': 'const',
    'FTP_TEXT': 'const',
    'FTP_BINARY': 'const',
    'FTP_IMAGE': 'const',
    'FTP_TIMEOUT_SEC': 'const',
    'FTP_AUTOSEEK': 'const',
    'FTP_AUTORESUME': 'const',
    'FTP_FAILED': 'const',
    'FTP_FINISHED': 'const',
    'FTP_MOREDATA': 'const',
    'ftp_alloc': 'function',
    'ftp_cdup': 'function',
    'ftp_chdir': 'function',
    'ftp_chmod': 'function',
    'ftp_close': 'function',
    'ftp_connect': 'function',
    'ftp_delete': 'function',
    'ftp_exec': 'function',
    'ftp_fget': 'function',
    'ftp_fput': 'function',
    'ftp_get_option': 'function',
    'ftp_get': 'function',
    'ftp_login': 'function',
    'ftp_mdtm': 'function',
    'ftp_mkdir': 'function',
    'ftp_nb_continue': 'function',
    'ftp_nb_fget': 'function',
    'ftp_nb_fput': 'function',
    'ftp_nb_get': 'function',
    'ftp_nb_put': 'function',
    'ftp_nlist': 'function',
    'ftp_pasv': 'function',
    'ftp_put': 'function',
    'ftp_pwd': 'function',
    'ftp_quit': 'function',
    'ftp_raw': 'function',
    'ftp_rawlist': 'function',
    'ftp_rename': 'function',
    'ftp_rmdir': 'function',
    'ftp_set_option': 'function',
    'ftp_site': 'function',
    'ftp_size': 'function',
    'ftp_ssl_connect': 'function',
    'ftp_systype': 'function',
    'HttpDeflateStream': 'class',
    'HttpInflateStream': 'class',
    'HttpMessage': 'class',
    'HttpQueryString': 'class',
    'HttpRequest': 'class',
    'HttpRequestPool': 'class',
    'HttpResponse': 'class',
    'HTTP_SUPPORT': 'const',
    'HTTP_SUPPORT_REQUESTS': 'const',
    'HTTP_SUPPORT_MAGICMIME': 'const',
    'HTTP_SUPPORT_ENCODINGS': 'const',
    'HTTP_SUPPORT_SSLREQUESTS': 'const',
    'HTTP_PARAMS_ALLOW_COMMA': 'const',
    'HTTP_PARAMS_ALLOW_FAILURE': 'const',
    'HTTP_PARAMS_RAISE_ERROR': 'const',
    'HTTP_PARAMS_DEFAULT': 'const',
    'HTTP_COOKIE_PARSE_RAW': 'const',
    'HTTP_COOKIE_SECURE': 'const',
    'HTTP_COOKIE_HTTPONLY': 'const',
    'HTTP_DEFLATE_LEVEL_DEF': 'const',
    'HTTP_DEFLATE_LEVEL_MIN': 'const',
    'HTTP_DEFLATE_LEVEL_MAX': 'const',
    'HTTP_DEFLATE_TYPE_ZLIB': 'const',
    'HTTP_DEFLATE_TYPE_GZIP': 'const',
    'HTTP_DEFLATE_TYPE_RAW': 'const',
    'HTTP_DEFLATE_STRATEGY_DEF': 'const',
    'HTTP_DEFLATE_STRATEGY_FILT': 'const',
    'HTTP_DEFLATE_STRATEGY_HUFF': 'const',
    'HTTP_DEFLATE_STRATEGY_RLE': 'const',
    'HTTP_DEFLATE_STRATEGY_FIXED': 'const',
    'HTTP_ENCODING_STREAM_FLUSH_NONE': 'const',
    'HTTP_ENCODING_STREAM_FLUSH_SYNC': 'const',
    'HTTP_ENCODING_STREAM_FLUSH_FULL': 'const',
    'HTTP_E_RUNTIME': 'const',
    'HTTP_E_INVALID_PARAM': 'const',
    'HTTP_E_HEADER': 'const',
    'HTTP_E_MALFORMED_HEADERS': 'const',
    'HTTP_E_REQUEST_METHOD': 'const',
    'HTTP_E_MESSAGE_TYPE': 'const',
    'HTTP_E_ENCODING': 'const',
    'HTTP_E_REQUEST': 'const',
    'HTTP_E_REQUEST_POOL': 'const',
    'HTTP_E_SOCKET': 'const',
    'HTTP_E_RESPONSE': 'const',
    'HTTP_E_URL': 'const',
    'HTTP_E_QUERYSTRING': 'const',
    'HTTP_MSG_NONE': 'const',
    'HTTP_MSG_REQUEST': 'const',
    'HTTP_MSG_RESPONSE': 'const',
    'HTTP_QUERYSTRING_TYPE_BOOL': 'const',
    'HTTP_QUERYSTRING_TYPE_INT': 'const',
    'HTTP_QUERYSTRING_TYPE_FLOAT': 'const',
    'HTTP_QUERYSTRING_TYPE_STRING': 'const',
    'HTTP_QUERYSTRING_TYPE_ARRAY': 'const',
    'HTTP_QUERYSTRING_TYPE_OBJECT': 'const',
    'HTTP_AUTH_BASIC': 'const',
    'HTTP_AUTH_DIGEST': 'const',
    'HTTP_AUTH_NTLM': 'const',
    'HTTP_AUTH_GSSNEG': 'const',
    'HTTP_AUTH_ANY': 'const',
    'HTTP_VERSION_ANY': 'const',
    'HTTP_VERSION_1_0': 'const',
    'HTTP_VERSION_1_1': 'const',
    'HTTP_SSL_VERSION_ANY': 'const',
    'HTTP_SSL_VERSION_TLSv1': 'const',
    'HTTP_SSL_VERSION_SSLv3': 'const',
    'HTTP_SSL_VERSION_SSLv2': 'const',
    'HTTP_PROXY_SOCKS4': 'const',
    'HTTP_PROXY_SOCKS5': 'const',
    'HTTP_PROXY_HTTP': 'const',
    'HTTP_IPRESOLVE_V4': 'const',
    'HTTP_IPRESOLVE_V6': 'const',
    'HTTP_IPRESOLVE_ANY': 'const',
    'HTTP_METH_GET': 'const',
    'HTTP_METH_HEAD': 'const',
    'HTTP_METH_POST': 'const',
    'HTTP_METH_PUT': 'const',
    'HTTP_METH_DELETE': 'const',
    'HTTP_METH_OPTIONS': 'const',
    'HTTP_METH_TRACE': 'const',
    'HTTP_METH_CONNECT': 'const',
    'HTTP_METH_PROPFIND': 'const',
    'HTTP_METH_PROPPATCH': 'const',
    'HTTP_METH_MKCOL': 'const',
    'HTTP_METH_COPY': 'const',
    'HTTP_METH_MOVE': 'const',
    'HTTP_METH_LOCK': 'const',
    'HTTP_METH_UNLOCK': 'const',
    'HTTP_METH_VERSION_CONTROL': 'const',
    'HTTP_METH_REPORT': 'const',
    'HTTP_METH_CHECKOUT': 'const',
    'HTTP_METH_CHECKIN': 'const',
    'HTTP_METH_UNCHECKOUT': 'const',
    'HTTP_METH_MKWORKSPACE': 'const',
    'HTTP_METH_UPDATE': 'const',
    'HTTP_METH_LABEL': 'const',
    'HTTP_METH_MERGE': 'const',
    'HTTP_METH_BASELINE_CONTROL': 'const',
    'HTTP_METH_MKACTIVITY': 'const',
    'HTTP_METH_ACL': 'const',
    'HTTP_REDIRECT': 'const',
    'HTTP_REDIRECT_PERM': 'const',
    'HTTP_REDIRECT_FOUND': 'const',
    'HTTP_REDIRECT_POST': 'const',
    'HTTP_REDIRECT_PROXY': 'const',
    'HTTP_REDIRECT_TEMP': 'const',
    'HTTP_URL_REPLACE': 'const',
    'HTTP_URL_JOIN_PATH': 'const',
    'HTTP_URL_JOIN_QUERY': 'const',
    'HTTP_URL_STRIP_USER': 'const',
    'HTTP_URL_STRIP_PASS': 'const',
    'HTTP_URL_STRIP_AUTH': 'const',
    'HTTP_URL_STRIP_PORT': 'const',
    'HTTP_URL_STRIP_PATH': 'const',
    'HTTP_URL_STRIP_QUERY': 'const',
    'HTTP_URL_STRIP_FRAGMENT': 'const',
    'HTTP_URL_STRIP_ALL': 'const',
    'http_cache_etag': 'function',
    'http_cache_last_modified': 'function',
    'http_chunked_decode': 'function',
    'http_deflate': 'function',
    'http_inflate': 'function',
    'http_build_cookie': 'function',
    'http_date': 'function',
    'http_get_request_body_stream': 'function',
    'http_get_request_body': 'function',
    'http_get_request_headers': 'function',
    'http_match_etag': 'function',
    'http_match_modified': 'function',
    'http_match_request_header': 'function',
    'http_support': 'function',
    'http_negotiate_charset': 'function',
    'http_negotiate_content_type': 'function',
    'http_negotiate_language': 'function',
    'ob_deflatehandler': 'function',
    'ob_etaghandler': 'function',
    'ob_inflatehandler': 'function',
    'http_parse_cookie': 'function',
    'http_parse_headers': 'function',
    'http_parse_message': 'function',
    'http_parse_params': 'function',
    'http_persistent_handles_clean': 'function',
    'http_persistent_handles_count': 'function',
    'http_persistent_handles_ident': 'function',
    'http_get': 'function',
    'http_head': 'function',
    'http_post_data': 'function',
    'http_post_fields': 'function',
    'http_put_data': 'function',
    'http_put_file': 'function',
    'http_put_stream': 'function',
    'http_request_body_encode': 'function',
    'http_request_method_exists': 'function',
    'http_request_method_name': 'function',
    'http_request_method_register': 'function',
    'http_request_method_unregister': 'function',
    'http_request': 'function',
    'http_redirect': 'function',
    'http_send_content_disposition': 'function',
    'http_send_content_type': 'function',
    'http_send_data': 'function',
    'http_send_file': 'function',
    'http_send_last_modified': 'function',
    'http_send_status': 'function',
    'http_send_stream': 'function',
    'http_throttle': 'function',
    'http_build_str': 'function',
    'http_build_url': 'function'
  };

}).call(this);
return exports;})();
require["./nodes"] = (function() {var exports = {}, module = {exports: exports};// Generated by CoffeeScript 1.9.3
(function() {
  var Access, Array, ArrayKey, Assign, Base, Block, Break, Call, Class, ClassLine, Clone, Code, Constant, Context, Continue, Declare, Delete, Document, Echo, Else, ElseIf, Existence, Expression, For, GetKeyAssign, Goto, HereDoc, Identifier, If, Include, Interface, Literal, Namespace, NewExpression, Operation, Param, Parens, QualifiedName, Range, RawText, Require, Return, Script, Section, Slice, Switch, Throw, Try, Unary, Update, Value, While, mammouthFunction, typeCasting,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Context = require('./context');

  Base = (function() {
    function Base() {}

    Base.prototype.prepare = function() {
      return this;
    };

    Base.prototype.compile = function() {};

    return Base;

  })();

  Document = exports.Document = (function(superClass) {
    extend(Document, superClass);

    function Document(sections) {
      this.type = 'Document';
      this.sections = sections;
    }

    Document.prototype.prepare = function() {
      return this;
    };

    Document.prototype.compile = function(system) {
      var code, j, len1, ref, section;
      code = '';
      ref = this.sections;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        section = ref[j];
        code += section.prepare(system).compile(system);
      }
      if (system.config.addMammouth) {
        code = mammouthFunction + code;
      }
      return code;
    };

    return Document;

  })(Base);

  RawText = exports.RawText = (function(superClass) {
    extend(RawText, superClass);

    function RawText(text) {
      if (text == null) {
        text = '';
      }
      this.type = 'RawText';
      this.text = text;
    }

    RawText.prototype.compile = function() {
      return this.text;
    };

    return RawText;

  })(Base);

  Script = exports.Script = (function(superClass) {
    extend(Script, superClass);

    function Script(block) {
      this.type = 'Script';
      this.body = block;
    }

    Script.prototype.prepare = function() {
      this.body.braces = false;
      return this;
    };

    Script.prototype.compile = function(system) {
      var code;
      code = '<?php';
      code += this.body.prepare(system).compile(system);
      code += '?>';
      return code;
    };

    return Script;

  })(Base);

  Block = exports.Block = (function(superClass) {
    extend(Block, superClass);

    function Block(instructions) {
      if (instructions == null) {
        instructions = [];
      }
      this.type = 'Block';
      this.body = instructions;
      this.braces = true;
      this.expands = false;
    }

    Block.prototype.activateReturn = function(returnGen) {
      var lastIndex;
      if (returnGen == null) {
        returnGen = Express;
      }
      if (this.body.length === 0) {
        return;
      }
      lastIndex = this.body.length - 1;
      switch (this.body[lastIndex].type) {
        case 'For':
        case 'If':
        case 'Switch':
        case 'Try':
        case 'While':
          return this.body[lastIndex].activateReturn(returnGen);
        case 'Break':
        case 'Declare':
        case 'Echo':
        case 'Goto':
        case 'Interface':
        case 'Namespace':
        case 'Section':
        case 'Throw':
          break;
        case 'Return':
          if (this.body[lastIndex].value === false) {
            return this.body.pop();
          }
          break;
        default:
          return this.body[lastIndex] = returnGen(this.body[lastIndex]);
      }
    };

    Block.prototype.prepare = function() {
      var expression, i, instruction, j, len1, ref;
      ref = this.body;
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        instruction = ref[i];
        instruction.isStatement = true;
        switch (instruction.type) {
          case 'Assign':
          case 'Call':
          case 'Clone':
          case 'Code':
          case 'Goto':
          case 'Break':
          case 'Constant':
          case 'Continue':
          case 'Declare':
          case 'Delete':
          case 'GetKeyAssign':
          case 'Echo':
          case 'Include':
          case 'Namespace':
          case 'NewExpression':
          case 'Operation':
          case 'Require':
          case 'Return':
          case 'Throw':
          case 'typeCasting':
          case 'Value':
            if (instruction.type === 'Code' && instruction.body !== false) {
              break;
            }
            if (instruction.type === 'Namespace' && instruction.body !== false) {
              break;
            }
            if (instruction.type === 'Declare' && instruction.script !== false) {
              break;
            }
            if (instruction.type === 'Value' && instruction.value.type === 'Parens' && instruction.properties.length === 0) {
              instruction = instruction.value.expression;
            }
            expression = new Expression(instruction);
            expression.isStatement = true;
            this.body[i] = expression;
        }
      }
      return this;
    };

    Block.prototype.compile = function(system) {
      var code, i, instruction, j, len1, ref;
      if (this.braces && this.body.length === 0) {
        return '{}';
      }
      code = '';
      if (this.braces) {
        code += '{';
      }
      if (this.body.length === 1 && this.body[0].type === 'Expression' && !this.expands) {
        code += ' ' + this.body[0].prepare(system).compile(system) + (this.braces ? ' }' : ' ');
      } else {
        system.indent.up();
        code += '\n';
        ref = this.body;
        for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
          instruction = ref[i];
          code += system.indent.get() + instruction.prepare(system).compile(system);
          code += '\n';
        }
        system.indent.down();
        if (this.braces) {
          code += system.indent.get() + '}';
        }
      }
      return code;
    };

    return Block;

  })(Base);

  Expression = exports.Expression = (function(superClass) {
    extend(Expression, superClass);

    function Expression(expression) {
      this.type = 'Expression';
      this.expression = expression;
    }

    Expression.prototype.compile = function(system) {
      return this.expression.prepare(system).compile(system) + ';';
    };

    return Expression;

  })(Base);

  Value = exports.Value = (function(superClass) {
    extend(Value, superClass);

    function Value(value, properties) {
      if (properties == null) {
        properties = [];
      }
      this.type = 'Value';
      this.value = value;
      this.properties = properties;
    }

    Value.prototype.add = function(prop) {
      this.properties.push(prop);
      return this;
    };

    Value.prototype.compile = function(system) {
      var code, existence, expression, j, len1, propertie, ref;
      if (this.value.type === 'Existence' && this.properties.length > 0) {
        existence = new Existence(this.value.value);
        this.value = this.value.value;
        expression = new If(existence, new Block([this]));
        if (this.isStatement) {
          expression.isStatement = true;
        }
        return expression.prepare(system).compile(system);
      }
      if (this.isStatement) {
        this.value.isStatement = true;
      }
      code = this.value.prepare(system).compile(system);
      ref = this.properties;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        propertie = ref[j];
        code += propertie.prepare(system).compile(system);
      }
      return code;
    };

    return Value;

  })(Base);

  Access = exports.Access = (function(superClass) {
    extend(Access, superClass);

    function Access(value, method) {
      if (method == null) {
        method = ".";
      }
      this.type = 'Access';
      this.value = value;
      this.method = method;
    }

    Access.prototype.compile = function(system) {
      var code;
      switch (this.method) {
        case '->':
        case '.':
          code = "->" + this.value.name;
          break;
        case '::':
        case '..':
          code = '::' + this.value.name;
          break;
        case '[]':
          code = '[' + this.value.prepare(system).compile(system) + ']';
      }
      return code;
    };

    return Access;

  })(Base);

  Identifier = exports.Identifier = (function(superClass) {
    extend(Identifier, superClass);

    function Identifier(name) {
      this.type = 'Identifier';
      this.name = name;
    }

    Identifier.prototype.compile = function(system) {
      if (!system.context.has(this.name)) {
        system.context.push(new Context.Name(this.name));
      }
      return system.context.Identify(this.name);
    };

    return Identifier;

  })(Base);

  HereDoc = exports.HereDoc = (function(superClass) {
    extend(HereDoc, superClass);

    function HereDoc(heredoc) {
      this.type = 'HereDoc';
      this.heredoc = heredoc;
    }

    HereDoc.prototype.compile = function(system) {
      return '<<<EOT\n' + this.heredoc + '\nEOT';
    };

    return HereDoc;

  })(Base);

  Literal = exports.Literal = (function(superClass) {
    extend(Literal, superClass);

    function Literal(raw) {
      this.type = 'Literal';
      this.value = eval(raw);
      this.raw = raw;
    }

    Literal.prototype.compile = function(system) {
      return this.raw;
    };

    return Literal;

  })(Base);

  Array = exports.Array = (function(superClass) {
    extend(Array, superClass);

    function Array(elements) {
      if (elements == null) {
        elements = [];
      }
      this.type = 'Array';
      this.elements = elements;
    }

    Array.prototype.compile = function(system) {
      var code, element, i, j, len1, ref;
      code = 'array(';
      ref = this.elements;
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        element = ref[i];
        code += element.prepare(system).compile(system);
        if (i !== this.elements.length - 1) {
          code += ', ';
        }
      }
      code += ')';
      return code;
    };

    return Array;

  })(Base);

  ArrayKey = exports.ArrayKey = (function(superClass) {
    extend(ArrayKey, superClass);

    function ArrayKey(key, value) {
      this.type = 'ArrayKey';
      this.key = key;
      this.value = value;
    }

    ArrayKey.prototype.compile = function(system) {
      return this.key.prepare(system).compile(system) + ' => ' + this.value.prepare(system).compile(system);
    };

    return ArrayKey;

  })(Base);

  Parens = exports.Parens = (function(superClass) {
    extend(Parens, superClass);

    function Parens(expression) {
      this.type = 'Parens';
      this.expression = expression;
    }

    Parens.prototype.compile = function(system) {
      return '(' + this.expression.prepare(system).compile(system) + ')';
    };

    return Parens;

  })(Base);

  typeCasting = exports.typeCasting = (function(superClass) {
    extend(typeCasting, superClass);

    function typeCasting(expression, ctype) {
      this.type = 'typeCasting';
      this.expression = expression;
      this.ctype = ctype;
    }

    typeCasting.prototype.compile = function(system) {
      return '(' + this.ctype + ') ' + this.expression.prepare(system).compile(system);
    };

    return typeCasting;

  })(Base);

  Clone = exports.Clone = (function(superClass) {
    extend(Clone, superClass);

    function Clone(expression) {
      this.type = 'Clone';
      this.expression = expression;
    }

    Clone.prototype.compile = function(system) {
      return 'clone ' + this.expression.prepare(system).compile(system);
    };

    return Clone;

  })(Base);

  Call = exports.Call = (function(superClass) {
    extend(Call, superClass);

    function Call(callee, args) {
      if (args == null) {
        args = [];
      }
      this.type = 'Call';
      this.callee = callee;
      this["arguments"] = args;
    }

    Call.prototype.prepare = function() {
      var arg, i, j, len1, ref;
      ref = this["arguments"];
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        arg = ref[i];
        if (arg.type === 'Value' && arg.value.type === 'Parens') {
          this["arguments"][i] = arg.value.expression;
        }
      }
      return this;
    };

    Call.prototype.compile = function(system) {
      var arg, callee, code, existence, expression, i, j, k, l, len1, len2, len3, prop, ref, ref1, ref2;
      if ((this.callee.value != null) && this.callee.value.type === 'Existence') {
        existence = new Existence(this.callee.value.value);
        callee = new Value(this.callee.value.value);
        ref = this.callee.value.value;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          prop = ref[j];
          callee.add(prop);
        }
        ref1 = this.callee.properties;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          prop = ref1[k];
          callee.add(prop);
        }
        expression = new If(existence, new Block([new Call(callee, this["arguments"])]));
        if (this.isStatement) {
          expression.isStatement = true;
        }
        return expression.prepare(system).compile(system);
      }
      code = this.callee.prepare(system).compile(system);
      code += '(';
      ref2 = this["arguments"];
      for (i = l = 0, len3 = ref2.length; l < len3; i = ++l) {
        arg = ref2[i];
        code += arg.prepare(system).compile(system);
        if (i !== this["arguments"].length - 1) {
          code += ', ';
        }
      }
      code += ')';
      return code;
    };

    return Call;

  })(Base);

  NewExpression = exports.NewExpression = (function(superClass) {
    extend(NewExpression, superClass);

    function NewExpression(callee, args) {
      if (args == null) {
        args = [];
      }
      this.type = 'NewExpression';
      this.callee = callee;
      this["arguments"] = args;
    }

    NewExpression.prototype.compile = function(system) {
      var arg, code, i, j, len1, ref;
      code = 'new ' + this.callee.prepare(system).compile(system);
      code += '(';
      ref = this["arguments"];
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        arg = ref[i];
        code += arg.prepare(system).compile(system);
        if (i !== this["arguments"].length - 1) {
          code += ', ';
        }
      }
      code += ')';
      return code;
    };

    return NewExpression;

  })(Base);

  Existence = exports.Existence = (function(superClass) {
    extend(Existence, superClass);

    function Existence(value) {
      this.type = 'Existence';
      this.value = value;
    }

    Existence.prototype.compile = function(system) {
      return 'isset(' + this.value.prepare(system).compile(system) + ')';
    };

    return Existence;

  })(Base);

  Range = exports.Range = (function(superClass) {
    extend(Range, superClass);

    function Range(from, to, tag) {
      this.type = 'Range';
      this.from = from;
      this.to = to;
      this.exclusive = tag === 'exclusive';
    }

    Range.prototype.prepare = function() {
      if (this.from instanceof Value && this.from.value instanceof Literal && typeof this.from.value.value === 'number') {
        this.fromCache = this.from.value.value;
      }
      if (this.to instanceof Value && this.to.value instanceof Literal && typeof this.to.value.value === 'number') {
        this.toCache = this.to.value.value;
      }
      if (typeof this.fromCache === 'number' && typeof this.toCache === 'number' && Math.abs(this.fromCache - this.toCache) <= 20) {
        this.compileResult = 'Array';
      } else {
        this.compileResult = 'function';
      }
      return this;
    };

    Range.prototype.compile = function(system) {
      var array, expression, i, index, j, k, ref, ref1, ref2, ref3, results, results1;
      if (this.compileResult === 'Array') {
        array = this.exclusive ? (function() {
          results = [];
          for (var j = ref = this.fromCache, ref1 = this.toCache; ref <= ref1 ? j < ref1 : j > ref1; ref <= ref1 ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this) : (function() {
          results1 = [];
          for (var k = ref2 = this.fromCache, ref3 = this.toCache; ref2 <= ref3 ? k <= ref3 : k >= ref3; ref2 <= ref3 ? k++ : k--){ results1.push(k); }
          return results1;
        }).apply(this);
        return (new Array((function() {
          var l, len1, results2;
          results2 = [];
          for (l = 0, len1 = array.length; l < len1; l++) {
            i = array[l];
            results2.push(new Literal(i.toString()));
          }
          return results2;
        })())).prepare(system).compile();
      } else {
        index = new Identifier(system.context.free('i'));
        expression = new Call(new Identifier('call_user_func'), [
          new Code([], new Block([
            new For({
              source: this,
              index: index,
              range: true
            }, new Block([new Value(index)]))
          ]))
        ]);
        return expression.prepare(system).compile(system);
      }
    };

    return Range;

  })(Base);

  Slice = exports.Slice = (function(superClass) {
    extend(Slice, superClass);

    function Slice(range) {
      this.type = 'Slice';
      this.range = range;
    }

    Slice.prototype.compile = function(system) {
      var expression, param;
      param = [];
      if (this.range.from != null) {
        param.push(this.range.from);
      } else {
        param.push(new Value(new Literal('0')));
      }
      if (this.range.to != null) {
        param.push(this.range.exclusive ? this.range.to : new Operation('+', this.range.to, new Literal('1')));
      }
      param = [new Literal('"slice"'), this.value].concat(param);
      system.config.addMammouth = true;
      expression = new Call(new Identifier('mammouth'), param);
      return expression.prepare(system).compile(system);
    };

    return Slice;

  })(Base);

  QualifiedName = exports.QualifiedName = (function(superClass) {
    extend(QualifiedName, superClass);

    function QualifiedName(path) {
      this.type = 'QualifiedName';
      this.path = path;
    }

    QualifiedName.prototype.compile = function(system) {
      return this.path;
    };

    return QualifiedName;

  })(Base);

  Assign = exports.Assign = (function(superClass) {
    extend(Assign, superClass);

    function Assign(operator, left, right) {
      this.type = 'Assign';
      this.operator = operator;
      this.left = left;
      this.right = right;
    }

    Assign.prototype.compile = function(system) {
      var code;
      code = this.left.prepare(system).compile(system);
      code += ' ' + this.operator + ' ';
      code += this.right.prepare(system).compile(system);
      return code;
    };

    return Assign;

  })(Base);

  GetKeyAssign = exports.GetKeyAssign = (function(superClass) {
    extend(GetKeyAssign, superClass);

    function GetKeyAssign(keys, source) {
      this.type = 'GetKeyAssign';
      this.keys = keys;
      this.source = source;
    }

    GetKeyAssign.prototype.compile = function(system) {
      var code, i, j, key, left, len1, ref;
      code = '';
      ref = this.keys;
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        key = ref[i];
        if (i !== 0) {
          code += system.indent.get();
        }
        left = new Value(key);
        this.source.properties = [];
        this.source.add(new Access(new Value(new Literal('"' + key.name + '"')), '[]'));
        code += (new Assign('=', left, this.source)).prepare(system).compile(system);
        if (i !== this.keys.length - 1) {
          code += ';\n';
        }
      }
      return code;
    };

    return GetKeyAssign;

  })(Base);

  Constant = exports.Constant = (function(superClass) {
    extend(Constant, superClass);

    function Constant(left, right) {
      this.type = 'Constant';
      this.left = left;
      this.right = right;
    }

    Constant.prototype.compile = function(system) {
      system.context.push(new Context.Name(this.left, 'const'));
      return 'const ' + this.left + ' = ' + this.right.prepare(system).compile(system);
    };

    return Constant;

  })(Base);

  Unary = exports.Unary = (function(superClass) {
    extend(Unary, superClass);

    function Unary(operator, expression) {
      this.type = 'Unary';
      this.operator = operator;
      this.expression = expression;
    }

    Unary.prototype.compile = function(system) {
      return this.operator + this.expression.prepare(system).compile(system);
    };

    return Unary;

  })(Base);

  Update = exports.Update = (function(superClass) {
    extend(Update, superClass);

    function Update(operator, expression, prefix) {
      if (prefix == null) {
        prefix = true;
      }
      this.type = 'Update';
      this.operator = operator;
      this.expression = expression;
      this.prefix = prefix;
    }

    Update.prototype.compile = function(system) {
      var code;
      code = this.expression.prepare(system).compile(system);
      if (this.prefix) {
        code = this.operator + code;
      } else {
        code += this.operator;
      }
      return code;
    };

    return Update;

  })(Base);

  Operation = exports.Operation = (function(superClass) {
    extend(Operation, superClass);

    function Operation(operator, left, right) {
      this.type = 'Operation';
      this.operator = operator;
      this.left = left;
      this.right = right;
    }

    Operation.prototype.compile = function(system) {
      var code, expression, space;
      if (this.operator === 'in') {
        return (new Value(new Call(new Value(new Identifier('in_array')), [this.left, this.right]))).prepare(system).compile(system);
      }
      code = this.left.prepare(system).compile(system);
      if (this.operator === '~') {
        this.operator = '.';
      }
      space = this.operator !== '.' ? ' ' : '';
      if (this.operator === '+' && system.config['+'] === true) {
        system.config.addMammouth = true;
        expression = new Value(new Call(new Value(new Identifier('mammouth')), [new Value(new Literal('"+"')), this.left, this.right]));
        return expression.prepare(system).compile(system);
      }
      code += space + this.operator + space;
      code += this.right.prepare(system).compile(system);
      return code;
    };

    return Operation;

  })(Base);

  Code = exports.Code = (function(superClass) {
    extend(Code, superClass);

    function Code(parameters, body, asStatement, name) {
      if (body == null) {
        body = false;
      }
      if (asStatement == null) {
        asStatement = false;
      }
      if (name == null) {
        name = null;
      }
      this.type = 'Code';
      this.parameters = parameters;
      this.body = body;
      this.asStatement = asStatement;
      this.name = name;
    }

    Code.prototype.prepare = function() {
      if (this.body !== false) {
        this.body.activateReturn(function(exp) {
          return new Return(exp);
        });
      }
      return this;
    };

    Code.prototype.compile = function(system) {
      var code, i, j, len1, parameter, ref;
      code = "function" + (this.asStatement ? ' ' + this.name : '') + '(';
      system.context.push(new Context.Name(this.name, 'function'));
      system.context.scopeStarts();
      ref = this.parameters;
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        parameter = ref[i];
        code += parameter.prepare(system).compile(system);
        if (i !== this.parameters.length - 1) {
          code += ', ';
        }
      }
      code += ')';
      if (this.body !== false) {
        code += ' ' + this.body.prepare(system).compile(system);
      }
      system.context.scopeEnds();
      return code;
    };

    return Code;

  })(Base);

  Param = exports.Param = (function(superClass) {
    extend(Param, superClass);

    function Param(name, passing, hasDefault, def) {
      if (passing == null) {
        passing = false;
      }
      if (hasDefault == null) {
        hasDefault = false;
      }
      if (def == null) {
        def = null;
      }
      this.type = 'Param';
      this.name = name;
      this.passing = passing;
      this.hasDefault = hasDefault;
      this["default"] = def;
    }

    Param.prototype.compile = function(system) {
      var code;
      system.context.push(new Context.Name(this.name));
      code = (this.passing ? '&' : '');
      code += '$' + this.name;
      code += (this.hasDefault ? ' = ' + this["default"].prepare(system).compile(system) : '');
      return code;
    };

    return Param;

  })(Base);

  If = exports.If = (function(superClass) {
    extend(If, superClass);

    function If(condition, body, invert) {
      if (invert == null) {
        invert = false;
      }
      this.type = 'If';
      this.condition = invert ? new Unary("!", new Parens(condition)) : condition;
      this.body = body;
      this.elses = [];
      this.closed = false;
    }

    If.prototype.addElse = function(element) {
      this.elses.push(element);
      return this;
    };

    If.prototype.activateReturn = function(returnGen) {
      var els, j, len1, ref, results;
      this.body.activateReturn(returnGen);
      ref = this.elses;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        els = ref[j];
        results.push(els.activateReturn(returnGen));
      }
      return results;
    };

    If.prototype.prepare = function() {
      var els, j, len1, ref;
      this.body.expands = true;
      ref = this.elses;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        els = ref[j];
        els.parentIf = this;
        if (this.isStatement) {
          els.isStatement = true;
        }
        els.body.expands = true;
      }
      if (!this.isStatement) {
        if (this.body.body.length === 1) {
          this.body = this.body.body[0];
        }
      }
      return this;
    };

    If.prototype.compile = function(system) {
      var code, els, j, k, len1, len2, ref, ref1;
      if (this.isStatement) {
        code = 'if(' + this.condition.prepare(system).compile(system) + ') ';
        code += this.body.prepare(system).compile(system);
        ref = this.elses;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          els = ref[j];
          code += els.prepare(system).compile(system);
        }
      } else {
        code = this.condition.prepare(system).compile(system) + ' ? ' + this.body.prepare(system).compile(system);
        ref1 = this.elses;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          els = ref1[k];
          code += ' : ' + els.prepare(system).compile(system);
        }
        if (!this.closed) {
          code += ' : NULL';
        }
      }
      return code;
    };

    return If;

  })(Base);

  ElseIf = exports.ElseIf = (function(superClass) {
    extend(ElseIf, superClass);

    function ElseIf(condition, body) {
      this.type = 'ElseIf';
      this.condition = condition;
      this.body = body;
    }

    ElseIf.prototype.activateReturn = function(returnGen) {
      return this.body.activateReturn(returnGen);
    };

    ElseIf.prototype.prepare = function() {
      if (!this.isStatement) {
        if (this.body.body.length === 1) {
          this.body = this.body.body[0];
        }
      }
      return this;
    };

    ElseIf.prototype.compile = function(system) {
      var code;
      if (this.isStatement) {
        code = ' elseif(' + this.condition.prepare(system).compile(system) + ') ';
        code += this.body.prepare(system).compile(system);
      } else {
        code = this.condition.prepare(system).compile(system) + ' ? ' + this.body.prepare(system).compile(system);
      }
      return code;
    };

    return ElseIf;

  })(Base);

  Else = exports.Else = (function(superClass) {
    extend(Else, superClass);

    function Else(body) {
      this.type = 'Else';
      this.body = body;
    }

    Else.prototype.activateReturn = function(returnGen) {
      return this.body.activateReturn(returnGen);
    };

    Else.prototype.prepare = function() {
      if (!this.isStatement) {
        if (this.body.body.length === 1) {
          this.body = this.body.body[0];
        }
      }
      return this;
    };

    Else.prototype.compile = function(system) {
      var code;
      if (this.isStatement) {
        code = ' else ';
        code += this.body.prepare(system).compile(system);
      } else {
        this.parentIf.closed = true;
        code = this.body.prepare(system).compile(system);
      }
      return code;
    };

    return Else;

  })(Base);

  While = exports.While = (function(superClass) {
    extend(While, superClass);

    function While(test, invert, guard, block) {
      if (invert == null) {
        invert = false;
      }
      if (guard == null) {
        guard = null;
      }
      if (block == null) {
        block = null;
      }
      this.type = 'While';
      this.test = invert ? new Unary("!", test) : test;
      this.guard = guard;
      this.body = block;
      this.returnactived = false;
      if (block !== null) {
        delete this.guard;
      }
    }

    While.prototype.addBody = function(block) {
      this.body = this.guard !== null ? new Block([new If(this.guard, block)]) : block;
      delete this.guard;
      return this;
    };

    While.prototype.activateReturn = function(returnGen) {
      return this.returnactived = true;
    };

    While.prototype.prepare = function(system) {
      var cacheRes, funcgen;
      this.body.expands = true;
      if (this.returnactived) {
        this.cacheRes = cacheRes = new Identifier(system.context.free('result'));
        funcgen = function(exp) {
          var m;
          m = new Expression(new Call(new Value(new Identifier('array_push')), [new Value(cacheRes), exp]));
          return m;
        };
        this.body.activateReturn(funcgen);
      }
      return this;
    };

    While.prototype.compile = function(system) {
      var code, init;
      code = '';
      if (this.isStatement) {
        if (this.returnactived) {
          init = new Expression(new Assign('=', new Value(this.cacheRes), new Value(new Array())));
          code += init.prepare(system).compile(system);
          code += '\n' + system.indent.get();
        }
        code += 'while(' + this.test.prepare(system).compile(system) + ') ';
        code += this.body.prepare(system).compile(system);
        if (this.returnactived) {
          code += '\n' + system.indent.get();
          code += (new Expression(new Return(new Value(this.cacheRes)))).prepare(system).compile(system);
        }
      } else {
        this.isStatement = true;
        code += (new Value(new Call(new Identifier('call_user_func'), [new Code([], new Block([this]))]))).prepare(system).compile(system);
      }
      return code;
    };

    return While;

  })(Base);

  Try = exports.Try = (function(superClass) {
    extend(Try, superClass);

    function Try(TryBody, CatchBody, CatchIdentifier, FinallyBody) {
      if (CatchBody == null) {
        CatchBody = new Block;
      }
      if (CatchIdentifier == null) {
        CatchIdentifier = false;
      }
      if (FinallyBody == null) {
        FinallyBody = false;
      }
      this.type = 'Try';
      this.TryBody = TryBody;
      this.CatchBody = CatchBody;
      this.CatchIdentifier = CatchIdentifier;
      this.FinallyBody = FinallyBody;
    }

    Try.prototype.activateReturn = function(returnGen) {
      this.TryBody.activateReturn(returnGen);
      this.CatchBody.activateReturn(returnGen);
      if (this.FinallyBody !== false) {
        return this.FinallyBody.activateReturn(returnGen);
      }
    };

    Try.prototype.prepare = function(system) {
      this.TryBody.expands = true;
      this.CatchBody.expands = true;
      if (this.FinallyBody !== false) {
        this.FinallyBody.expands = true;
      }
      return this;
    };

    Try.prototype.compile = function(system) {
      var code;
      code = '';
      if (this.isStatement) {
        code += 'try ';
        code += this.TryBody.prepare(system).compile(system);
        code += ' catch(Exception ';
        if (this.CatchIdentifier === false) {
          code += (new Identifier(system.context.free('error'))).prepare(system).compile(system);
        } else {
          code += this.CatchIdentifier.prepare(system).compile(system);
        }
        code += ') ' + this.CatchBody.prepare(system).compile(system);
      } else {
        this.isStatement = true;
        code += (new Value(new Call(new Identifier('call_user_func'), [new Code([], new Block([this]))]))).prepare(system).compile(system);
      }
      return code;
    };

    return Try;

  })(Base);

  For = exports.For = (function(superClass) {
    extend(For, superClass);

    function For(source, block) {
      this.type = 'For';
      this.source = source;
      this.body = block;
      this.returnactived = false;
      this.isPrepared = false;
    }

    For.prototype.activateReturn = function(returnGen) {
      return this.returnactived = true;
    };

    For.prototype.prepare = function(system) {
      var addTop, cacheRes, funcgen, valfromRef;
      this.body.expands = true;
      this.object = !!this.source.object;
      if (!((this.source.range != null) && this.source.range === true) && !this.isPrepared) {
        if (!this.object) {
          this.cacheIndex = new Identifier(system.context.free('i'));
          this.cacheLen = new Identifier(system.context.free('len'));
          if (this.source.source.type === 'Value' && this.source.source.value.type === 'Identifier') {
            this.initRef = false;
            this.cacheRef = this.source.source.value;
          } else {
            this.initRef = true;
            this.cacheRef = new Identifier(system.context.free('ref'));
          }
          valfromRef = new Value(this.cacheRef);
          valfromRef.add(new Access((this.source.index != null ? this.source.index : this.cacheIndex), '[]'));
          addTop = true;
        }
      }
      if ((this.source.guard != null) && !this.isPrepared) {
        this.body = new Block([new If(this.source.guard, this.body)]);
      }
      if (addTop === true && !this.isPrepared) {
        this.body.body.unshift(new Expression(new Assign('=', this.source.name, valfromRef)));
      }
      if (this.returnactived) {
        this.cacheRes = cacheRes = new Identifier(system.context.free('result'));
        funcgen = function(exp) {
          var m;
          m = new Expression(new Call(new Value(new Identifier('array_push')), [new Value(cacheRes), exp]));
          return m;
        };
        this.body.activateReturn(funcgen);
      }
      return this;
    };

    For.prototype.compile = function(system) {
      var code, index, init, len, update;
      code = '';
      if (this.isStatement) {
        if (this.returnactived) {
          init = new Expression(new Assign('=', new Value(this.cacheRes), new Value(new Array())));
          code += init.prepare(system).compile(system);
          code += '\n' + system.indent.get();
        }
        if ((this.source.range != null) && this.source.range === true) {
          index = this.source.index != null ? this.source.index : new Identifier(system.context.free('i'));
          code += 'for(';
          code += (new Assign('=', index, this.source.source.from)).prepare(system).compile(system);
          code += '; ';
          code += (new Operation(this.source.source.exclusive ? '<' : '<=', index, this.source.source.to)).prepare(system).compile(system);
          code += '; ';
          if (this.source.step != null) {
            update = new Assign('+=', index, this.source.step);
          } else {
            update = new Update('++', index, false);
          }
          code += update.prepare(system).compile(system);
          code += ') ';
          code += this.body.prepare(system).compile(system);
        } else {
          if (this.object) {
            code += 'foreach(' + this.source.source.prepare(system).compile(system) + ' as ';
            code += this.source.name.prepare(system).compile(system);
            code += ' => ';
            if (this.source.index != null) {
              code += this.source.index.prepare(system).compile(system);
            } else {
              code += (new Identifier(system.context.free('value'))).prepare(system).compile(system);
            }
            code += ') ';
            code += this.body.prepare(system).compile(system);
          } else {
            index = this.cacheIndex;
            len = this.cacheLen;
            if (this.initRef) {
              init = new Expression(new Assign('=', new Value(this.cacheRef), this.source.source));
              code += init.prepare(system).compile(system);
              code += '\n' + system.indent.get();
            }
            code += 'for(';
            if (this.source.index != null) {
              code += (new Assign('=', this.source.index, new Value(new Assign('=', index, new Value(new Literal('0')))))).prepare(system).compile(system);
            } else {
              code += (new Assign('=', index, new Value(new Literal('0')))).prepare(system).compile(system);
            }
            code += ', ';
            system.config.addMammouth = true;
            code += (new Assign('=', len, new Value(new Call(new Identifier('mammouth'), [new Value(new Literal("'length'")), this.cacheRef])))).prepare(system).compile(system);
            code += '; ';
            code += (new Operation('<', index, len)).prepare(system).compile(system);
            code += '; ';
            if (this.source.step != null) {
              update = new Assign('+=', index, this.source.step);
            } else {
              update = new Update('++', index, false);
            }
            if (this.source.index != null) {
              code += (new Assign('=', this.source.index, new Value(update))).prepare(system).compile(system);
            } else {
              code += update.prepare(system).compile(system);
            }
            code += ') ';
            code += this.body.prepare(system).compile(system);
          }
        }
        if (this.returnactived) {
          code += '\n' + system.indent.get();
          code += (new Expression(new Return(new Value(this.cacheRes)))).prepare(system).compile(system);
        }
      } else {
        this.isStatement = true;
        this.isPrepared = true;
        code += (new Value(new Call(new Identifier('call_user_func'), [new Code([], new Block([this]))]))).prepare(system).compile(system);
      }
      return code;
    };

    return For;

  })(Base);

  Switch = exports.Switch = (function(superClass) {
    extend(Switch, superClass);

    function Switch(subject, whens, otherwise) {
      var i, j, k, len1, len2, ref, ref1, val, whe;
      if (subject == null) {
        subject = null;
      }
      if (otherwise == null) {
        otherwise = false;
      }
      this.type = 'Switch';
      this.subject = subject === null ? new Value(new Literal('false')) : subject;
      this.whens = whens;
      if (subject === null) {
        ref = this.whens;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          whe = ref[j];
          ref1 = whe[0];
          for (i = k = 0, len2 = ref1.length; k < len2; i = ++k) {
            val = ref1[i];
            whe[0][i] = new Value(new Unary('!', new Parens(val)));
          }
        }
      }
      this.otherwise = otherwise;
      this.isPrepared = false;
      this.returnactived = false;
    }

    Switch.prototype.activateReturn = function(returnGen) {
      var j, len1, ref, whe;
      this.returnactived = true;
      ref = this.whens;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        whe = ref[j];
        whe[1].activateReturn(returnGen);
      }
      if (this.otherwise !== false) {
        return this.otherwise.activateReturn(returnGen);
      }
    };

    Switch.prototype.compile = function(system) {
      var code, i, j, k, l, lastndex, len1, len2, len3, ref, ref1, ref2, ref3, val, whe;
      code = '';
      if (this.isStatement) {
        ref = this.whens;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          whe = ref[j];
          whe[1].expands = true;
          whe[1].braces = false;
          lastndex = whe[1].body.length - 1;
          if (!((ref1 = whe[1].body[lastndex].type) === 'Return' || ref1 === 'Break') && !this.returnactived) {
            whe[1].body.push(new Break);
          }
        }
        if (this.otherwise !== false) {
          this.otherwise.expands = true;
          this.otherwise.braces = false;
        }
        code += 'switch(' + this.subject.prepare(system).compile(system) + ') {\n';
        system.indent.up();
        ref2 = this.whens;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          whe = ref2[k];
          ref3 = whe[0];
          for (i = l = 0, len3 = ref3.length; l < len3; i = ++l) {
            val = ref3[i];
            if (i !== 0) {
              code += '\n';
            }
            code += system.indent.get() + 'case ' + val.prepare(system).compile(system) + ':';
          }
          code += whe[1].prepare(system).compile(system);
        }
        if (this.otherwise !== false) {
          code += system.indent.get() + 'default:';
          code += this.otherwise.prepare(system).compile(system);
        }
        system.indent.down();
        code += system.indent.get() + '}';
      } else {
        this.isStatement = true;
        this.isPrepared = true;
        this.activateReturn(function(exp) {
          return new Return(exp);
        });
        code += (new Value(new Call(new Identifier('call_user_func'), [new Code([], new Block([this]))]))).prepare(system).compile(system);
      }
      return code;
    };

    return Switch;

  })(Base);

  Declare = exports.Declare = (function(superClass) {
    extend(Declare, superClass);

    function Declare(expression, script) {
      if (script == null) {
        script = false;
      }
      this.type = 'Declare';
      this.expression = expression;
      this.script = script;
    }

    Declare.prototype.prepare = function(system) {
      if (this.script !== false) {
        this.script.expands = true;
      }
      return this;
    };

    Declare.prototype.compile = function(system) {
      var code;
      if (this.expression.type === 'Assign' && this.expression.left.type === 'Value' && this.expression.left.value.type === 'Identifier') {
        system.context.push(new Context.Name(this.expression.left.value.name, 'const'));
      }
      code = 'declare(' + this.expression.prepare(system).compile(system) + ')';
      if (this.script !== false) {
        code += ' ' + this.script.prepare(system).compile(system);
      }
      return code;
    };

    return Declare;

  })(Base);

  Section = exports.Section = (function(superClass) {
    extend(Section, superClass);

    function Section(name) {
      this.type = 'Section';
      this.name = name;
    }

    Section.prototype.compile = function(system) {
      return this.name + ':';
    };

    return Section;

  })(Base);

  Goto = exports.Goto = (function(superClass) {
    extend(Goto, superClass);

    function Goto(section) {
      this.type = 'Goto';
      this.section = section;
    }

    Goto.prototype.compile = function(system) {
      return 'goto ' + this.section;
    };

    return Goto;

  })(Base);

  Break = exports.Break = (function(superClass) {
    extend(Break, superClass);

    function Break(arg) {
      if (arg == null) {
        arg = false;
      }
      this.type = 'Break';
      this.arg = arg;
    }

    Break.prototype.compile = function(system) {
      return 'break' + (this.arg === false ? '' : ' ' + this.arg.prepare(system).compile(system));
    };

    return Break;

  })(Base);

  Continue = exports.Continue = (function(superClass) {
    extend(Continue, superClass);

    function Continue(arg) {
      if (arg == null) {
        arg = false;
      }
      this.type = 'Continue';
      this.arg = arg;
    }

    Continue.prototype.compile = function(system) {
      return 'continue' + (this.arg === false ? '' : ' ' + this.arg.prepare(system).compile(system));
    };

    return Continue;

  })(Base);

  Return = exports.Return = (function(superClass) {
    extend(Return, superClass);

    function Return(value) {
      if (value == null) {
        value = false;
      }
      this.type = 'Return';
      this.value = value;
    }

    Return.prototype.compile = function(system) {
      return 'return' + (this.value === false ? '' : ' ' + this.value.prepare(system).compile(system));
    };

    return Return;

  })(Base);

  Throw = exports.Throw = (function(superClass) {
    extend(Throw, superClass);

    function Throw(expression) {
      this.type = 'Throw';
      this.expression = expression;
    }

    Throw.prototype.compile = function(system) {
      return 'throw ' + this.expression.prepare(system).compile(system);
    };

    return Throw;

  })(Base);

  Echo = exports.Echo = (function(superClass) {
    extend(Echo, superClass);

    function Echo(value) {
      this.type = 'Echo';
      this.value = value;
    }

    Echo.prototype.compile = function(system) {
      return 'echo ' + this.value.prepare(system).compile(system);
    };

    return Echo;

  })(Base);

  Delete = exports.Delete = (function(superClass) {
    extend(Delete, superClass);

    function Delete(value) {
      this.type = 'Delete';
      this.value = value;
    }

    Delete.prototype.compile = function(system) {
      return 'delete ' + this.value.prepare(system).compile(system);
    };

    return Delete;

  })(Base);

  Class = exports.Class = (function(superClass) {
    extend(Class, superClass);

    function Class(name, body, extendable, implement, modifier) {
      if (extendable == null) {
        extendable = false;
      }
      if (implement == null) {
        implement = false;
      }
      if (modifier == null) {
        modifier = false;
      }
      this.type = "Class";
      this.name = name;
      this.body = body;
      this.extendable = extendable;
      this.implement = implement;
      this.modifier = modifier;
    }

    Class.prototype.prepare = function(system) {
      var i, j, len1, line, ref;
      ref = this.body;
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        line = ref[i];
        if (line.element.type === 'Code' && line.element.body === false) {
          this.body[i].element = new Expression(line.element);
        }
      }
      return this;
    };

    Class.prototype.compile = function(system) {
      var code, i, impl, j, k, len1, len2, line, ref, ref1;
      system.context.push(new Context.Name(this.name, 'class'));
      code = (this.modifier !== false ? this.modifier + ' ' : '') + 'class ' + this.name;
      if (this.extendable !== false) {
        code += ' extends ' + this.extendable.prepare(system).compile(system);
      }
      if (this.implement !== false) {
        code += ' implements ';
        ref = this.implement;
        for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
          impl = ref[i];
          code += impl.prepare(system).compile(system);
          if (i !== this.implement.length - 1) {
            code += ', ';
          }
        }
      }
      code += '\n' + system.indent.get() + '{\n';
      system.indent.up();
      ref1 = this.body;
      for (i = k = 0, len2 = ref1.length; k < len2; i = ++k) {
        line = ref1[i];
        code += system.indent.get() + line.prepare(system).compile(system);
        code += '\n';
      }
      system.indent.down();
      code += system.indent.get() + '}';
      return code;
    };

    return Class;

  })(Base);

  ClassLine = exports.ClassLine = (function(superClass) {
    extend(ClassLine, superClass);

    function ClassLine(visibility, statically, element) {
      this.type = 'ClassLine';
      this.abstract = false;
      this.finaly = false;
      this.visibility = visibility;
      this.statically = statically;
      this.element = element;
    }

    ClassLine.prototype.compile = function(system) {
      var code;
      code = '';
      if (this.abstract === true) {
        code += 'abstract ';
      }
      if (this.finaly === true) {
        code += 'final ';
      }
      if (this.visibility !== false) {
        code += this.visibility + ' ';
      }
      if (this.statically !== false) {
        code += this.statically + ' ';
      }
      code += this.element.prepare(system).compile(system);
      return code;
    };

    return ClassLine;

  })(Base);

  Interface = exports.Interface = (function(superClass) {
    extend(Interface, superClass);

    function Interface(name, body, extendable) {
      if (extendable == null) {
        extendable = false;
      }
      this.type = "Interface";
      this.name = name;
      this.body = body;
      this.extendable = extendable;
    }

    Interface.prototype.prepare = function(system) {
      var i, j, len1, line, ref;
      ref = this.body;
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        line = ref[i];
        if (line.element.type === 'Code' && line.element.body === false) {
          this.body[i].element = new Expression(line.element);
        }
      }
      return this;
    };

    Interface.prototype.compile = function(system) {
      var code, i, j, len1, line, ref;
      system.context.push(new Context.Name(this.name, 'interface'));
      code = 'interface ' + this.name;
      if (this.extendable !== false) {
        code += ' extends ' + this.extendable.prepare(system).compile(system);
      }
      code += '\n' + system.indent.get() + '{\n';
      system.indent.up();
      ref = this.body;
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        line = ref[i];
        code += system.indent.get() + line.prepare(system).compile(system);
        code += '\n';
      }
      system.indent.down();
      code += system.indent.get() + '}';
      return code;
    };

    return Interface;

  })(Base);

  Namespace = exports.Namespace = (function(superClass) {
    extend(Namespace, superClass);

    function Namespace(name, body) {
      if (body == null) {
        body = false;
      }
      this.type = 'Namespace';
      this.name = name;
      this.body = body;
    }

    Namespace.prototype.prepare = function(system) {
      if (this.body !== false) {
        this.body.expands = true;
      }
      return this;
    };

    Namespace.prototype.compile = function(system) {
      var code;
      code = 'namespace ' + this.name.prepare(system).compile(system);
      if (this.body !== false) {
        system.context.scopeStarts();
        code += ' ' + this.body.prepare(system).compile(system);
        system.context.scopeEnds();
      }
      return code;
    };

    return Namespace;

  })(Base);

  Include = exports.Include = (function(superClass) {
    extend(Include, superClass);

    function Include(path, once) {
      if (once == null) {
        once = false;
      }
      this.type = 'Include';
      this.path = path;
      this.once = once;
    }

    Include.prototype.compile = function(system) {
      var code;
      code = '';
      if (this.once) {
        code += 'include_once ';
      } else {
        code += 'include ';
      }
      code += this.path.prepare(system).compile(system);
      return code;
    };

    return Include;

  })(Base);

  Require = exports.Require = (function(superClass) {
    extend(Require, superClass);

    function Require(path, once) {
      if (once == null) {
        once = false;
      }
      this.type = 'Require';
      this.path = path;
      this.once = once;
    }

    Require.prototype.compile = function(system) {
      var code, literal, path;
      code = '';
      if (this.once) {
        code += 'require_once ';
      } else {
        code += 'require ';
      }
      if (this.path.type === 'Value' && this.path.value.type === 'Literal') {
        literal = this.path.value.value;
        if (typeof literal === 'string' && system.config['import']) {
          path = literal;
          system.Mammouth.contextify(path);
          if (literal.slice(-9) === '.mammouth') {
            this.path.value.raw = this.path.value.raw.slice(0, -10) + '.php' + this.path.value.raw.slice(-1);
          }
        }
      }
      code += this.path.prepare(system).compile(system);
      return code;
    };

    return Require;

  })(Base);

  mammouthFunction = "<?php function mammouth() { $arguments = func_get_args(); switch($arguments[0]) { case '+': if((is_string($arguments[1]) && is_numeric($arguments[2])) || (is_string($arguments[1]) && is_numeric($arguments[1]))) { return $arguments[1].$arguments[2]; } else { return mammouth('+', $arguments[1], $arguments[2]); } break; case 'length': if(is_array($arguments[1])) { return count($arguments[1]); } elseif(is_string($arguments[1])) { return strlen($arguments[1]); } elseif(is_numeric($arguments[1])) { return strlen((string) $arguments[1]); } break; case 'slice': if(is_array($arguments[1])) { if(count($arguments) === 3) { return array_slice($arguments[1], $arguments[2]); } else { return array_slice($arguments[1], $arguments[2], $arguments[3] - $arguments[2]); } } elseif(is_string($arguments[1])) { if(count($arguments) === 3) { return substr($arguments[1], $arguments[2]); } else { return substr($arguments[1], $arguments[2], $arguments[3] - $arguments[2]); } } elseif(is_numeric($arguments[1])) { if(count($arguments) === 3) { return mammouth('slice', (string) $arguments[1], $arguments[2]); } else { return mammouth('slice', (string) $arguments[1], $arguments[2], $arguments[3] - $arguments[2]); } } break; } } ?>\n";

}).call(this);
return exports;})();
require["./phplexer"] = (function() {var exports = {}, module = {exports: exports};// Generated by CoffeeScript 1.9.3
(function() {
  var KEYWORDS, Lexer, Position, REGEX, Token, errorAt,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  errorAt = require('./utils').errorAt;

  Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.setInput = function(input) {
      this.yytext = '';
      this.track = {
        position: new Position,
        into: {
          php: false
        },
        opened: []
      };
      this.tokens = [];
      this.pos = 0;
      return this.input = input.replace(/\r\n/g, '\n');
    };

    Lexer.prototype.addToken = function(tokens) {
      var j, len, ref, token;
      if (tokens instanceof Array) {
        for (j = 0, len = tokens.length; j < len; j++) {
          token = tokens[j];
          if ((ref = token.type) === 'INDENT' || ref === 'MINDENT' || ref === 'LINETERMINATOR') {
            this.track.into["for"] = false;
          }
          this.tokens.push(token);
        }
      } else {
        this.tokens.push(tokens);
      }
      return tokens;
    };

    Lexer.prototype.getPos = function() {
      return this.track.position.clone();
    };

    Lexer.prototype.posAdvance = function(string, incPos) {
      var i, j, len, line, lines, results;
      if (incPos == null) {
        incPos = true;
      }
      if (incPos) {
        this.pos += string.length;
      }
      lines = string.split(REGEX.LINETERMINATOR);
      results = [];
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        if (i === 0) {
          results.push(this.track.position.col += string.length);
        } else {
          this.track.position.row++;
          results.push(this.track.position.col = line.length);
        }
      }
      return results;
    };

    Lexer.prototype.colAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      return this.track.position.col += num;
    };

    Lexer.prototype.rowAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      this.track.position.row += num;
      return this.track.position.col = 0;
    };

    Lexer.prototype.last = function(num) {
      if (num == null) {
        num = 1;
      }
      if (this.tokens[this.tokens.length - num]) {
        return this.tokens[this.tokens.length - num];
      }
      return void 0;
    };

    Lexer.prototype.next = function(num) {
      var lexer;
      if (num == null) {
        num = 1;
      }
      lexer = new Lexer;
      lexer.track = JSON.parse(JSON.stringify(this.track));
      lexer.track.position = this.track.position.clone();
      lexer.tokens = JSON.parse(JSON.stringify(this.tokens));
      lexer.pos = this.pos;
      lexer.input = this.input;
      while (num > 0) {
        lexer.nextToken();
        num--;
      }
      return lexer.tokens[lexer.tokens.length - 1];
    };

    Lexer.prototype.charCode = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.charCodeAt(pos);
    };

    Lexer.prototype.lex = function() {
      var token;
      if (!this.lexed) {
        this.tokenize();
      }
      token = this.tokens.shift();
      if (token) {
        this.yytext = token.value ? token.value : '';
        this.yylloc = {
          first_column: token.location.start.col,
          first_line: token.location.start.row,
          last_line: token.location.end.row,
          last_column: token.location.end.col
        };
        return token.type;
      }
    };

    Lexer.prototype.tokenize = function() {
      var m;
      m = 0;
      while (m !== void 0) {
        m = this.nextToken();
      }
      this.lexed = true;
      return this.tokens;
    };

    Lexer.prototype.nextToken = function() {
      if (this.pos === this.input.length) {
        return void 0;
      }
      if (!this.track.into.php) {
        return this.readTokenRAW();
      }
      if (this.isStartTag()) {
        return this.readTokenStartTag();
      }
      if (this.isEndTag()) {
        return this.readTokenEndTag();
      }
      if (this.isComment()) {
        return this.skipComment();
      }
      if (this.isVariable()) {
        return this.readTokenVariable();
      }
      if (this.isName()) {
        return this.readTokenName();
      }
      if (this.isNumber()) {
        return this.readTokenNumber();
      }
      if (this.isString()) {
        return this.readTokenString();
      }
      return this.getTokenFromCode(this.charCode());
    };

    Lexer.prototype.readTokenRAW = function() {
      var startPos, token, value;
      token = (new Token('RAW')).setStart(this.getPos());
      startPos = this.pos;
      while (this.pos < this.input.length && !this.isStartTag()) {
        this.pos++;
      }
      if (this.isStartTag()) {
        this.track.into.php = true;
      }
      value = this.input.slice(startPos, this.pos);
      this.posAdvance(value, false);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenStartTag = function() {
      var token, value;
      token = (new Token('STARTTAG')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.STARTTAG)[0];
      this.colAdvance(value.length);
      this.track.opened.unshift({
        type: 'STARTTAG',
        closableBy: 'ENDTAG'
      });
      return this.addToken(token.setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenEndTag = function() {
      var token, tokens;
      token = (new Token('ENDTAG')).setStart(this.getPos());
      this.colAdvance(2);
      token.setEnd(this.getPos());
      this.track.into.php = false;
      tokens = [token];
      if (this.track.opened[0].type === 'STARTTAG') {
        this.track.opened.shift();
      }
      return this.addToken(tokens);
    };

    Lexer.prototype.readTokenVariable = function() {
      var token, value;
      token = (new Token('VARIABLENAME')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.VARIABLE)[0];
      this.posAdvance(value);
      return this.addToken(token.set('value', value.slice(1)).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenName = function() {
      var ref, ref1, token, value;
      token = (new Token).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.NAME)[0];
      this.posAdvance(value);
      if ((ref = value.toUpperCase()) === 'TRUE' || ref === 'FALSE') {
        return this.addToken(token.set('type', 'BOOL').set('value', value).setEnd(this.getPos()));
      }
      if (ref1 = value.toLowerCase(), indexOf.call(KEYWORDS.PHPRESERVED, ref1) >= 0) {
        return this.addToken(token.set('type', value.toUpperCase()).setEnd(this.getPos()));
      }
      return this.addToken(token.set('type', 'NAME').set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenNumber = function() {
      var token, value;
      token = (new Token('NUMBER')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.NUMBER)[0];
      this.colAdvance(value.length);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenString = function() {
      var token, value;
      token = (new Token('STRING')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.STRING)[0];
      this.posAdvance(value);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.getTokenFromCode = function(code) {
      var startPos, token;
      startPos = this.getPos();
      token = (new Token).setStart(startPos);
      this.colAdvance();
      switch (code) {
        case 10:
        case 13:
        case 8232:
          this.colAdvance(-1);
          this.rowAdvance();
          return this.nextToken();
        case 32:
        case 160:
        case 5760:
        case 6158:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
          return this.nextToken();
        case 33:
          if (this.charCode() === 61) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'COMPARE').set('value', '!==').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'COMPARE').set('value', '!=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '!').setEnd(this.getPos()));
        case 36:
          return this.addToken(token.set('type', '$').setEnd(this.getPos()));
        case 37:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '%=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '%').setEnd(this.getPos()));
        case 38:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '&=').setEnd(this.getPos()));
          }
          if (this.charCode() === 38) {
            this.colAdvance();
            return this.addToken(token.set('type', 'LOGIC').set('value', '&&').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '&').setEnd(this.getPos()));
        case 40:
          return this.addToken(token.set('type', '(').setEnd(this.getPos()));
        case 41:
          return this.addToken(token.set('type', ')').setEnd(this.getPos()));
        case 42:
          if (this.charCode() === 42) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '**=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', '**').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '*=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '*').setEnd(this.getPos()));
        case 43:
          if (this.charCode() === 43) {
            this.colAdvance();
            return this.addToken(token.set('type', '++').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '+=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '+').setEnd(this.getPos()));
        case 44:
          return this.addToken(token.set('type', ',').setEnd(this.getPos()));
        case 45:
          if (this.charCode() === 62) {
            this.colAdvance();
            return this.addToken(token.set('type', '->').setEnd(this.getPos()));
          }
          if (this.charCode() === 45) {
            this.colAdvance();
            return this.addToken(token.set('type', '--').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '-=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '-').setEnd(this.getPos()));
        case 46:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '.=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '.').setEnd(this.getPos()));
        case 47:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '/=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '/').setEnd(this.getPos()));
        case 58:
          if (this.charCode() === 58) {
            this.colAdvance();
            return this.addToken(token.set('type', '::').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', ':').setEnd(this.getPos()));
        case 59:
          return this.addToken(token.set('type', ';').setEnd(this.getPos()));
        case 60:
          if (this.charCode() === 60) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '<<=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'BITWISE').set('value', '<<').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'COMPARE').set('value', '<=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'COMPARE').set('value', '<').setEnd(this.getPos()));
        case 61:
          if (this.charCode() === 61) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'COMPARE').set('value', '===').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'COMPARE').set('value', '==').setEnd(this.getPos()));
          }
          if (this.charCode() === 38) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '=&').setEnd(this.getPos()));
          }
          if (this.charCode() === 62) {
            this.colAdvance();
            return this.addToken(token.set('type', '=>').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '=').setEnd(this.getPos()));
        case 62:
          if (this.charCode() === 62) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '>>=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'BITWISE').set('value', '>>').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'COMPARE').set('value', '>=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'COMPARE').set('value', '>').setEnd(this.getPos()));
        case 63:
          return this.addToken(token.set('type', '?').setEnd(this.getPos()));
        case 91:
          return this.addToken(token.set('type', '[').setEnd(this.getPos()));
        case 92:
          return this.addToken(token.set('type', 'BS').setEnd(this.getPos()));
        case 93:
          return this.addToken(token.set('type', ']').setEnd(this.getPos()));
        case 94:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '^=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'BITWISE').set('value', '^').setEnd(this.getPos()));
        case 123:
          return this.addToken(token.set('type', '{').setEnd(this.getPos()));
        case 124:
          if (this.charCode() === 124) {
            this.colAdvance();
            return this.addToken(token.set('type', 'BITWISE').set('value', '||').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '|=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'BITWISE').set('value', '|').setEnd(this.getPos()));
        case 125:
          return this.addToken(token.set('type', '}').setEnd(this.getPos()));
        case 126:
          return this.addToken(token.set('type', '~').setEnd(this.getPos()));
      }
    };

    Lexer.prototype.skipComment = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.COMMENT)[0];
      this.posAdvance(value);
      return this.nextToken();
    };

    Lexer.prototype.isStartTag = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.STARTTAG) !== null;
    };

    Lexer.prototype.isEndTag = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.ENDTAG) !== null;
    };

    Lexer.prototype.isComment = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.COMMENT) !== null;
    };

    Lexer.prototype.isVariable = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.VARIABLE) !== null;
    };

    Lexer.prototype.isName = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.NAME) !== null;
    };

    Lexer.prototype.isNumber = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.NUMBER) !== null;
    };

    Lexer.prototype.isString = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.STRING) !== null;
    };

    return Lexer;

  })();

  Token = (function() {
    function Token(type, location, obj) {
      var key, value;
      this.type = type != null ? type : null;
      this.location = location != null ? location : {};
      if (obj == null) {
        obj = {};
      }
      for (key in obj) {
        value = obj[key];
        this[key] = value;
      }
      if (this.location === null) {
        delete this.location;
      }
    }

    Token.prototype.set = function(key, value) {
      this[key] = value;
      return this;
    };

    Token.prototype.get = function(key) {
      return this[key];
    };

    Token.prototype.setStart = function(value) {
      this.location.start = value;
      return this;
    };

    Token.prototype.setEnd = function(value) {
      this.location.end = value;
      return this;
    };

    Token.prototype.clone = function() {
      var k, token, v;
      token = new Token;
      for (k in this) {
        v = this[k];
        token.set(k, v);
      }
      return token;
    };

    return Token;

  })();

  Position = (function() {
    function Position(row, col) {
      this.row = row != null ? row : 1;
      this.col = col != null ? col : 0;
    }

    Position.prototype.clone = function() {
      return new Position(this.row, this.col);
    };

    Position.from = function(pos) {
      return new Position(pos.row || 1, pos.col || 0);
    };

    return Position;

  })();

  REGEX = {
    COMMENT: /^\/\*([\s\S]*?)(?:\*\/[^\n\S]*|\*\/$)|^(?:\s*\/\/(.*)+)|^(?:\s*\#(.*)+)/,
    LINETERMINATOR: /[\n\r\u2028]/,
    STARTTAG: /^<\?php|^<\?=/,
    ENDTAG: /^\?>/,
    NAME: /((^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    NUMBER: /^(0b[01]+|0o[0-7]+|0(x|X)[\da-fA-F]+|\d*\.?\d+(?:(e|E)[+-]?\d+)?)/,
    STRING: /^('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/,
    VARIABLE: /((^\$[A-Za-z_\x7f-\uffff][\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/
  };

  KEYWORDS = {
    PHPRESERVED: ['abstract', 'and', 'array', 'as', 'break', 'callable', 'case', 'catch', 'class', 'clone', 'const', 'continue', 'declare', 'default', 'do', 'echo', 'else', 'elseif', 'empty', 'enddeclare', 'endfor', 'endforeach', 'endif', 'endswitch', 'endwhile', 'extends', 'final', 'finally', 'for', 'foreach', 'function', 'global', 'goto', 'if', 'implements', 'include', 'include_once', 'instanceof', 'insteadof', 'interface', 'namespace', 'new', 'null', 'or', 'print', 'private', 'protected', 'public', 'require', 'require_once', 'return', 'static', 'switch', 'throw', 'trait', 'try', 'unset', 'use', 'var', 'while']
  };

  module.exports = new Lexer;

}).call(this);
return module.exports;})();
require["./php"] = (function() {var exports = {}, module = {exports: exports};// Generated by CoffeeScript 1.9.3
(function() {
  var Context, lexer;

  lexer = require('./phplexer');

  Context = require('./context');

  module.exports = {
    compile: function(code, system) {
      var i, j, len, token, token2, token3, tokens;
      lexer.setInput(code);
      tokens = lexer.tokenize();
      for (i = j = 0, len = tokens.length; j < len; i = ++j) {
        token = tokens[i];
        if (token.type === 'VARIABLENAME') {
          system.context.push(new Context.Name(token.value));
        }
        if (token.type === 'NAME') {
          if (tokens[i - 1] != null) {
            token2 = tokens[i - 1];
            if (token2.type === 'FUNCTION') {
              system.context.push(new Context.Name(token.value, 'function'));
            }
            if (token2.type === 'CLASS') {
              system.context.push(new Context.Name(token.value, 'class'));
            }
            if (token2.type === 'INTERFACE') {
              system.context.push(new Context.Name(token.value, 'interface'));
            }
            if (token2.type === 'CONST') {
              system.context.push(new Context.Name(token.value, 'const'));
            }
          }
        }
        if (token.type === 'STRING') {
          if ((tokens[i - 1] != null) && (tokens[i - 2] != null) && tokens[i - 1].type === '(') {
            token3 = tokens[i - 2];
            if (token3.type === 'NAME' && token3.value === 'define') {
              system.context.push(new Context.Name(token.value.slice(1, -1), 'const'));
            }
          }
        }
      }
    }
  };

}).call(this);
return module.exports;})();
require["./mammouth"] = (function() {var exports = {}, module = {exports: exports};// Generated by CoffeeScript 1.9.3
(function() {
  var Context, IndentGenerator, Mammouth, PHP, Predefined, System, lexer, parser, yy;

  yy = require('./nodes');

  parser = require('./parser').parser;

  lexer = require('./lexer');

  Context = require('./context');

  Predefined = require('./predefined');

  IndentGenerator = require('./utils').IndentGenerator;

  PHP = require('./php');

  parser.lexer = lexer;

  parser.yy = yy;

  System = (function() {
    function System() {
      this.indent = new IndentGenerator;
      this.context = new Context.Context(new Context.Scope);
      Predefined.Initialize(this.context);
      this.config = {};
      this.setDefaultConfig();
    }

    System.prototype.setDefaultConfig = function() {
      this.config['+'] = true;
      this.config['import'] = false;
      return this.config['addMammouth'] = false;
    };

    System.prototype.setStrictMode = function() {
      this.config['+'] = false;
      return this.config['import'] = false;
    };

    return System;

  })();

  Mammouth = (function() {
    Mammouth.VERSION = '3.0.0';

    function Mammouth() {
      this._fs = require('fs');
      this._path = require('path');
    }

    Mammouth.prototype.compile = function(file) {
      var code, result;
      code = this._fs.readFileSync(file, 'utf8');
      this.path = this._path.dirname(file);
      this.system = new System;
      this.system.config['import'] = true;
      this.system.Mammouth = this;
      result = Mammouth.compile(code, this.system);
      return result;
    };

    Mammouth.prototype.contextify = function(file) {
      var code, path, path2, type;
      path = this._path.join(this.path, file);
      type = 'php';
      switch (this._path.extname(path)) {
        case '.php':
          type = 'php';
          break;
        case '.mammouth':
          type = 'mammouth';
          break;
        default:
          return;
      }
      if (this._fs.existsSync(path)) {
        code = this._fs.readFileSync(path, 'utf8');
        if (type === 'mammouth') {
          Mammouth.compile(code, this.system);
        } else if (type === 'php') {
          PHP.compile(code, this.system);
        }
        return;
      }
      if (type === 'php') {
        path2 = this._path.join(this._path.dirname(path), path.basename(path, '.php'), '.mammouth');
        if (this._fs.existsSync(path2)) {
          code = this._fs.readFileSync(path2, 'utf8');
          Mammouth.compile(path2, this.system);
        }
      }
    };

    Mammouth.parser = parser;

    Mammouth.parse = function(code) {
      return Mammouth.parser.parse(code);
    };

    Mammouth.compile = function(code, sys) {
      var result, system, tree;
      if (sys == null) {
        sys = false;
      }
      if (sys === false) {
        system = new System;
      } else {
        system = sys;
      }
      tree = Mammouth.parse(code);
      return result = tree.prepare().compile(system);
    };

    Mammouth.contextify = function(code, sys) {
      var result, system;
      if (sys == null) {
        sys = false;
      }
      if (sys === false) {
        system = new System;
      } else {
        system = sys;
      }
      result = Mammouth.compile(system, system);
      return system.context;
    };

    return Mammouth;

  })();

  module.exports = Mammouth;

}).call(this);
return module.exports;})();

mammouth = require["./mammouth"];
return require["./mammouth"];
}(this));