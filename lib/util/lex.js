// Generated by CoffeeScript 1.9.3

/*
    This is just aaditmshah/lexer (https://github.com/aaditmshah/lexer) lexer rewrited
    in coffeescript with some addtion:
        * the `look` function that allow to detect next token into addRule
 */

(function() {
  var Lexer;

  Lexer = function(defunct) {
    var remove, scan, tokens;
    if (typeof defunct !== 'function') {
      defunct = function(char) {
        throw new Error('Unexpected character at index ' + (this.index - 1) + ': ' + char);
      };
    }
    tokens = [];
    this.rules = [];
    remove = 0;
    this.state = 0;
    this.index = 0;
    this.input = '';
    this.addRule = function(pattern, action, start) {
      var flags, global;
      global = pattern.global;
      if (!global) {
        flags = "g";
        if (pattern.multiline) {
          flags += "m";
        }
        if (pattern.ignoreCase) {
          flags += "i";
        }
        pattern = new RegExp(pattern.source, flags);
      }
      if (Object.prototype.toString.call(start) !== "[object Array]") {
        start = [0];
      }
      this.rules.push({
        pattern: pattern,
        global: global,
        action: action,
        start: start
      });
      return this;
    };
    this.setInput = function(input) {
      remove = 0;
      this.state = 0;
      this.index = 0;
      this.input = input;
      return this;
    };
    this.lex = function() {
      var index, input, length, match, matches, result, token;
      if (tokens.length) {
        return tokens.shift();
      }
      this.reject = true;
      while (this.index <= this.input.length) {
        matches = scan.call(this).splice(remove);
        index = this.index;
        while (matches.length) {
          if (this.reject) {
            match = matches.shift();
            result = match.result;
            length = match.length;
            this.index += length;
            this.reject = false;
            remove++;
            token = match.action.apply(this, result);
            if (this.reject) {
              this.index = result.index;
            } else if (typeof token !== 'undefined') {
              switch (Object.prototype.toString.call(token)) {
                case '[object Array]':
                  tokens = token.slice(1);
                  token = token[0];
                  break;
                default:
                  if (length) {
                    remove = 0;
                  }
                  return token;
              }
            }
          } else {
            break;
          }
        }
        input = this.input;
        if (index < input.length) {
          if (this.reject) {
            remove = 0;
            token = defunct.call(this, input.charAt(this.index++));
            if (typeof token !== 'undefined') {
              if (Object.prototype.toString.call(token) === '[object Array]') {
                tokens = token.slice(1);
                return token[0];
              } else {
                return token;
              }
            }
          } else {
            if (this.index !== index) {
              remove = 0;
            }
            this.reject = true;
          }
        } else if (matches.length) {
          this.reject = true;
        } else {
          break;
        }
      }
    };
    scan = function() {
      var index, input, j, k, l, lastIndex, len, matches, pattern, ref, result, rule, start, state, states, temple;
      matches = [];
      index = 0;
      state = this.state;
      lastIndex = this.index;
      input = this.input;
      ref = this.rules;
      for (l = 0, len = ref.length; l < len; l++) {
        rule = ref[l];
        start = rule.start;
        states = start.length;
        if ((!states || start.indexOf(state) >= 0) || (state % 2 && states === 1 && !start[0])) {
          pattern = rule.pattern;
          pattern.lastIndex = lastIndex;
          result = pattern.exec(input);
          if (result && result.index === lastIndex) {
            j = matches.push({
              result: result,
              action: rule.action,
              length: result[0].length
            });
            if (rule.global) {
              index = j;
            }
            while (--j > index) {
              k = j - 1;
              if (matches[j].length > matches[k].length) {
                temple = matches[j];
                matches[j] = matches[k];
                matches[k] = temple;
              }
            }
          }
        }
      }
      return matches;
    };
    this.look = function(num) {
      var i, lexer, res;
      if (num == null) {
        num = 1;
      }
      lexer = new Lexer;
      lexer.state = this.state;
      lexer.index = this.index;
      lexer.input = this.input;
      lexer.rules = this.rules;
      res = null;
      i = 0;
      while (i < num) {
        res = lexer.lex();
        i++;
      }
      return res;
    };
    return this;
  };

  module.exports = Lexer;

}).call(this);
