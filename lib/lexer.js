// Generated by CoffeeScript 1.9.3
(function() {
  var Lexer, REGEX, Track, addToken, initializeTrack, lexer, posAdvance;

  Lexer = require('./util/lex');

  REGEX = require('./constants').REGEX;

  Track = {};

  initializeTrack = function() {
    return {
      row: 1,
      col: 1,
      into: {
        mammouth: false
      },
      tokens: [],
      indent: {
        currentIndent: -1,
        openedIndent: 0,
        indentStack: []
      }
    };
  };

  addToken = function(tok, value, prop) {
    var el, i, j, key, len, ref, token, val;
    if (value == null) {
      value = void 0;
    }
    if (prop == null) {
      prop = {};
    }
    if (tok instanceof Array) {
      for (i = j = 0, len = tok.length; j < len; i = ++j) {
        el = tok[i];
        token = {
          type: el
        };
        if (value && value[i]) {
          token['value'] = value[i];
        }
        if (prop && prop[i]) {
          ref = prop[i];
          for (key in ref) {
            val = ref[key];
            token[key] = val;
          }
        }
        Track.tokens.push(token);
      }
      return tok;
    } else {
      token = {
        type: tok
      };
      if (value) {
        token['value'] = value;
      }
      for (key in prop) {
        val = prop[key];
        token[key] = val;
      }
      Track.tokens.push(token);
      return tok;
    }
  };

  posAdvance = function(string, yy) {
    var i, j, len, line, lines;
    yy.yylloc = {
      first_line: Track.row,
      first_column: Track.col
    };
    lines = string.split(REGEX.LINETERMINATOR);
    for (i = j = 0, len = lines.length; j < len; i = ++j) {
      line = lines[i];
      if (i === 0) {
        Track.col += string.length;
      } else {
        Track.row++;
        Track.col = string.length;
      }
    }
    yy.yylloc.last_line = Track.row;
    return yy.yylloc.last_column = Track.col;
  };

  Track = initializeTrack();

  lexer = module.exports = new Lexer(function(char) {
    throw new Error('Unexpected character at row ' + Track.row + ', col ' + Track.col + ': ' + char);
  });

  lexer.addRule(REGEX.RAWTEXT, function(lexeme) {
    if (!Track.into.mammouth) {
      posAdvance(lexeme, this);
      this.yytext = lexeme;
      return addToken('RAWTEXT', lexeme);
    } else {
      return this.reject = true;
    }
  });

  lexer.addRule(REGEX.startTag, function(lexeme) {
    posAdvance(lexeme, this);
    Track.into.mammouth = true;
    return addToken('{{');
  });

  lexer.addRule(REGEX.endTag, function(lexeme) {
    var tokens;
    posAdvance(lexeme, this);
    Track.into.mammouth = false;
    tokens = ['}}'];
    while (Track.indent.openedIndent > 0) {
      tokens.unshift('OUTDENT');
      Track.indent.openedIndent--;
    }
    console.log(tokens);
    return addToken(tokens);
  });

  lexer.addRule(REGEX.EMPTYLINE, function(lexeme) {
    return posAdvance(lexeme, this);
  });

  lexer.addRule(REGEX.INDENT, function(lexeme) {
    var i, indentLength, indentLevel, j, k, len, len1, multiIndent, prop, ref, reversedStack, tokens;
    posAdvance(lexeme, this);
    multiIndent = lexeme.split(REGEX.LINETERMINATOR);
    indentLength = multiIndent[multiIndent.length - 1].replace(/\t/g, '    ').length;
    if (indentLength > Track.indent.currentIndent) {
      Track.indent.currentIndent = indentLength;
      Track.indent.openedIndent++;
      Track.indent.indentStack.push(indentLength);
      return addToken('INDENT', void 0, {
        length: indentLength
      });
    } else if (indentLength === Track.indent.currentIndent) {
      return addToken('MINDENT');
    } else {
      tokens = [];
      prop = [];
      reversedStack = [];
      ref = Track.indent.indentStack;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        reversedStack.unshift(i);
      }
      for (k = 0, len1 = reversedStack.length; k < len1; k++) {
        indentLevel = reversedStack[k];
        if (indentLength === indentLevel) {
          Track.indent.currentIndent = indentLevel;
        } else if (indentLength < indentLevel) {
          Track.indent.currentIndent = Track.indent.indentStack.pop();
          tokens.push('OUTDENT');
          prop.push(void 0);
          Track.indent.openedIndent--;
        } else if (indentLength > indentLevel) {
          Track.indent.currentIndent = indentLength;
          Track.indent.openedIndent++;
          Track.indent.indentStack.push(indentLength);
          tokens.push('INDENT');
          prop.push({
            length: indentLength
          });
        }
      }
      return addToken(tokens, void 0, prop);
    }
  });

  lexer.addRule(REGEX.IDENTIFIER, function(lexeme) {
    posAdvance(lexeme, this);
    return addToken('IDENTIFIER', lexeme);
  });

  lexer.addRule(REGEX.LINETERMINATOR, function(lexeme) {
    var ref;
    posAdvance(lexeme, this);
    if ((ref = this.look()) === 'INDENT' || ref === 'MINDENT' || ref === 'OUTDENT') {
      return addToken('LINETERMINATOR');
    }
  });

  lexer.addRule(/$/, function(lexeme) {
    this.tokens = Track.tokens;
    return this.reject = true;
  });

}).call(this);
