// Generated by CoffeeScript 1.7.1
(function() {
  var CloseIndents, IntoArray, IntoMammouth, Levels, Lexer, RegularExpression, ShouldCloseCall, col, lastIsIdentifier, lexer, row, setToken;

  Lexer = require("lex");

  col = 1;

  row = 1;

  IntoArray = false;

  IntoMammouth = false;

  Levels = [
    {
      IndentStack: [],
      CurrentIndent: -1,
      OpenedIndent: 0
    }
  ];

  lastIsIdentifier = false;

  ShouldCloseCall = false;

  setToken = function(token) {
    if (token === 'IDENTIFIER') {
      return lastIsIdentifier = true;
    } else {
      return lastIsIdentifier = false;
    }
  };

  CloseIndents = function(tokens) {
    while (Levels[0].OpenedIndent > 0) {
      tokens.unshift('OUTDENT');
      Levels[0].OpenedIndent--;
    }
    return tokens;
  };

  lexer = module.exports = new Lexer(function(char) {
    throw new Error("Unexpected character at row " + row + ", col " + col + ": " + char);
  });

  RegularExpression = {
    PlainText: /(((?!({{|}})).)*)/,
    MammouthStart: /{{/,
    MammouthEnd: /}}/,
    Python_indent: /(^[ \t]*)/gm,
    EmptyLine: /(^[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]*[\n\r\u2028\u2029])/gmi,
    IDENTIFIER: /(([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    NUMBER: /(0b[01]+|0o[0-7]+|0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)/,
    STRING: /('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/,
    BOOL: /true|false/,
    LineTerminator: /[\n\r\u2028\u2029]/,
    Zs: /[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]/
  };

  lexer.addRule(RegularExpression.PlainText, function(lexeme) {
    if (!IntoMammouth) {
      col += lexeme.length;
      this.yytext = lexeme;
      setToken('PlainText');
      return 'PlainText';
    } else {
      return this.reject = true;
    }
  });

  lexer.addRule(RegularExpression.EmptyLine, function(lexeme) {});

  lexer.addRule(RegularExpression.Python_indent, function(lexeme) {
    var a, current_line_indent, i, tokens, _i, _j, _len, _len1, _ref;
    if (IntoMammouth) {
      col += lexeme.length;
      current_line_indent = lexeme.replace(/\t/g, '    ').length;
      if (current_line_indent > Levels[0].CurrentIndent) {
        Levels[0].CurrentIndent = current_line_indent;
        Levels[0].OpenedIndent++;
        Levels[0].IndentStack.push(Levels[0].CurrentIndent);
        setToken('INDENT');
        return 'INDENT';
      } else if (current_line_indent < Levels[0].CurrentIndent) {
        tokens = [];
        a = [];
        _ref = Levels[0].IndentStack;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          a.unshift(i);
        }
        for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
          i = a[_j];
          if (current_line_indent === i) {
            Levels[0].CurrentIndent = i;
          } else if (current_line_indent < i) {
            Levels[0].CurrentIndent = Levels[0].IndentStack.pop();
            setToken('OUTDENT');
            tokens.push('OUTDENT');
            Levels[0].OpenedIndent -= 1;
          }
        }
        return tokens;
      } else {

      }
    }
  });

  lexer.addRule(RegularExpression.Zs, function(lexeme) {});

  lexer.addRule(RegularExpression.MammouthStart, function() {
    col += 2;
    IntoMammouth = true;
    setToken('{{');
    return '{{';
  });

  lexer.addRule(RegularExpression.MammouthEnd, function() {
    var token, tokens, _i, _len;
    col += 2;
    IntoMammouth = false;
    tokens = CloseIndents(['}}']);
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
      token = tokens[_i];
      setToken(token);
    }
    return tokens;
  });

  lexer.addRule(/\(/, function(lexeme) {
    col += lexeme.length;
    if (lastIsIdentifier) {
      lastIsIdentifier = false;
      ShouldCloseCall = true;
      setToken('CALL_START');
      return 'CALL_START';
    } else {
      setToken('(');
      return '(';
    }
  });

  lexer.addRule(/\)/, function(lexeme) {
    col += lexeme.length;
    if (ShouldCloseCall) {
      ShouldCloseCall = false;
      setToken('CALL_END');
      return 'CALL_END';
    } else {
      setToken(')');
      return ')';
    }
  });

  lexer.addRule(/\[/, function(lexeme) {
    col += lexeme.length;
    setToken('[');
    return '[';
  });

  lexer.addRule(/\]/, function(lexeme) {
    col += lexeme.length;
    setToken(']');
    return ']';
  });

  lexer.addRule(/,/, function(lexeme) {
    col += lexeme.length;
    setToken(',');
    return ',';
  });

  lexer.addRule(/\./, function(lexeme) {
    col += lexeme.length;
    setToken('.');
    return '.';
  });

  lexer.addRule(/\.\./, function(lexeme) {
    col += lexeme.length;
    setToken('..');
    return '..';
  });

  lexer.addRule(/<->/, function(lexeme) {
    col += lexeme.length;
    setToken('<->');
    return '<->';
  });

  lexer.addRule(/->/, function(lexeme) {
    col += lexeme.length;
    setToken('->');
    return '->';
  });

  lexer.addRule(/:/, function(lexeme) {
    col += lexeme.length;
    setToken(':');
    return ':';
  });

  lexer.addRule(/::/, function(lexeme) {
    col += lexeme.length;
    setToken('::');
    return '::';
  });

  lexer.addRule(/\+/, function(lexeme) {
    col += lexeme.length;
    setToken('+');
    return '+';
  });

  lexer.addRule(/\+\+/, function(lexeme) {
    col += lexeme.length;
    setToken('++');
    return '++';
  });

  lexer.addRule(/-/, function(lexeme) {
    col += lexeme.length;
    setToken('-');
    return '-';
  });

  lexer.addRule(/--/, function(lexeme) {
    col += lexeme.length;
    setToken('--');
    return '--';
  });

  lexer.addRule(/\?/, function(lexeme) {
    col += lexeme.length;
    setToken('?');
    return '?';
  });

  lexer.addRule(/\*/, function(lexeme) {
    col += lexeme.length;
    setToken('*');
    return '*';
  });

  lexer.addRule(/\*\*/, function(lexeme) {
    col += lexeme.length;
    setToken('**');
    return '**';
  });

  lexer.addRule(/\//, function(lexeme) {
    col += lexeme.length;
    setToken('/');
    return '/';
  });

  lexer.addRule(/%/, function(lexeme) {
    col += lexeme.length;
    setToken('%');
    return '%';
  });

  lexer.addRule(/\+\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/-\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/\*\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/\/\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/\%\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/&/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('&');
    return "&";
  });

  lexer.addRule(/>>/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('>>');
    return "SHIFT";
  });

  lexer.addRule(/<</, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('<<');
    return 'SHIFT';
  });

  lexer.addRule(/\|\|/, function(lexeme) {
    col += lexeme.length;
    this.yytext = '||';
    setToken('LOGIC');
    return 'LOGIC';
  });

  lexer.addRule(/&&/, function(lexeme) {
    col += lexeme.length;
    this.yytext = 'and';
    setToken('LOGIC');
    return 'LOGIC';
  });

  lexer.addRule(/\|/, function(lexeme) {
    col += lexeme.length;
    this.yytext = 'or';
    setToken('LOGIC');
    return 'LOGIC';
  });

  lexer.addRule(/</, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/>/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/<=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/>=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/!\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/\=\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/\=\=\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/\=/, function(lexeme) {
    col += lexeme.length;
    setToken('=');
    return "=";
  });

  lexer.addRule(RegularExpression.IDENTIFIER, function(lexeme) {
    col += lexeme.length;
    if (lexeme === 'true' || lexeme === 'false') {
      this.yytext = eval(lexeme);
      setToken('BOOL');
      return 'BOOL';
    } else if (lexeme === 'and') {
      this.yytext = lexeme;
      setToken('LOGIC');
      return 'LOGIC';
    } else if (lexeme === 'catch') {
      this.yytext = lexeme;
      setToken('CATCH');
      return 'CATCH';
    } else if (lexeme === 'case') {
      setToken('CASE');
      return 'CASE';
    } else if (lexeme === 'cte') {
      this.yytext = lexeme;
      setToken('CTE');
      return 'CTE';
    } else if (lexeme === 'else') {
      this.yytext = lexeme;
      setToken('ELSE');
      return 'ELSE';
    } else if (lexeme === 'finally') {
      this.yytext = lexeme;
      setToken('FINALLY');
      return 'FINALLY';
    } else if (lexeme === 'func') {
      setToken('FUNC');
      return 'FUNC';
    } else if (lexeme === 'if') {
      this.yytext = lexeme;
      setToken('IF');
      return 'IF';
    } else if (lexeme === "is") {
      this.yytext = "===";
      setToken('COMPARE');
      return "COMPARE";
    } else if (lexeme === "isnt") {
      this.yytext = "!=";
      setToken('COMPARE');
      return "COMPARE";
    } else if (lexeme === "in") {
      setToken('IN');
      return "IN";
    } else if (lexeme === 'not') {
      setToken('NOT');
      return 'NOT';
    } else if (lexeme === 'or') {
      this.yytext = lexeme;
      setToken('LOGIC');
      return 'LOGIC';
    } else if (lexeme === 'switch') {
      setToken('SWITCH');
      return 'SWITCH';
    } else if (lexeme === 'try') {
      this.yytext = lexeme;
      setToken('TRY');
      return 'TRY';
    } else if (lexeme === 'use') {
      setToken('USE');
      return 'USE';
    } else if (lexeme === 'when') {
      setToken('WHEN');
      return 'WHEN';
    } else if (lexeme === 'while') {
      setToken('WHILE');
      return 'WHILE';
    } else {
      this.yytext = lexeme;
      setToken('IDENTIFIER');
      return "IDENTIFIER";
    }
  });

  lexer.addRule(RegularExpression.NUMBER, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('NUMBER');
    return "NUMBER";
  });

  lexer.addRule(RegularExpression.STRING, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('STRING');
    return "STRING";
  });

  lexer.addRule(RegularExpression.LineTerminator, function(lexeme) {
    col = 1;
    row++;
    setToken('LineTerminator');
    return "LineTerminator";
  });

}).call(this);
