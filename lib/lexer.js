// Generated by CoffeeScript 1.7.1
(function() {
  var KEYWORDS, Lexer, REGEX,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  REGEX = {
    EMPTYLINE: /(^[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]*[\n\r\u2028\u2029])/,
    IDENTIFIER: /((^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    INDENT: /(^[ \t]*)/,
    LINETERMINATOR: /[\n\r\u2028]/,
    NUMBER: /^(0b[01]+|0o[0-7]+|0(x|X)[\da-fA-F]+|\d*\.?\d+(?:(e|E)[+-]?\d+)?)/,
    STRING: /^('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/
  };

  KEYWORDS = {
    CASTTYPE: ['array', 'binary', 'bool', 'boolean', 'double', 'int', 'integer', 'float', 'object', 'real', 'string', 'unset'],
    RESERVED: ['clone', 'const', 'cte', 'func', 'in', 'instanceof', 'new', 'not', 'null']
  };

  Lexer = (function() {
    function Lexer() {
      this.initialize();
    }

    Lexer.prototype.initialize = function() {
      this.input = '';
      this.inputLength = 0;
      this.Tokens = [];
      this._Tokens = [];
      this.yytext = '';
      this.pos = 0;
      this.Track = {
        position: {
          col: 1,
          row: 1
        },
        into: {
          mammouth: false,
          call: false
        },
        indent: {
          indentStack: [],
          currentIndent: -1,
          openedIndent: 0
        }
      };
      return this.lexed = false;
    };

    Lexer.prototype.setInput = function(code) {
      this.initialize();
      this.input = code;
      return this.inputLength = code.length;
    };

    Lexer.prototype.lex = function() {
      var token;
      if (!this.lexed) {
        this.tokenize();
      }
      token = this._Tokens.shift();
      if (token) {
        this.yytext = token.value ? token.value : '';
        return token.type;
      }
    };

    Lexer.prototype.tokenize = function() {
      var i, m, token, _i, _len, _ref;
      m = 0;
      while (m !== void 0) {
        m = this.nextToken();
      }
      _ref = this.Tokens;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        token = _ref[i];
        if (token) {
          if (token.type === 'MINDENT') {
            if (this.Tokens[i + 1] && this.Tokens[i - 1]) {
              if (this.Tokens[i + 1].type === ']' && this.Tokens[i - 1].type === 'OUTDENT') {
                this.Tokens.splice(i, 1);
              }
              if (this.Tokens[i + 1].type === 'CALL_END' && this.Tokens[i - 1].type === 'OUTDENT') {
                this.Tokens.splice(i, 1);
              }
            }
          }
        }
      }
      this._Tokens = this.Tokens;
      this.lexed = true;
      return this.Tokens;
    };

    Lexer.prototype.posAdvance = function(string) {
      var i, line, lines, _i, _len, _results;
      lines = string.split(REGEX.LINETERMINATOR);
      _results = [];
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        line = lines[i];
        if (i === 0) {
          _results.push(this.Track.position.col += string.length);
        } else {
          this.Track.position.row++;
          _results.push(this.Track.position.col = string.length);
        }
      }
      return _results;
    };

    Lexer.prototype.colAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      return this.Track.position.col += num;
    };

    Lexer.prototype.addToken = function(token) {
      var tok, _i, _len;
      if (token instanceof Array) {
        for (_i = 0, _len = token.length; _i < _len; _i++) {
          tok = token[_i];
          this.Tokens.push(tok);
        }
        return token;
      } else {
        this.Tokens.push(token);
        return token;
      }
    };

    Lexer.prototype.lastToken = function() {
      if (this.Tokens[this.Tokens.length - 1]) {
        return this.Tokens[this.Tokens.length - 1].type;
      }
    };

    Lexer.prototype.nextToken = function() {
      if (this.pos === this.inputLength) {
        return void 0;
      }
      if (!this.Track.into.mammouth) {
        return this.readTokenRAW();
      }
      if (this.isStartTag(this.pos)) {
        return this.readTokenStartTag();
      }
      if (this.isEndTag(this.pos)) {
        return this.readTokenEndTag();
      }
      if (this.lastToken() === 'LINETERMINAROR' && this.isEmptyLines(this.pos)) {
        return this.skipEmptyLines();
      }
      if (this.lastToken() === 'LINETERMINAROR' && this.isIndent(this.pos)) {
        this.Tokens.pop();
        return this.readIndent();
      }
      if (this.isIdentifier(this.pos)) {
        return this.readTokenIdentifier();
      }
      if (this.isNumber(this.pos)) {
        return this.readTokenNumber();
      }
      if (this.isString(this.pos)) {
        return this.readTokenString();
      }
      return this.getTokenFromCode(this.input.charCodeAt(this.pos));
    };

    Lexer.prototype.getTokenFromCode = function(code) {
      switch (code) {
        case 10:
        case 13:
        case 8232:
          return this.readLineTerminator();
        case 32:
        case 160:
        case 5760:
        case 6158:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
          this.colAdvance();
          return this.nextToken();
        case 33:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'COMPARE',
              value: '!='
            });
          }
          return this.addToken({
            type: 'NOT'
          });
        case 37:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'ASSIGN',
              value: '%='
            });
          }
          return this.addToken({
            type: '%'
          });
        case 38:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'ASSIGN',
              value: '&='
            });
          }
          if (this.input.charCodeAt(this.pos) === 38) {
            this.colAdvance();
            return this.addToken({
              type: 'LOGIC',
              value: '&&'
            });
          }
          return this.addToken({
            type: 'LOGIC',
            value: '&'
          });
        case 40:
          this.colAdvance();
          if (this.lastToken() === 'IDENTIFIER') {
            this.Track.into.call = true;
            return this.addToken({
              type: 'CALL_START'
            });
          }
          return this.addToken({
            type: '('
          });
        case 41:
          this.colAdvance();
          if (this.Track.into.call === true) {
            this.Track.into.call = false;
            return this.addToken({
              type: 'CALL_END'
            });
          }
          return this.addToken({
            type: ')'
          });
        case 42:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 42) {
            this.colAdvance();
            return this.addToken({
              type: '**'
            });
          }
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'ASSIGN',
              value: '*='
            });
          }
          return this.addToken({
            type: '*'
          });
        case 43:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 43) {
            this.colAdvance();
            return this.addToken({
              type: '++'
            });
          }
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'ASSIGN',
              value: '+='
            });
          }
          return this.addToken({
            type: '+'
          });
        case 44:
          this.colAdvance();
          return this.addToken({
            type: ','
          });
        case 45:
          this.colAdvance();
          switch (this.input.charCodeAt(this.pos)) {
            case 45:
              this.colAdvance();
              return this.addToken({
                type: '--'
              });
            case 61:
              this.colAdvance();
              return this.addToken({
                type: 'ASSIGN',
                value: '-='
              });
            case 62:
              this.colAdvance();
              return this.addToken({
                type: '->'
              });
          }
          return this.addToken({
            type: '-'
          });
        case 46:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 46) {
            this.colAdvance();
            return this.addToken({
              type: '..'
            });
          }
          return this.addToken({
            type: '.'
          });
        case 47:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'ASSIGN',
              value: '/='
            });
          }
          return this.addToken({
            type: '/'
          });
        case 58:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 58) {
            this.colAdvance();
            return this.addToken({
              type: '::'
            });
          }
          return this.addToken({
            type: ':'
          });
        case 60:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 60) {
            this.colAdvance();
            if (this.input.charCodeAt(this.pos) === 61) {
              this.colAdvance();
              return this.addToken({
                type: 'ASSIGN',
                value: '<<='
              });
            }
            return this.addToken({
              type: 'BITWISE',
              value: '<<'
            });
          }
          if (this.input.charCodeAt(this.pos) === 45 && this.input.charCodeAt(this.pos + 1) === 62) {
            this.colAdvance(2);
            return this.addToken({
              type: 'CONCAT'
            });
          }
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'COMPARE',
              value: '<='
            });
          }
          return this.addToken({
            type: 'COMPARE',
            value: '<'
          });
        case 61:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 62) {
            this.colAdvance();
            return this.addToken({
              type: '=>'
            });
          }
          if (this.input.charCodeAt(this.pos) === 61 && this.input.charCodeAt(this.pos + 1) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'COMPARE',
              value: '==='
            });
          }
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'COMPARE',
              value: '=='
            });
          }
          return this.addToken({
            type: '='
          });
        case 62:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 62) {
            this.colAdvance();
            if (this.input.charCodeAt(this.pos) === 61) {
              this.colAdvance();
              return this.addToken({
                type: 'ASSIGN',
                value: '>>='
              });
            }
            return this.addToken({
              type: 'BITWISE',
              value: '>>'
            });
          }
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'COMPARE',
              value: '>='
            });
          }
          return this.addToken({
            type: 'COMPARE',
            value: '>'
          });
        case 64:
          this.colAdvance();
          return this.addToken({
            type: '@'
          });
        case 91:
          this.colAdvance();
          this.Track.into.array = true;
          return this.addToken({
            type: '['
          });
        case 93:
          this.colAdvance();
          this.Track.into.array = false;
          return this.addToken({
            type: ']'
          });
        case 94:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'ASSIGN',
              value: '^='
            });
          }
          return this.addToken({
            type: 'BITWISE',
            value: '^'
          });
        case 96:
          this.colAdvance();
          return this.addToken({
            type: '`'
          });
        case 124:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 124) {
            this.colAdvance();
            return this.addToken({
              type: 'BITWISE',
              value: '||'
            });
          }
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'ASSIGN',
              value: '|='
            });
          }
          return this.addToken({
            type: 'BITWISE',
            value: '|'
          });
        case 126:
          this.colAdvance();
          if (this.input.charCodeAt(this.pos) === 126) {
            this.colAdvance();
            if (this.input.charCodeAt(this.pos) === 61) {
              this.colAdvance();
              return this.addToken({
                type: 'ASSIGN',
                value: '.='
              });
            }
            return this.addToken({
              type: 'CONCAT'
            });
          }
          if (this.input.charCodeAt(this.pos) === 61) {
            this.colAdvance();
            return this.addToken({
              type: 'ASSIGN',
              value: '.='
            });
          }
          return this.addToken({
            type: 'CONCAT'
          });
      }
    };

    Lexer.prototype.readTokenRAW = function() {
      var startPos, value;
      startPos = this.pos;
      while (this.pos < this.inputLength && !this.isStartTag(this.pos)) {
        this.pos++;
      }
      if (this.isStartTag(this.pos)) {
        this.Track.into.mammouth = true;
      }
      value = this.input.slice(startPos, this.pos);
      this.posAdvance(value);
      return this.addToken({
        type: 'RAW',
        value: value
      });
    };

    Lexer.prototype.readTokenStartTag = function() {
      this.colAdvance(2);
      return this.addToken({
        type: '{{'
      });
    };

    Lexer.prototype.readTokenEndTag = function() {
      var tokens;
      this.colAdvance(2);
      tokens = [
        {
          type: '}}'
        }
      ];
      this.Track.into.mammouth = false;
      while (this.Track.indent.openedIndent) {
        if (this.lastToken() === 'LINETERMINAROR') {
          this.Tokens.pop();
        }
        tokens.unshift({
          type: 'OUTDENT'
        });
        this.Track.indent.openedIndent--;
      }
      if (this.lastToken() === 'LINETERMINAROR') {
        this.Tokens.pop();
      }
      return this.addToken(tokens);
    };

    Lexer.prototype.skipEmptyLines = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.EMPTYLINE)[0];
      this.pos += value.length;
      this.posAdvance(value);
      return this.nextToken();
    };

    Lexer.prototype.readLineTerminator = function() {
      var _ref;
      this.colAdvance();
      if ((_ref = this.input.charCodeAt(this.pos)) === 10 || _ref === 13 || _ref === 8232) {
        return this.readLineTerminator();
      }
      return this.addToken({
        type: 'LINETERMINAROR'
      });
    };

    Lexer.prototype.readTokenIdentifier = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.IDENTIFIER)[0];
      this.colAdvance(value.length);
      if (value === 'true' || value === 'false') {
        return this.addToken({
          type: 'BOOL',
          value: value
        });
      }
      if (value === 'and' || value === 'or' || value === 'xor') {
        return this.addToken({
          type: 'LOGIC',
          value: value === 'and' ? '&&' : value === 'or' ? '||' : value
        });
      }
      if (value === 'is') {
        return this.addToken({
          type: 'COMPARE',
          value: "==="
        });
      }
      if (value === 'isnt') {
        return this.addToken({
          type: 'COMPARE',
          value: '!='
        });
      }
      if (this.lastToken() === '=>' && __indexOf.call(KEYWORDS.CASTTYPE, value) >= 0) {
        return this.addToken({
          type: 'CASTTYPE',
          value: value
        });
      }
      if (__indexOf.call(KEYWORDS.RESERVED, value) >= 0) {
        if (value === 'cte') {
          value = 'const';
        }
        return this.addToken({
          type: value.toUpperCase()
        });
      }
      return this.addToken({
        type: 'IDENTIFIER',
        value: value
      });
    };

    Lexer.prototype.readIndent = function() {
      var i, indent, indentLevel, reversed, tokens, _i, _j, _len, _len1, _ref;
      indent = this.input.slice(this.pos).match(REGEX.INDENT)[0];
      this.colAdvance(indent.length);
      if (indent.length > this.Track.indent.currentIndent) {
        this.Track.indent.currentIndent = indent.length;
        this.Track.indent.openedIndent++;
        this.Track.indent.indentStack.push(indent.length);
        return this.addToken({
          type: 'INDENT',
          length: indent.length
        });
      } else if (indent.length === this.Track.indent.currentIndent) {
        return this.addToken({
          type: 'MINDENT'
        });
      } else {
        tokens = [];
        reversed = [];
        _ref = this.Track.indent.indentStack;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          reversed.unshift(i);
        }
        for (_j = 0, _len1 = reversed.length; _j < _len1; _j++) {
          indentLevel = reversed[_j];
          if (indent.length === indentLevel) {
            this.Track.indent.currentIndent = indent.length;
            tokens.push({
              type: 'MINDENT'
            });
          } else if (indent.length < indentLevel) {
            this.Track.indent.currentIndent = this.Track.indent.indentStack.pop();
            this.Track.indent.openedIndent--;
            tokens.push({
              type: 'OUTDENT'
            });
          }
        }
        return this.addToken(tokens);
      }
    };

    Lexer.prototype.readTokenNumber = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.NUMBER)[0];
      this.colAdvance(value.length);
      return this.addToken({
        type: 'NUMBER',
        value: value
      });
    };

    Lexer.prototype.readTokenString = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.STRING)[0];
      this.pos += value.length;
      this.posAdvance(value);
      return this.addToken({
        type: 'STRING',
        value: value
      });
    };

    Lexer.prototype.isStartTag = function(pos) {
      if (this.pos + 1 > this.inputLength - 1) {
        return false;
      }
      return this.input.charCodeAt(pos) === 123 && this.input.charCodeAt(this.pos + 1) === 123;
    };

    Lexer.prototype.isEndTag = function(pos) {
      if (this.pos + 1 > this.inputLength - 1) {
        return false;
      }
      return this.input.charCodeAt(pos) === 125 && this.input.charCodeAt(this.pos + 1) === 125;
    };

    Lexer.prototype.isEmptyLines = function(pos) {
      return this.input.slice(pos).match(REGEX.EMPTYLINE) !== null;
    };

    Lexer.prototype.isIdentifier = function(pos) {
      return this.input.slice(pos).match(REGEX.IDENTIFIER) !== null;
    };

    Lexer.prototype.isIndent = function(pos) {
      return this.input.slice(pos).match(REGEX.INDENT) !== null && this.lastToken() !== 'INDENT';
    };

    Lexer.prototype.isNumber = function(pos) {
      return this.input.slice(pos).match(REGEX.NUMBER) !== null;
    };

    Lexer.prototype.isString = function(pos) {
      return this.input.slice(pos).match(REGEX.STRING) !== null;
    };

    return Lexer;

  })();

  module.exports = new Lexer;

}).call(this);
