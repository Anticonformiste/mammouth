// Generated by CoffeeScript 1.7.1
(function() {
  var CurrentIndent, IndentStack, IntoArray, IntoMammouth, Lexer, OpenedIndent, RegularExpression, col, lexer, row;

  Lexer = require("lex");

  col = 0;

  row = 0;

  IntoMammouth = false;

  IntoArray = false;

  IndentStack = [];

  CurrentIndent = -1;

  OpenedIndent = 0;

  lexer = module.exports = new Lexer(function(char) {
    throw new Error("Unexpected character at row " + row + ", col " + col + ": " + char);
  });

  RegularExpression = {
    PlainText: /(((?!({{|}})).)*)/,
    MammouthStart: /{{/,
    MammouthEnd: /}}/,
    Python_indent: /(^[ \t]*)/gm,
    EmptyLine: /(^[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]*[\n\r\u2028\u2029])/gmi,
    IDENTIFIER: /(([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    NUMBER: /(0b[01]+|0o[0-7]+|0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)/,
    STRING: /('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/,
    BOOL: /true|false/,
    LineTerminator: /[\n\r\u2028\u2029]/,
    Zs: /[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]/
  };

  lexer.addRule(RegularExpression.PlainText, function(lexeme) {
    if (!IntoMammouth) {
      col += lexeme.length;
      this.yytext = lexeme;
      return "PlainText";
    } else {
      return this.reject = true;
    }
  });

  lexer.addRule(RegularExpression.EmptyLine, function(lexeme) {
    col += lexeme.length;
    return 'BLANKLINE';
  });

  lexer.addRule(RegularExpression.Python_indent, function(lexeme) {
    var a, current_line_indent, i, tokens, _i, _j, _len, _len1;
    if (IntoArray) {
      this.reject = true;
    }
    if (IntoMammouth) {
      col += lexeme.length;
      current_line_indent = lexeme.replace(/\t/g, '    ').length;
      if (current_line_indent > CurrentIndent) {
        CurrentIndent = current_line_indent;
        OpenedIndent++;
        IndentStack.push(CurrentIndent);
        return ['INDENT', 'SAMEDENT'];
      } else if (current_line_indent < CurrentIndent) {
        tokens = [];
        a = [];
        for (_i = 0, _len = IndentStack.length; _i < _len; _i++) {
          i = IndentStack[_i];
          a.unshift(i);
        }
        for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
          i = a[_j];
          if (current_line_indent === i) {
            CurrentIndent = i;
            tokens.push('SAMEDENT');
          } else if (current_line_indent < i) {
            CurrentIndent = IndentStack.pop();
            tokens.push('DEDENT');
            OpenedIndent -= 1;
          }
        }
        return tokens;
      } else {
        return 'SAMEDENT';
      }
    }
  });

  lexer.addRule(RegularExpression.Zs, function(lexeme) {});

  lexer.addRule(RegularExpression.MammouthStart, function() {
    col += 2;
    IntoMammouth = true;
    return "{{";
  });

  lexer.addRule(RegularExpression.MammouthEnd, function() {
    var tokens;
    col += 2;
    IntoMammouth = false;
    tokens = ["}}"];
    while (OpenedIndent > 0) {
      tokens.unshift('DEDENT');
      OpenedIndent--;
    }
    return tokens;
  });

  lexer.addRule(/\(/, function(lexeme) {
    col += lexeme.length;
    return "(";
  });

  lexer.addRule(/\)/, function(lexeme) {
    col += lexeme.length;
    return ")";
  });

  lexer.addRule(/\[/, function(lexeme) {
    col += lexeme.length;
    IntoArray = true;
    return "[";
  });

  lexer.addRule(/\]/, function(lexeme) {
    col += lexeme.length;
    IntoArray = false;
    return "]";
  });

  lexer.addRule(/,/, function(lexeme) {
    col += lexeme.length;
    return ",";
  });

  lexer.addRule(/::/, function(lexeme) {
    col += lexeme.length;
    return "::";
  });

  lexer.addRule(/:/, function(lexeme) {
    col += lexeme.length;
    return ":";
  });

  lexer.addRule(/\.\./, function(lexeme) {
    col += lexeme.length;
    return "..";
  });

  lexer.addRule(/\./, function(lexeme) {
    col += lexeme.length;
    return ".";
  });

  lexer.addRule(/<->/, function(lexeme) {
    col += lexeme.length;
    return "<->";
  });

  lexer.addRule(/->/, function(lexeme) {
    col += lexeme.length;
    return "->";
  });

  lexer.addRule(/--/, function(lexeme) {
    col += lexeme.length;
    return "--";
  });

  lexer.addRule(/\+\+/, function(lexeme) {
    col += lexeme.length;
    return "++";
  });

  lexer.addRule(/\*\*/, function(lexeme) {
    col += lexeme.length;
    return "**";
  });

  lexer.addRule(/\|\|/, function(lexeme) {
    col += lexeme.length;
    this.yytext = '||';
    return "LOGIC";
  });

  lexer.addRule(/&&/, function(lexeme) {
    col += lexeme.length;
    this.yytext = 'and';
    return "LOGIC";
  });

  lexer.addRule(/\|/, function(lexeme) {
    col += lexeme.length;
    this.yytext = 'or';
    return "LOGIC";
  });

  lexer.addRule(/&/, function(lexeme) {
    col += lexeme.length;
    this.yytext = 'and';
    return "LOGIC";
  });

  lexer.addRule(/!|~/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "NOT";
  });

  lexer.addRule(/-/, function(lexeme) {
    col += lexeme.length;
    return "-";
  });

  lexer.addRule(/\+/, function(lexeme) {
    col += lexeme.length;
    return "+";
  });

  lexer.addRule(/\*/, function(lexeme) {
    col += lexeme.length;
    return "*";
  });

  lexer.addRule(/\//, function(lexeme) {
    col += lexeme.length;
    return "/";
  });

  lexer.addRule(/%/, function(lexeme) {
    col += lexeme.length;
    return "%";
  });

  lexer.addRule(/\?/, function(lexeme) {
    col += lexeme.length;
    return "?";
  });

  lexer.addRule(/>>/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "SHIFT";
  });

  lexer.addRule(/<</, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "SHIFT";
  });

  lexer.addRule(/</, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "COMPARE";
  });

  lexer.addRule(/>/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "COMPARE";
  });

  lexer.addRule(/<=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "COMPARE";
  });

  lexer.addRule(/>=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "COMPARE";
  });

  lexer.addRule(/!\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "COMPARE";
  });

  lexer.addRule(/\=\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "COMPARE";
  });

  lexer.addRule(/\=\=\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "COMPARE";
  });

  lexer.addRule(/\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "=";
  });

  lexer.addRule(/\+\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "ASSIGN";
  });

  lexer.addRule(/-\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "ASSIGN";
  });

  lexer.addRule(/\*\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "ASSIGN";
  });

  lexer.addRule(/\/\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "ASSIGN";
  });

  lexer.addRule(/\%\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    return "ASSIGN";
  });

  lexer.addRule(RegularExpression.BOOL, function(lexeme) {
    col += lexeme.length;
    if (lexeme === 'true') {
      this.yytext = true;
    } else if (lexeme === 'false') {
      this.yytext = false;
    }
    return "BOOL";
  });

  lexer.addRule(RegularExpression.IDENTIFIER, function(lexeme) {
    col += lexeme.length;
    if (lexeme === "cte") {
      return "cte";
    } else if (lexeme === "use") {
      return "use";
    } else if (lexeme === "and") {
      this.yytext = "and";
      return "LOGIC";
    } else if (lexeme === "or") {
      this.yytext = "or";
      return "LOGIC";
    } else if (lexeme === "not") {
      this.yytext = "!";
      return "NOT";
    } else if (lexeme === "is") {
      this.yytext = "===";
      return "COMPARE";
    } else if (lexeme === 'in') {
      this.yytext = "IN";
      return 'RELATION';
    } else if (lexeme === 'echo') {
      return 'ECHO';
    } else if (lexeme === 'return') {
      return 'RETURN';
    } else if (lexeme === 'break') {
      return 'BREAK';
    } else if (lexeme === 'continue') {
      return 'CONTINUE';
    } else if (lexeme === 'include') {
      return 'INCLUDE';
    } else if (lexeme === 'require') {
      return 'REQUIRE';
    } else if (lexeme === 'once') {
      return 'ONCE';
    } else if (lexeme === 'if') {
      return 'IF';
    } else if (lexeme === 'else') {
      return 'ELSE';
    } else if (lexeme === 'then') {
      return 'THEN';
    } else if (lexeme === 'while') {
      return 'WHILE';
    } else {
      this.yytext = lexeme;
      return "IDENTIFIER";
    }
  });

  lexer.addRule(RegularExpression.NUMBER, function(lexeme) {
    col += lexeme.length;
    this.yytext = parseFloat(lexeme);
    return "NUMBER";
  });

  lexer.addRule(RegularExpression.STRING, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme[0] === '"' ? lexeme.replace(/"/g, '') : lexeme[0] === '"' ? lexeme.replace(/'/g, '') : void 0;
    return "STRING";
  });

  lexer.addRule(RegularExpression.LineTerminator, function(lexeme) {
    col = 1;
    row++;
    return "LineTerminator";
  });

}).call(this);
