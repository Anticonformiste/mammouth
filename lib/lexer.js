// Generated by CoffeeScript 1.9.3
(function() {
  var Lexer, REGEX, Tokens, lexer, m;

  REGEX = {
    IDENTIFIER: /((^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    INDENT: /(^[ \t]*)/,
    LINETERMINATOR: /[\n\r\u2028]/
  };

  Lexer = (function() {
    function Lexer() {
      this.initialize();
    }

    Lexer.prototype.initialize = function() {
      this.input = '';
      this.inputLength = 0;
      this.Tokens = [];
      this.pos = 0;
      return this.Track = {
        position: {
          col: 1,
          row: 1
        },
        into: {
          mammouth: false
        },
        indent: {
          indentStack: [],
          currentIndent: -1,
          openedIndent: 0
        }
      };
    };

    Lexer.prototype.setInput = function(code) {
      this.initialize();
      this.input = code;
      return this.inputLength = code.length;
    };

    Lexer.prototype.posAdvance = function(string) {
      var i, j, len, line, lines, results;
      lines = string.split(REGEX.LINETERMINATOR);
      results = [];
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        if (i === 0) {
          results.push(this.Track.position.col += string.length);
        } else {
          this.Track.position.row++;
          results.push(this.Track.position.col = string.length);
        }
      }
      return results;
    };

    Lexer.prototype.addToken = function(token) {
      var j, len, tok;
      if (token instanceof Array) {
        for (j = 0, len = token.length; j < len; j++) {
          tok = token[j];
          this.Tokens.push(tok);
        }
        return token;
      } else {
        this.Tokens.push(token);
        return token;
      }
    };

    Lexer.prototype.lastToken = function() {
      return this.Tokens[this.Tokens.length - 1].type;
    };

    Lexer.prototype.nextToken = function() {
      if (this.pos === this.inputLength) {
        return void 0;
      }
      if (!this.Track.into.mammouth) {
        return this.readRAW();
      }
      if (this.isStartTag(this.pos)) {
        return this.readTokenStartTag();
      }
      if (this.isEndTag(this.pos)) {
        return this.readTokenEndTag();
      }
      if (this.lastToken() === 'LINETERMINAROR' && this.isIndent(this.pos)) {
        this.Tokens.pop();
        return this.readIndent();
      }
      if (this.isIdentifier(this.pos)) {
        return this.readTokenIdentifier();
      }
      return this.getTokenFromCode(this.input.charCodeAt(this.pos));
    };

    Lexer.prototype.getTokenFromCode = function(code) {
      switch (code) {
        case 10:
        case 13:
        case 8232:
          return this.readLineTerminator();
      }
    };

    Lexer.prototype.readRAW = function() {
      var startPos, value;
      startPos = this.pos;
      while (this.pos < this.inputLength && !this.isStartTag(this.pos)) {
        this.pos++;
      }
      if (this.isStartTag(this.pos)) {
        this.Track.into.mammouth = true;
      }
      value = this.input.slice(startPos, this.pos);
      this.posAdvance(value);
      return this.addToken({
        type: 'RAW',
        value: value
      });
    };

    Lexer.prototype.readTokenStartTag = function() {
      this.Track.position.col += 2;
      this.pos += 2;
      return this.addToken({
        type: '{{'
      });
    };

    Lexer.prototype.readTokenEndTag = function() {
      var tokens;
      this.Track.position.col += 2;
      this.pos += 2;
      tokens = [
        {
          type: '}}'
        }
      ];
      this.Track.into.mammouth = false;
      while (this.Track.indent.openedIndent) {
        tokens.unshift({
          type: 'OUTDENT'
        });
        this.Track.indent.openedIndent--;
      }
      return this.addToken(tokens);
    };

    Lexer.prototype.readLineTerminator = function() {
      this.pos++;
      this.Track.position.row++;
      return this.addToken({
        type: 'LINETERMINAROR'
      });
    };

    Lexer.prototype.readTokenIdentifier = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.IDENTIFIER)[0];
      this.pos += value.length;
      this.Track.position.col += value.length;
      return this.addToken({
        type: 'IDENTIFIER',
        value: value
      });
    };

    Lexer.prototype.readIndent = function() {
      var i, indent, indentLevel, j, k, len, len1, ref, reversed, tokens;
      indent = this.input.slice(this.pos).match(REGEX.INDENT)[0];
      this.pos += indent.length;
      this.Track.position.col += indent.length;
      if (indent.length > this.Track.indent.currentIndent) {
        this.Track.indent.currentIndent = indent.length;
        this.Track.indent.openedIndent++;
        this.Track.indent.indentStack.push(indent.length);
        return this.addToken({
          type: 'INDENT',
          length: indent.length
        });
      } else if (indent.length === this.Track.indent.currentIndent) {
        return this.addToken({
          type: 'MINDENT'
        });
      } else {
        tokens = [];
        reversed = [];
        ref = this.Track.indent.indentStack;
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          reversed.unshift(i);
        }
        for (k = 0, len1 = reversed.length; k < len1; k++) {
          indentLevel = reversed[k];
          if (indent.length === indentLevel) {
            this.Track.indent.currentIndent = indent.length;
            tokens.push({
              type: 'MINDENT'
            });
          } else if (indent.length < indentLevel) {
            this.Track.indent.currentIndent = this.Track.indent.indentStack.pop();
            this.Track.indent.openedIndent--;
            tokens.push({
              type: 'OUTDENT'
            });
          }
        }
        return this.addToken(tokens);
      }
    };

    Lexer.prototype.isStartTag = function(pos) {
      if (this.pos + 1 > this.inputLength - 1) {
        return false;
      }
      return this.input.charCodeAt(pos) === 123 && this.input.charCodeAt(this.pos + 1) === 123;
    };

    Lexer.prototype.isEndTag = function(pos) {
      if (this.pos + 1 > this.inputLength - 1) {
        return false;
      }
      return this.input.charCodeAt(pos) === 125 && this.input.charCodeAt(this.pos + 1) === 125;
    };

    Lexer.prototype.isIdentifier = function(pos) {
      return this.input.slice(pos).match(REGEX.IDENTIFIER) !== null;
    };

    Lexer.prototype.isIndent = function(pos) {
      return this.input.slice(pos).match(REGEX.INDENT) !== null;
    };

    return Lexer;

  })();

  lexer = new Lexer;

  lexer.setInput('sdfsdfsdf{{\nv1\n v2\n v2\n   v3\n   v3\n v2}}sdfsd');

  Tokens = [];

  m = 0;

  while (m !== void 0) {
    m = lexer.nextToken();
  }

  console.log(lexer.Tokens);

}).call(this);
