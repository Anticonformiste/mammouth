// Generated by CoffeeScript 1.9.3
(function() {
  var Lexer, REGEX, Tokens, lexer, m;

  REGEX = {
    IDENTIFIER: /((^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    LINETERMINATOR: /[\n\r\u2028]/
  };

  Lexer = (function() {
    function Lexer() {
      this.initialize();
    }

    Lexer.prototype.initialize = function() {
      this.input = '';
      this.inputLength = 0;
      this.Tokens = [];
      this.pos = 0;
      return this.Track = {
        position: {
          col: 1,
          row: 1
        },
        into: {
          mammouth: false
        }
      };
    };

    Lexer.prototype.setInput = function(code) {
      this.initialize();
      this.input = code;
      return this.inputLength = code.length;
    };

    Lexer.prototype.addToken = function(token) {
      this.Tokens.push(token);
      console.log(token, this.pos, this.inputLength - 1);
      return token;
    };

    Lexer.prototype.posAdvance = function(string) {
      var i, j, len, line, lines, results;
      lines = string.split(REGEX.LINETERMINATOR);
      results = [];
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        if (i === 0) {
          results.push(this.Track.position.col += string.length);
        } else {
          this.Track.position.row++;
          results.push(this.Track.position.col = string.length);
        }
      }
      return results;
    };

    Lexer.prototype.nextToken = function() {
      if (this.pos === this.inputLength) {
        return void 0;
      }
      if (!this.Track.into.mammouth) {
        return this.readRAW();
      }
      if (this.isStartTag(this.pos)) {
        return this.readTokenStartTag();
      }
      if (this.isEndTag(this.pos)) {
        return this.readTokenEndTag();
      }
      if (this.isIdentifier(this.pos)) {
        return this.readTokenIdentifier();
      }
      return this.getTokenFromCode(this.input.charCodeAt(this.pos));
    };

    Lexer.prototype.getTokenFromCode = function(code) {
      switch (code) {
        case 10:
        case 13:
        case 8232:
          return this.readLineTerminator();
      }
    };

    Lexer.prototype.readRAW = function() {
      var startPos, value;
      startPos = this.pos;
      while (this.pos < this.inputLength && !this.isStartTag(this.pos)) {
        this.pos++;
      }
      if (this.isStartTag(this.pos)) {
        this.Track.into.mammouth = true;
      }
      value = this.input.slice(startPos, this.pos);
      this.posAdvance(value);
      return this.addToken({
        type: 'RAW',
        value: value
      });
    };

    Lexer.prototype.readTokenStartTag = function() {
      this.Track.position.col += 2;
      this.pos += 2;
      return this.addToken({
        type: '{{'
      });
    };

    Lexer.prototype.readTokenEndTag = function() {
      this.Track.position.col += 2;
      this.pos += 2;
      this.Track.into.mammouth = false;
      return this.addToken({
        type: '}}'
      });
    };

    Lexer.prototype.readLineTerminator = function() {
      this.pos++;
      this.Track.position.row++;
      return this.addToken({
        type: 'LINETERMINAROR'
      });
    };

    Lexer.prototype.readTokenIdentifier = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.IDENTIFIER)[0];
      this.pos += value.length;
      this.Track.position.col += value.length;
      return this.addToken({
        type: 'IDENTIFIER',
        value: value
      });
    };

    Lexer.prototype.isStartTag = function(pos) {
      if (this.pos + 1 > this.inputLength - 1) {
        return false;
      }
      return this.input.charCodeAt(pos) === 123 && this.input.charCodeAt(this.pos + 1) === 123;
    };

    Lexer.prototype.isEndTag = function(pos) {
      if (this.pos + 1 > this.inputLength - 1) {
        return false;
      }
      return this.input.charCodeAt(pos) === 125 && this.input.charCodeAt(this.pos + 1) === 125;
    };

    Lexer.prototype.isIdentifier = function(pos) {
      return this.input.slice(pos).match(REGEX.IDENTIFIER) !== null;
    };

    return Lexer;

  })();

  lexer = new Lexer;

  lexer.setInput('sdfsdfsdf{{fs\ndf}}sdfsd');

  Tokens = [];

  m = 0;

  while (m !== void 0) {
    m = lexer.nextToken();
    Tokens.push(m);
  }

  console.log(Tokens);

}).call(this);
