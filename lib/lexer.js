// Generated by CoffeeScript 1.7.1
(function() {
  var CloseIndents, IntoArray, IntoHereDoc, IntoMammouth, Levels, Lexer, OpenedParens, RegularExpression, captureTypeCasting, col, lastIsIdentifier, lexer, row, setToken, tokenStack;

  Lexer = require("lex");

  col = 1;

  row = 1;

  IntoArray = false;

  IntoMammouth = false;

  IntoHereDoc = false;

  Levels = [
    {
      IndentStack: [],
      CurrentIndent: -1,
      OpenedIndent: 0
    }
  ];

  OpenedParens = [];

  lastIsIdentifier = false;

  captureTypeCasting = false;

  tokenStack = [];

  setToken = function(token) {
    if (token === 'IDENTIFIER' && tokenStack[0] !== 'FUNC') {
      lastIsIdentifier = true;
    } else {
      lastIsIdentifier = false;
      if (token === '=>') {
        captureTypeCasting = true;
      } else {
        captureTypeCasting = false;
      }
    }
    return tokenStack.unshift(token);
  };

  CloseIndents = function(tokens) {
    while (Levels[0].OpenedIndent > 0) {
      tokens.unshift('OUTDENT');
      Levels[0].OpenedIndent--;
    }
    return tokens;
  };

  lexer = module.exports = new Lexer(function(char) {
    throw new Error("Unexpected character at row " + row + ", col " + col + ": " + char);
  });

  RegularExpression = {
    PlainText: /(((?!({{|}}))([\n\r\u2028\u2029]|.))*)/,
    MammouthStart: /{{/,
    MammouthEnd: /}}/,
    Python_indent: /(^[ \t]*)/gm,
    EmptyLine: /(^[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]*[\n\r\u2028\u2029])/gmi,
    IDENTIFIER: /(([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    NUMBER: /(0b[01]+|0o[0-7]+|0(x|X)[\da-fA-F]+|\d*\.?\d+(?:(e|E)[+-]?\d+)?)/,
    STRING: /('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/,
    HEREDOC: /(((?!(\`))(.|[\n\r\u2028\u2029]|[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]))*)/,
    LineTerminator: /[\n\r\u2028\u2029]/,
    Zs: /[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]/,
    SingleComment: /#(.*)+[\n\r\u2028\u2029]/,
    MultiComment: /###(([\n\r\u2028\u2029]|.)*)###/
  };

  lexer.addRule(RegularExpression.PlainText, function(lexeme) {
    if (!IntoMammouth) {
      col += lexeme.length;
      this.yytext = lexeme;
      setToken('PlainText');
      return 'PlainText';
    } else {
      return this.reject = true;
    }
  });

  lexer.addRule(RegularExpression.HEREDOC, function(lexeme) {
    if (IntoMammouth && IntoHereDoc) {
      col += lexeme.length;
      this.yytext = lexeme;
      setToken('HEREDOCTEXT');
      return 'HEREDOCTEXT';
    } else {
      return this.reject = true;
    }
  });

  lexer.addRule(RegularExpression.EmptyLine, function(lexeme) {});

  lexer.addRule(RegularExpression.SingleComment, function(lexeme) {});

  lexer.addRule(RegularExpression.MultiComment, function(lexeme) {});

  lexer.addRule(RegularExpression.Python_indent, function(lexeme) {
    var a, current_line_indent, i, tokens, _i, _j, _len, _len1, _ref;
    if (IntoMammouth) {
      col += lexeme.length;
      current_line_indent = lexeme.replace(/\t/g, '    ').length;
      if (current_line_indent > Levels[0].CurrentIndent) {
        Levels[0].CurrentIndent = current_line_indent;
        Levels[0].OpenedIndent++;
        Levels[0].IndentStack.push(Levels[0].CurrentIndent);
        setToken('INDENT');
        return 'INDENT';
      } else if (current_line_indent < Levels[0].CurrentIndent) {
        tokens = [];
        a = [];
        _ref = Levels[0].IndentStack;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          a.unshift(i);
        }
        for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
          i = a[_j];
          if (current_line_indent === i) {
            Levels[0].CurrentIndent = i;
          } else if (current_line_indent < i) {
            Levels[0].CurrentIndent = Levels[0].IndentStack.pop();
            setToken('OUTDENT');
            tokens.push('OUTDENT');
            Levels[0].OpenedIndent -= 1;
          }
        }
        return tokens;
      } else {

      }
    }
  });

  lexer.addRule(RegularExpression.Zs, function(lexeme) {});

  lexer.addRule(RegularExpression.MammouthStart, function() {
    var ShouldCloseCall;
    col += 2;
    IntoMammouth = true;
    setToken('{{');
    IntoArray = false;
    IntoHereDoc = false;
    Levels = [
      {
        IndentStack: [],
        CurrentIndent: -1,
        OpenedIndent: 0
      }
    ];
    lastIsIdentifier = false;
    ShouldCloseCall = false;
    captureTypeCasting = false;
    tokenStack = [];
    return '{{';
  });

  lexer.addRule(RegularExpression.MammouthEnd, function() {
    var token, tokens, _i, _len;
    col += 2;
    IntoMammouth = false;
    tokens = CloseIndents(['}}']);
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
      token = tokens[_i];
      setToken(token);
    }
    return tokens;
  });

  lexer.addRule(/\`/, function(lexeme) {
    col += lexeme.length;
    if (IntoHereDoc) {
      IntoHereDoc = false;
    } else {
      IntoHereDoc = true;
    }
    setToken('`');
    return '`';
  });

  lexer.addRule(/\{/, function(lexeme) {
    col += lexeme.length;
    setToken('{');
    return '{';
  });

  lexer.addRule(/\}/, function(lexeme) {
    col += lexeme.length;
    setToken('}');
    return '}';
  });

  lexer.addRule(/\(/, function(lexeme) {
    col += lexeme.length;
    if (lastIsIdentifier) {
      lastIsIdentifier = false;
      OpenedParens.unshift('CALL_END');
      setToken('CALL_START');
      return 'CALL_START';
    } else {
      OpenedParens.unshift(')');
      setToken('(');
      return '(';
    }
  });

  lexer.addRule(/\)/, function(lexeme) {
    var tok;
    col += lexeme.length;
    tok = OpenedParens.shift();
    setToken(tok);
    return tok;
  });

  lexer.addRule(/\;/, function(lexeme) {
    col += lexeme.length;
    setToken(';');
    return ';';
  });

  lexer.addRule(/\[/, function(lexeme) {
    col += lexeme.length;
    setToken('[');
    return '[';
  });

  lexer.addRule(/\]/, function(lexeme) {
    col += lexeme.length;
    setToken(']');
    return ']';
  });

  lexer.addRule(/@/, function(lexeme) {
    col += lexeme.length;
    setToken('@');
    return '@';
  });

  lexer.addRule(/,/, function(lexeme) {
    col += lexeme.length;
    setToken(',');
    return ',';
  });

  lexer.addRule(/\./, function(lexeme) {
    col += lexeme.length;
    setToken('.');
    return '.';
  });

  lexer.addRule(/\.\./, function(lexeme) {
    col += lexeme.length;
    setToken('..');
    return '..';
  });

  lexer.addRule(/<->/, function(lexeme) {
    col += lexeme.length;
    setToken('<->');
    return '<->';
  });

  lexer.addRule(/->/, function(lexeme) {
    col += lexeme.length;
    setToken('->');
    return '->';
  });

  lexer.addRule(/\=>/, function(lexeme) {
    col += lexeme.length;
    setToken('=>');
    return '=>';
  });

  lexer.addRule(/\=\=>/, function(lexeme) {
    col += lexeme.length;
    setToken('==>');
    return '==>';
  });

  lexer.addRule(/:/, function(lexeme) {
    col += lexeme.length;
    setToken(':');
    return ':';
  });

  lexer.addRule(/::/, function(lexeme) {
    col += lexeme.length;
    setToken('::');
    return '::';
  });

  lexer.addRule(/\+/, function(lexeme) {
    col += lexeme.length;
    setToken('+');
    return '+';
  });

  lexer.addRule(/\+\+/, function(lexeme) {
    col += lexeme.length;
    setToken('++');
    return '++';
  });

  lexer.addRule(/-/, function(lexeme) {
    col += lexeme.length;
    setToken('-');
    return '-';
  });

  lexer.addRule(/--/, function(lexeme) {
    col += lexeme.length;
    setToken('--');
    return '--';
  });

  lexer.addRule(/\?/, function(lexeme) {
    col += lexeme.length;
    setToken('?');
    return '?';
  });

  lexer.addRule(/\*/, function(lexeme) {
    col += lexeme.length;
    setToken('*');
    return '*';
  });

  lexer.addRule(/\*\*/, function(lexeme) {
    col += lexeme.length;
    setToken('**');
    return '**';
  });

  lexer.addRule(/\//, function(lexeme) {
    col += lexeme.length;
    setToken('/');
    return '/';
  });

  lexer.addRule(/\\/, function(lexeme) {
    col += lexeme.length;
    setToken('\\');
    return '\\';
  });

  lexer.addRule(/%/, function(lexeme) {
    col += lexeme.length;
    setToken('%');
    return '%';
  });

  lexer.addRule(/\+\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/-\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/\*\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/\/\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/\%\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('ASSIGN');
    return "ASSIGN";
  });

  lexer.addRule(/&/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('&');
    return "&";
  });

  lexer.addRule(/>>/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('>>');
    return "SHIFT";
  });

  lexer.addRule(/<</, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('<<');
    return 'SHIFT';
  });

  lexer.addRule(/\|\|/, function(lexeme) {
    col += lexeme.length;
    this.yytext = '||';
    setToken('LOGIC');
    return 'LOGIC';
  });

  lexer.addRule(/&&/, function(lexeme) {
    col += lexeme.length;
    this.yytext = 'and';
    setToken('LOGIC');
    return 'LOGIC';
  });

  lexer.addRule(/\|/, function(lexeme) {
    col += lexeme.length;
    this.yytext = 'or';
    setToken('LOGIC');
    return 'LOGIC';
  });

  lexer.addRule(/</, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/>/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/<=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/>=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/!\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/\=\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/\=\=\=/, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('COMPARE');
    return "COMPARE";
  });

  lexer.addRule(/\=/, function(lexeme) {
    col += lexeme.length;
    setToken('=');
    return "=";
  });

  lexer.addRule(RegularExpression.IDENTIFIER, function(lexeme) {
    col += lexeme.length;
    if (captureTypeCasting) {
      this.yytext = lexeme;
      setToken('cType');
      return 'cType';
    }
    if (lexeme === 'true' || lexeme === 'false') {
      this.yytext = eval(lexeme);
      setToken('BOOL');
      return 'BOOL';
    } else if (lexeme === 'break') {
      setToken('BREAK');
      return 'BREAK';
    } else if (lexeme === 'and') {
      this.yytext = lexeme;
      setToken('LOGIC');
      return 'LOGIC';
    } else if (lexeme === 'abstract') {
      setToken('ABSTRACT');
      return 'ABSTRACT';
    } else if (lexeme === 'as') {
      setToken('AS');
      return 'AS';
    } else if (lexeme === 'catch') {
      setToken('CATCH');
      return 'CATCH';
    } else if (lexeme === 'case') {
      setToken('CASE');
      return 'CASE';
    } else if (lexeme === 'class') {
      setToken('CLASS');
      return 'CLASS';
    } else if (lexeme === 'clone') {
      setToken('CLONE');
      return 'CLONE';
    } else if (lexeme === 'continue') {
      setToken('CONTINUE');
      return 'CONTINUE';
    } else if (lexeme === 'cte') {
      setToken('CTE');
      return 'CTE';
    } else if (lexeme === 'declare') {
      setToken('DECLARE');
      return 'DECLARE';
    } else if (lexeme === 'delete') {
      setToken('DELETE');
      return 'DELETE';
    } else if (lexeme === 'do') {
      setToken('DO');
      return 'DO';
    } else if (lexeme === 'each') {
      setToken('EACH');
      return 'EACH';
    } else if (lexeme === 'echo') {
      setToken('ECHO');
      return 'ECHO';
    } else if (lexeme === 'else') {
      setToken('ELSE');
      return 'ELSE';
    } else if (lexeme === 'exec') {
      setToken('EXEC');
      return 'EXEC';
    } else if (lexeme === 'extends') {
      setToken('EXTENDS');
      return 'EXTENDS';
    } else if (lexeme === 'final') {
      setToken('FINAL');
      return 'FINAL';
    } else if (lexeme === 'finally') {
      setToken('FINALLY');
      return 'FINALLY';
    } else if (lexeme === 'for') {
      setToken('FOR');
      return 'FOR';
    } else if (lexeme === 'func') {
      setToken('FUNC');
      return 'FUNC';
    } else if (lexeme === 'goto') {
      setToken('GOTO');
      return 'GOTO';
    } else if (lexeme === 'if') {
      setToken('IF');
      return 'IF';
    } else if (lexeme === 'implements') {
      setToken('IMPLEMENTS');
      return 'IMPLEMENTS';
    } else if (lexeme === 'include') {
      setToken('INCLUDE');
      return 'INCLUDE';
    } else if (lexeme === 'instanceof') {
      setToken('INSTANCEOF');
      return 'INSTANCEOF';
    } else if (lexeme === 'interface') {
      setToken('INTERFACE');
      return 'INTERFACE';
    } else if (lexeme === "is") {
      this.yytext = "===";
      setToken('COMPARE');
      return "COMPARE";
    } else if (lexeme === "isnt") {
      this.yytext = "!=";
      setToken('COMPARE');
      return "COMPARE";
    } else if (lexeme === "in") {
      setToken('IN');
      return "IN";
    } else if (lexeme === 'not') {
      setToken('NOT');
      return 'NOT';
    } else if (lexeme === 'namespace') {
      setToken('NAMESPACE');
      return 'NAMESPACE';
    } else if (lexeme === 'new') {
      setToken('NEW');
      return 'NEW';
    } else if (lexeme === 'null') {
      setToken('NULL');
      return 'NULL';
    } else if (lexeme === 'once') {
      setToken('ONCE');
      return 'ONCE';
    } else if (lexeme === 'or') {
      this.yytext = lexeme;
      setToken('LOGIC');
      return 'LOGIC';
    } else if (lexeme === 'public') {
      setToken('PUBLIC');
      return 'PUBLIC';
    } else if (lexeme === 'private') {
      setToken('PRIVATE');
      return 'PRIVATE';
    } else if (lexeme === 'protected') {
      setToken('PROTECTED');
      return 'PROTECTED';
    } else if (lexeme === 'static') {
      setToken('STATIC');
      return 'STATIC';
    } else if (lexeme === 'require') {
      setToken('REQUIRE');
      return 'REQUIRE';
    } else if (lexeme === 'return') {
      setToken('RETURN');
      return 'RETURN';
    } else if (lexeme === 'switch') {
      setToken('SWITCH');
      return 'SWITCH';
    } else if (lexeme === 'then') {
      setToken('THEN');
      return 'THEN';
    } else if (lexeme === 'try') {
      setToken('TRY');
      return 'TRY';
    } else if (lexeme === 'use') {
      setToken('USE');
      return 'USE';
    } else if (lexeme === 'when') {
      setToken('WHEN');
      return 'WHEN';
    } else if (lexeme === 'while') {
      setToken('WHILE');
      return 'WHILE';
    } else {
      this.yytext = lexeme;
      setToken('IDENTIFIER');
      return "IDENTIFIER";
    }
  });

  lexer.addRule(RegularExpression.NUMBER, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('NUMBER');
    return "NUMBER";
  });

  lexer.addRule(RegularExpression.STRING, function(lexeme) {
    col += lexeme.length;
    this.yytext = lexeme;
    setToken('STRING');
    return "STRING";
  });

  lexer.addRule(RegularExpression.LineTerminator, function(lexeme) {
    col = 1;
    row++;
    setToken('LineTerminator');
    return "LineTerminator";
  });

}).call(this);
