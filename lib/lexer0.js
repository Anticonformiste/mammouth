// Generated by CoffeeScript 1.9.3
(function() {
  var KEYWORDS, Lexer, REGEX, collect,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.setInput = function(input) {
      this.yytext = '';
      this.Track = {
        position: {
          row: 1,
          col: 0
        },
        into: {
          array: false,
          call: false,
          mammouth: false
        },
        indent: [
          {
            indentStack: [],
            currentIndent: -1,
            openedIndent: 0
          }
        ]
      };
      this.Tokens = [];
      this.pos = 0;
      this.input = input = input.replace(/\r\n/g, '\n');
      this.inputLength = input.length;
      return this.lexed = false;
    };

    Lexer.prototype.addToken = function(tokens) {
      var j, len, token;
      if (tokens instanceof Array) {
        for (j = 0, len = tokens.length; j < len; j++) {
          token = tokens[j];
          this.Tokens.push(token);
        }
      } else {
        this.Tokens.push(tokens);
      }
      return tokens;
    };

    Lexer.prototype.posAdvance = function(string, incPos) {
      var i, j, len, line, lines, results;
      if (incPos == null) {
        incPos = true;
      }
      if (incPos) {
        this.pos += string.length;
      }
      lines = string.split(REGEX.LINETERMINATOR);
      results = [];
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        if (i === 0) {
          results.push(this.Track.position.col += string.length);
        } else {
          this.Track.position.row++;
          results.push(this.Track.position.col = line.length);
        }
      }
      return results;
    };

    Lexer.prototype.colAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      return this.Track.position.col += num;
    };

    Lexer.prototype.rowAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      this.Track.position.row += num;
      return this.Track.position.col = 0;
    };

    Lexer.prototype.getPos = function() {
      return JSON.parse(JSON.stringify(this.Track.position));
    };

    Lexer.prototype.last = function(num) {
      if (num == null) {
        num = 1;
      }
      if (this.Tokens[this.Tokens.length - num]) {
        return this.Tokens[this.Tokens.length - num];
      }
      return void 0;
    };

    Lexer.prototype.next = function(num) {
      var lexer;
      if (num == null) {
        num = 1;
      }
      lexer = new Lexer;
      lexer.yyloc = this.yyloc;
      lexer.Track = JSON.parse(JSON.stringify(this.Track));
      lexer.Tokens = JSON.parse(JSON.stringify(this.Tokens));
      lexer.pos = this.pos;
      lexer.input = this.input;
      lexer.inputLength = this.inputLength;
      lexer.name = 2;
      while (num > 0) {
        lexer.nextToken();
        num--;
      }
      return lexer.Tokens[lexer.Tokens.length - 1];
    };

    Lexer.prototype.charCode = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.charCodeAt(pos);
    };

    Lexer.prototype.lex = function() {
      var token;
      if (!this.lexed) {
        this.tokenize();
      }
      token = this.Tokens.shift();
      if (token) {
        this.yytext = token.value ? token.value : '';
        this.yylloc = {
          first_column: token.loc.start.col,
          first_line: token.loc.start.row,
          last_line: token.loc.end.row,
          last_column: token.loc.end.col
        };
        return token.type;
      }
    };

    Lexer.prototype.tokenize = function() {
      var m;
      m = 0;
      while (m !== void 0) {
        m = this.nextToken();
      }
      this.rewrite();
      this.lexed = true;
      return this.Tokens;
    };

    Lexer.prototype.nextToken = function() {
      if (this.pos === this.inputLength) {
        return void 0;
      }
      if (!this.Track.into.mammouth) {
        return this.readTokenRAW();
      }
      if (this.isStartTag()) {
        return this.readTokenStartTag();
      }
      if (this.isEndTag()) {
        return this.readTokenEndTag();
      }
      if (this.last().type === 'LINETERMINATOR' && this.isEmptyLines()) {
        return this.skipEmptyLines();
      }
      if (this.last().type === 'LINETERMINATOR' && this.isIndent()) {
        this.Tokens.pop();
        return this.readIndent();
      }
      if (this.isIdentifier()) {
        return this.readTokenIdentifier();
      }
      if (this.isNumber()) {
        return this.readTokenNumber();
      }
      if (this.isString()) {
        return this.readTokenString();
      }
      return this.getTokenFromCode(this.charCode());
    };

    Lexer.prototype.readTokenRAW = function() {
      var startPos, token, value;
      token = this.newToken();
      startPos = this.pos;
      while (this.pos < this.inputLength && !this.isStartTag()) {
        this.pos++;
      }
      if (this.isStartTag()) {
        this.Track.into.mammouth = true;
      }
      value = this.input.slice(startPos, this.pos);
      this.posAdvance(value, false);
      token.loc.end = this.getPos();
      return this.addToken(collect({
        type: 'RAW',
        value: value
      }, token));
    };

    Lexer.prototype.readTokenStartTag = function() {
      var token;
      token = this.newToken();
      this.colAdvance(2);
      token.loc.end = this.getPos();
      return this.addToken(collect({
        type: '{{'
      }, token));
    };

    Lexer.prototype.readTokenEndTag = function() {
      var token, tokens;
      token = this.newToken();
      this.colAdvance(2);
      token.loc.end = this.getPos();
      tokens = [
        collect({
          type: '}}'
        }, token)
      ];
      tokens = this.closeIndent(0, token).concat(tokens);
      this.Track.into.mammouth = false;
      return this.addToken(tokens);
    };

    Lexer.prototype.readIndent = function() {
      var indent, indentLevel, j, len, reversed, token, tokens;
      token = this.newToken();
      indent = this.input.slice(this.pos).match(REGEX.INDENT)[0];
      this.colAdvance(indent.length);
      token.loc.end = this.getPos();
      if (indent.length > this.Track.indent[0].currentIndent) {
        this.Track.indent[0].currentIndent = indent.length;
        this.Track.indent[0].openedIndent++;
        this.Track.indent[0].indentStack.push({
          length: indent.length
        });
        return this.addToken(collect({
          type: 'INDENT',
          length: indent.length
        }, token));
      } else if (indent.length === this.Track.indent[0].currentIndent) {
        return this.addToken(collect({
          type: 'MINDENT',
          length: indent.length
        }, token));
      } else {
        tokens = [];
        reversed = this.reversedIndentStack();
        for (j = 0, len = reversed.length; j < len; j++) {
          indentLevel = reversed[j];
          if (indent.length === indentLevel.length) {
            this.Track.indent[0].currentIndent = indent.length;
            tokens.push(collect({
              type: 'MINDENT',
              length: indent.length
            }, token));
          } else if (indent.length < indentLevel.length) {
            this.Track.indent[0].currentIndent = this.Track.indent[0].indentStack.pop().length;
            this.Track.indent[0].openedIndent--;
            tokens.push(collect({
              type: 'OUTDENT',
              value: indentLevel.length
            }, token));
          }
        }
        return this.addToken(tokens);
      }
    };

    Lexer.prototype.readTokenIdentifier = function() {
      var length, ref, ref1, res, token, value;
      token = this.newToken();
      value = this.input.slice(this.pos).match(REGEX.IDENTIFIER)[0];
      this.colAdvance(value.length);
      token.loc.end = this.getPos();
      if (ref = value.toUpperCase(), indexOf.call(KEYWORDS.BOOL, ref) >= 0) {
        return this.addToken(collect({
          type: 'BOOL',
          value: value
        }, token));
      }
      if (indexOf.call(KEYWORDS.LOGIC, value) >= 0) {
        return this.addToken(collect({
          type: 'LOGIC',
          value: value === 'and' ? '&&' : value === 'or' ? '||' : value
        }, token));
      }
      if (indexOf.call(KEYWORDS.COMPARE, value) >= 0) {
        return this.addToken(collect({
          type: 'COMPARE',
          value: value === 'is' ? '===' : value === 'isnt' ? '!=' : value
        }, token));
      }
      if (this.last().type === '=>' && indexOf.call(KEYWORDS.CASTTYPE, value) >= 0) {
        return this.addToken(collect({
          type: 'CASTTYPE',
          value: value
        }, token));
      }
      if (indexOf.call(KEYWORDS.RESERVED, value) >= 0) {
        if ((value === 'if' || value === 'unless') && !((ref1 = this.last().type) === 'INDENT' || ref1 === 'MINDENT' || ref1 === 'OUTDENT' || ref1 === '(' || ref1 === 'CALL_START' || ref1 === ',')) {
          return this.addToken(collect({
            type: 'POST_IF',
            value: value === 'if' ? false : true
          }, token));
        }
        if (value === 'if' || value === 'unless') {
          return this.addToken(collect({
            type: 'IF',
            value: value === 'if' ? false : true
          }, token));
        }
        if (value === 'then') {
          length = this.Track.indent[0].currentIndent + 1;
          this.Track.indent[0].currentIndent = length;
          this.Track.indent[0].openedIndent++;
          this.Track.indent[0].indentStack.push({
            length: length,
            sensible: true
          });
          return this.addToken(collect({
            type: 'INDENT',
            length: length
          }, token));
        }
        if (value === 'else') {
          res = this.closeSensibleIndent(0, token);
          if (res[0] === true) {
            return this.addToken(res[1].concat(collect({
              type: value.toUpperCase()
            }, token)));
          }
        }
        return this.addToken(collect({
          type: value.toUpperCase()
        }, token));
      }
      if (indexOf.call(KEYWORDS.PHPRESERVED, value) >= 0) {
        return this.addToken(collect({
          type: 'UNEXPECTED',
          value: value
        }, token));
      }
      return this.addToken(collect({
        type: 'IDENTIFIER',
        value: value
      }, token));
    };

    Lexer.prototype.readTokenNumber = function() {
      var token, value;
      token = this.newToken();
      value = this.input.slice(this.pos).match(REGEX.NUMBER)[0];
      this.colAdvance(value.length);
      token.loc.end = this.getPos();
      return this.addToken(collect({
        type: 'NUMBER',
        value: value
      }, token));
    };

    Lexer.prototype.readTokenString = function() {
      var token, value;
      token = this.newToken();
      value = this.input.slice(this.pos).match(REGEX.STRING)[0];
      this.posAdvance(value);
      token.loc.end = this.getPos();
      return this.addToken(collect({
        type: 'STRING',
        value: value
      }, token));
    };

    Lexer.prototype.getTokenFromCode = function(code) {
      var length, next, ref, token, tokens;
      token = this.newToken();
      switch (code) {
        case 10:
        case 13:
        case 8232:
          return this.readLineTerminator();
        case 32:
        case 160:
        case 5760:
        case 6158:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
          this.colAdvance();
          return this.nextToken();
        case 33:
          this.colAdvance();
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'COMPARE',
              value: '!='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: 'NOT'
          }, token));
        case 37:
          this.colAdvance();
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'ASSIGN',
              value: '%='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: '%'
          }, token));
        case 38:
          this.colAdvance();
          switch (this.charCode()) {
            case 61:
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: 'ASSIGN',
                value: '&='
              }, token));
            case 38:
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: 'LOGIC',
                value: '&&'
              }, token));
            default:
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: '&'
              }, token));
          }
          break;
        case 40:
          this.colAdvance();
          token.loc.end = this.getPos();
          this.addIndentLevel();
          if ((ref = this.last().type, indexOf.call(KEYWORDS.CALLABLE, ref) >= 0) && this.last(2).type !== 'FUNC') {
            this.Track.into.call = true;
            return this.addToken(collect({
              type: 'CALL_START'
            }, token));
          }
          return this.addToken(collect({
            type: '('
          }, token));
        case 41:
          this.colAdvance();
          token.loc.end = this.getPos();
          if (this.Track.into.call === true) {
            this.Track.into.call = false;
            tokens = [
              collect({
                type: 'CALL_END'
              }, token)
            ];
            tokens = this.closeIndent(0, token).concat(tokens);
            this.closeIndentLevel();
            return this.addToken(tokens);
          }
          tokens = [
            collect({
              type: ')'
            }, token)
          ];
          tokens = this.closeIndent(0, token).concat(tokens);
          this.closeIndentLevel();
          return this.addToken(tokens);
        case 42:
          this.colAdvance();
          switch (this.charCode()) {
            case 42:
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: '**'
              }, token));
            case 61:
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: 'ASSIGN',
                value: '*='
              }, token));
            default:
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: '*'
              }, token));
          }
          break;
        case 43:
          this.colAdvance();
          switch (this.charCode()) {
            case 43:
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: '++'
              }, token));
            case 61:
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: 'ASSIGN',
                value: '+='
              }, token));
            default:
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: '+'
              }, token));
          }
          break;
        case 44:
          this.colAdvance();
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: ','
          }, token));
        case 45:
          this.colAdvance();
          switch (this.charCode()) {
            case 45:
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: '--'
              }, token));
            case 61:
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: 'ASSIGN',
                value: '-='
              }, token));
            case 62:
              this.colAdvance();
              token.loc.end = this.getPos();
              tokens = [
                collect({
                  type: '->'
                }, token)
              ];
              next = this.next(2).type;
              if (next !== 'INDENT') {
                if (next === 'MINDENT' || next === 'OUTDENT' || next === 'LINETERMINATOR') {
                  tokens.push(collect({
                    type: 'INDENT',
                    length: this.Track.indent[0].currentIndent + 1
                  }, token));
                  tokens.push(collect({
                    type: 'OUTDENT',
                    length: this.Track.indent[0].currentIndent + 1
                  }, token));
                } else {
                  length = this.Track.indent[0].currentIndent + 1;
                  this.Track.indent[0].currentIndent = length;
                  this.Track.indent[0].openedIndent++;
                  this.Track.indent[0].indentStack.push({
                    length: length
                  });
                  tokens.push(collect({
                    type: 'INDENT',
                    length: length
                  }, token));
                }
              }
              return this.addToken(tokens);
            default:
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: '-'
              }, token));
          }
          break;
        case 46:
          this.colAdvance();
          if (this.charCode() === 46) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: '..'
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: '.'
          }, token));
        case 47:
          this.colAdvance();
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'ASSIGN',
              value: '/='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: '/'
          }, token));
        case 58:
          this.colAdvance();
          if (this.charCode() === 58) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: '::'
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: ':'
          }, token));
        case 60:
          this.colAdvance();
          if (this.charCode() === 60) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: 'ASSIGN',
                value: '<<='
              }, token));
            }
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'BITWISE',
              value: '<<'
            }, token));
          }
          if (this.charCode() === 45 && this.charCode(this.pos + 1) === 62) {
            this.colAdvance(2);
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'CONCAT'
            }, token));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'COMPARE',
              value: '<='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: 'COMPARE',
            value: '<'
          }, token));
        case 61:
          this.colAdvance();
          if (this.charCode() === 62) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: '=>'
            }, token));
          }
          if (this.charCode() === 61 && this.charCode(this.pos + 1) === 61) {
            this.colAdvance(2);
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'COMPARE',
              value: '==='
            }, token));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'COMPARE',
              value: '=='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: '='
          }, token));
        case 62:
          this.colAdvance();
          if (this.charCode() === 62) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: 'ASSIGN',
                value: '>>='
              }, token));
            }
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'BITWISE',
              value: '>>'
            }, token));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'COMPARE',
              value: '>='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: 'COMPARE',
            value: '>'
          }, token));
        case 63:
          this.colAdvance();
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: '?'
          }, token));
        case 64:
          this.colAdvance();
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: '@'
          }, token));
        case 91:
          this.colAdvance();
          this.addIndentLevel();
          this.Track.into.array = true;
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: '['
          }, token));
        case 93:
          this.colAdvance();
          token.loc.end = this.getPos();
          this.Track.into.array = false;
          tokens = [
            collect({
              type: ']'
            }, token)
          ];
          tokens = this.closeIndent(0, token).concat(tokens);
          this.closeIndentLevel();
          return this.addToken(tokens);
        case 94:
          this.colAdvance();
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'ASSIGN',
              value: '^='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: 'BITWISE',
            value: '^'
          }, token));
        case 96:
          this.colAdvance();
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: '`'
          }, token));
        case 124:
          this.colAdvance();
          if (this.charCode() === 124) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'BITWISE',
              value: '||'
            }, token));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'ASSIGN',
              value: '|='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: 'BITWISE',
            value: '|'
          }, token));
        case 126:
          this.colAdvance();
          if (this.charCode() === 126) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              token.loc.end = this.getPos();
              return this.addToken(collect({
                type: 'ASSIGN',
                value: '.='
              }, token));
            }
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'CONCAT'
            }, token));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            token.loc.end = this.getPos();
            return this.addToken(collect({
              type: 'ASSIGN',
              value: '.='
            }, token));
          }
          token.loc.end = this.getPos();
          return this.addToken(collect({
            type: 'CONCAT'
          }, token));
      }
    };

    Lexer.prototype.readLineTerminator = function() {
      var ref, token;
      token = this.newToken();
      this.rowAdvance();
      if ((ref = this.charCode()) === 10 || ref === 13 || ref === 8232) {
        return this.readLineTerminator();
      }
      token.loc.end = this.getPos();
      return this.addToken(collect({
        type: 'LINETERMINATOR'
      }, token));
    };

    Lexer.prototype.skipEmptyLines = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.EMPTYLINE)[0];
      this.posAdvance(value);
      return this.nextToken();
    };

    Lexer.prototype.isStartTag = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      if (this.pos + 1 > this.inputLength - 1) {
        return false;
      }
      return this.charCode(pos) === 123 && this.charCode(this.pos + 1) === 123;
    };

    Lexer.prototype.isEndTag = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      if (this.pos + 1 > this.inputLength - 1) {
        return false;
      }
      return this.charCode(pos) === 125 && this.charCode(this.pos + 1) === 125;
    };

    Lexer.prototype.isEmptyLines = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.EMPTYLINE) !== null;
    };

    Lexer.prototype.isIdentifier = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.IDENTIFIER) !== null;
    };

    Lexer.prototype.isIndent = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.INDENT) !== null && this.last().type !== 'INDENT';
    };

    Lexer.prototype.isNumber = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.NUMBER) !== null;
    };

    Lexer.prototype.isString = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.STRING) !== null;
    };

    Lexer.prototype.rewrite = function() {
      var i, j, len, ref, ref1, results, token;
      ref = this.Tokens;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        token = ref[i];
        if (token) {
          if (token.type === 'MINDENT' && this.Tokens[i + 1] && ((ref1 = this.Tokens[i + 1].type) === 'CATCH' || ref1 === 'ELSE' || ref1 === 'FINALLY')) {
            results.push(this.Tokens.splice(i, 1));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Lexer.prototype.newToken = function() {
      return {
        loc: {
          start: this.getPos()
        }
      };
    };

    Lexer.prototype.addIndentLevel = function() {
      return this.Track.indent.unshift({
        indentStack: [],
        currentIndent: -1,
        openedIndent: 0
      });
    };

    Lexer.prototype.closeIndentLevel = function() {
      return this.Track.indent.shift();
    };

    Lexer.prototype.reversedIndentStack = function(level) {
      var i, j, len, ref, reversed;
      if (level == null) {
        level = 0;
      }
      reversed = [];
      ref = this.Track.indent[level].indentStack;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        reversed.unshift(i);
      }
      return reversed;
    };

    Lexer.prototype.closeIndent = function(level, posTok) {
      var ref, reversed, tokens;
      if (level == null) {
        level = 0;
      }
      if (posTok == null) {
        posTok = {};
      }
      tokens = [];
      reversed = this.reversedIndentStack();
      while (this.Track.indent[level].openedIndent) {
        if ((ref = this.last().type) === 'LINETERMINAROR' || ref === 'MINDENT') {
          this.Tokens.pop();
        }
        tokens.unshift(collect({
          type: 'OUTDENT',
          length: reversed[this.Track.indent[0].openedIndent - 1].length
        }, posTok));
        this.Track.indent[0].openedIndent--;
      }
      if (this.last().type === 'LINETERMINATOR') {
        this.Tokens.pop();
      }
      return tokens;
    };

    Lexer.prototype.closeSensibleIndent = function(level, posTok) {
      var length, res;
      if (level == null) {
        level = 0;
      }
      if (posTok == null) {
        posTok = 0;
      }
      res = [false];
      if (this.Track.indent[level].indentStack[this.Track.indent[level].indentStack.length - 1] && this.Track.indent[level].indentStack[this.Track.indent[level].indentStack.length - 1].sensible === true) {
        (res[0] = true) && (res.push([]));
        length = this.Track.indent[0].indentStack.pop().length - 1;
        this.Track.indent[0].currentIndent = length;
        this.Track.indent[0].openedIndent--;
        res[1].push(collect({
          type: 'OUTDENT',
          length: length
        }, posTok));
      }
      return res;
    };

    return Lexer;

  })();

  collect = function() {
    var j, key, len, object, ret, value;
    ret = {};
    for (j = 0, len = arguments.length; j < len; j++) {
      object = arguments[j];
      for (key in object) {
        value = object[key];
        ret[key] = value;
      }
    }
    return ret;
  };

  REGEX = {
    EMPTYLINE: /(^[\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]*[\n\r\u2028\u2029])/,
    IDENTIFIER: /((^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    INDENT: /(^[ \t]*)/,
    LINETERMINATOR: /[\n\r\u2028]/,
    NUMBER: /^(0b[01]+|0o[0-7]+|0(x|X)[\da-fA-F]+|\d*\.?\d+(?:(e|E)[+-]?\d+)?)/,
    STRING: /^('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/
  };

  KEYWORDS = {
    CALLABLE: ['CALL_END', 'IDENTIFIER', ')', ']', '?', '@'],
    BOOL: ['TRUE', 'FALSE'],
    CASTTYPE: ['array', 'binary', 'bool', 'boolean', 'double', 'int', 'integer', 'float', 'object', 'real', 'string', 'unset'],
    COMPARE: ['is', 'isnt'],
    LOGIC: ['and', 'or', 'xor'],
    RESERVED: ['catch', 'clone', 'const', 'cte', 'else', 'finally', 'func', 'if', 'in', 'instanceof', 'loop', 'new', 'not', 'null', 'then', 'try', 'unless', 'until', 'use', 'when', 'while'],
    PHPRESERVED: ['abstract', 'and', 'array', 'as', 'break', 'callable', 'case', 'catch', 'class', 'clone', 'const', 'continue', 'declare', 'default', 'die', 'do', 'echo', 'else', 'elseif', 'empty', 'enddeclare', 'endfor', 'endforeach', 'endif', 'endswitch', 'endwhile', 'eval', 'exit', 'extends', 'final', 'finally', 'for', 'foreach', 'function', 'global', 'goto', 'if', 'implements', 'include', 'include_once', 'instanceof', 'insteadof', 'interface', 'isset', 'list', 'namespace', 'new', 'or', 'print', 'private', 'protected', 'public', 'require', 'require_once', 'return', 'static', 'switch', 'throw', 'trait', 'try', 'unset', 'use', 'var', 'while']
  };

  module.exports = new Lexer;

}).call(this);
