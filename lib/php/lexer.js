// Generated by CoffeeScript 1.9.3
(function() {
  var KEYWORDS, Lexer, Position, REGEX, Token, errorAt,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  errorAt = require('../utils').errorAt;

  Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.setInput = function(input) {
      this.yytext = '';
      this.track = {
        position: new Position,
        into: {
          php: false
        },
        opened: []
      };
      this.tokens = [];
      this.pos = 0;
      return this.input = input.replace(/\r\n/g, '\n');
    };

    Lexer.prototype.addToken = function(tokens) {
      var j, len, ref, token;
      if (tokens instanceof Array) {
        for (j = 0, len = tokens.length; j < len; j++) {
          token = tokens[j];
          if ((ref = token.type) === 'INDENT' || ref === 'MINDENT' || ref === 'LINETERMINATOR') {
            this.track.into["for"] = false;
          }
          this.tokens.push(token);
        }
      } else {
        this.tokens.push(tokens);
      }
      return tokens;
    };

    Lexer.prototype.getPos = function() {
      return this.track.position.clone();
    };

    Lexer.prototype.posAdvance = function(string, incPos) {
      var i, j, len, line, lines, results;
      if (incPos == null) {
        incPos = true;
      }
      if (incPos) {
        this.pos += string.length;
      }
      lines = string.split(REGEX.LINETERMINATOR);
      results = [];
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        if (i === 0) {
          results.push(this.track.position.col += string.length);
        } else {
          this.track.position.row++;
          results.push(this.track.position.col = line.length);
        }
      }
      return results;
    };

    Lexer.prototype.colAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      return this.track.position.col += num;
    };

    Lexer.prototype.rowAdvance = function(num) {
      if (num == null) {
        num = 1;
      }
      this.pos += num;
      this.track.position.row += num;
      return this.track.position.col = 0;
    };

    Lexer.prototype.last = function(num) {
      if (num == null) {
        num = 1;
      }
      if (this.tokens[this.tokens.length - num]) {
        return this.tokens[this.tokens.length - num];
      }
      return void 0;
    };

    Lexer.prototype.next = function(num) {
      var lexer;
      if (num == null) {
        num = 1;
      }
      lexer = new Lexer;
      lexer.track = JSON.parse(JSON.stringify(this.track));
      lexer.track.position = this.track.position.clone();
      lexer.tokens = JSON.parse(JSON.stringify(this.tokens));
      lexer.pos = this.pos;
      lexer.input = this.input;
      while (num > 0) {
        lexer.nextToken();
        num--;
      }
      return lexer.tokens[lexer.tokens.length - 1];
    };

    Lexer.prototype.charCode = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.charCodeAt(pos);
    };

    Lexer.prototype.lex = function() {
      var token;
      if (!this.lexed) {
        this.tokenize();
      }
      token = this.tokens.shift();
      if (token) {
        this.yytext = token.value ? token.value : '';
        this.yylloc = {
          first_column: token.location.start.col,
          first_line: token.location.start.row,
          last_line: token.location.end.row,
          last_column: token.location.end.col
        };
        return token.type;
      }
    };

    Lexer.prototype.tokenize = function() {
      var m;
      m = 0;
      while (m !== void 0) {
        m = this.nextToken();
      }
      this.lexed = true;
      return this.tokens;
    };

    Lexer.prototype.nextToken = function() {
      if (this.pos === this.input.length) {
        return void 0;
      }
      if (!this.track.into.php) {
        return this.readTokenRAW();
      }
      if (this.isStartTag()) {
        return this.readTokenStartTag();
      }
      if (this.isEndTag()) {
        return this.readTokenEndTag();
      }
      if (this.isComment()) {
        return this.skipComment();
      }
      if (this.isVariable()) {
        return this.readTokenVariable();
      }
      if (this.isName()) {
        return this.readTokenName();
      }
      if (this.isNumber()) {
        return this.readTokenNumber();
      }
      if (this.isString()) {
        return this.readTokenString();
      }
      return this.getTokenFromCode(this.charCode());
    };

    Lexer.prototype.readTokenRAW = function() {
      var startPos, token, value;
      token = (new Token('RAW')).setStart(this.getPos());
      startPos = this.pos;
      while (this.pos < this.input.length && !this.isStartTag()) {
        this.pos++;
      }
      if (this.isStartTag()) {
        this.track.into.php = true;
      }
      value = this.input.slice(startPos, this.pos);
      this.posAdvance(value, false);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenStartTag = function() {
      var token, value;
      token = (new Token('STARTTAG')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.STARTTAG)[0];
      this.colAdvance(value.length);
      this.track.opened.unshift({
        type: 'STARTTAG',
        closableBy: 'ENDTAG'
      });
      return this.addToken(token.setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenEndTag = function() {
      var token, tokens;
      token = (new Token('ENDTAG')).setStart(this.getPos());
      this.colAdvance(2);
      token.setEnd(this.getPos());
      this.track.into.php = false;
      tokens = [token];
      if (this.track.opened[0].type === 'STARTTAG') {
        this.track.opened.shift();
      }
      return this.addToken(tokens);
    };

    Lexer.prototype.readTokenVariable = function() {
      var token, value;
      token = (new Token('VARIABLENAME')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.VARIABLE)[0];
      this.posAdvance(value);
      return this.addToken(token.set('value', value.slice(1)).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenName = function() {
      var ref, ref1, token, value;
      token = (new Token).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.NAME)[0];
      this.posAdvance(value);
      if ((ref = value.toUpperCase()) === 'TRUE' || ref === 'FALSE') {
        return this.addToken(token.set('type', 'BOOL').set('value', value).setEnd(this.getPos()));
      }
      if (ref1 = value.toLowerCase(), indexOf.call(KEYWORDS.PHPRESERVED, ref1) >= 0) {
        return this.addToken(token.set('type', value.toUpperCase()).setEnd(this.getPos()));
      }
      return this.addToken(token.set('type', 'NAME').set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenNumber = function() {
      var token, value;
      token = (new Token('NUMBER')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.NUMBER)[0];
      this.colAdvance(value.length);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.readTokenString = function() {
      var token, value;
      token = (new Token('STRING')).setStart(this.getPos());
      value = this.input.slice(this.pos).match(REGEX.STRING)[0];
      this.posAdvance(value);
      return this.addToken(token.set('value', value).setEnd(this.getPos()));
    };

    Lexer.prototype.getTokenFromCode = function(code) {
      var startPos, token;
      startPos = this.getPos();
      token = (new Token).setStart(startPos);
      this.colAdvance();
      switch (code) {
        case 10:
        case 13:
        case 8232:
          this.colAdvance(-1);
          this.rowAdvance();
          return this.nextToken();
        case 32:
        case 160:
        case 5760:
        case 6158:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
          return this.nextToken();
        case 33:
          if (this.charCode() === 61) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'COMPARE').set('value', '!==').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'COMPARE').set('value', '!=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '!').setEnd(this.getPos()));
        case 36:
          return this.addToken(token.set('type', '$').setEnd(this.getPos()));
        case 37:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '%=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '%').setEnd(this.getPos()));
        case 38:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '&=').setEnd(this.getPos()));
          }
          if (this.charCode() === 38) {
            this.colAdvance();
            return this.addToken(token.set('type', 'LOGIC').set('value', '&&').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '&').setEnd(this.getPos()));
        case 40:
          return this.addToken(token.set('type', '(').setEnd(this.getPos()));
        case 41:
          return this.addToken(token.set('type', ')').setEnd(this.getPos()));
        case 42:
          if (this.charCode() === 42) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '**=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', '**').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '*=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '*').setEnd(this.getPos()));
        case 43:
          if (this.charCode() === 43) {
            this.colAdvance();
            return this.addToken(token.set('type', '++').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '+=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '+').setEnd(this.getPos()));
        case 44:
          return this.addToken(token.set('type', ',').setEnd(this.getPos()));
        case 45:
          if (this.charCode() === 62) {
            this.colAdvance();
            return this.addToken(token.set('type', '->').setEnd(this.getPos()));
          }
          if (this.charCode() === 45) {
            this.colAdvance();
            return this.addToken(token.set('type', '--').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '-=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '-').setEnd(this.getPos()));
        case 46:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '.=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '.').setEnd(this.getPos()));
        case 47:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '/=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '/').setEnd(this.getPos()));
        case 58:
          if (this.charCode() === 58) {
            this.colAdvance();
            return this.addToken(token.set('type', '::').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', ':').setEnd(this.getPos()));
        case 59:
          return this.addToken(token.set('type', ';').setEnd(this.getPos()));
        case 60:
          if (this.charCode() === 60) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '<<=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'BITWISE').set('value', '<<').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'COMPARE').set('value', '<=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'COMPARE').set('value', '<').setEnd(this.getPos()));
        case 61:
          if (this.charCode() === 61) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'COMPARE').set('value', '===').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'COMPARE').set('value', '==').setEnd(this.getPos()));
          }
          if (this.charCode() === 38) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '=&').setEnd(this.getPos()));
          }
          if (this.charCode() === 62) {
            this.colAdvance();
            return this.addToken(token.set('type', '=>').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', '=').setEnd(this.getPos()));
        case 62:
          if (this.charCode() === 62) {
            this.colAdvance();
            if (this.charCode() === 61) {
              this.colAdvance();
              return this.addToken(token.set('type', 'ASSIGN').set('value', '>>=').setEnd(this.getPos()));
            }
            return this.addToken(token.set('type', 'BITWISE').set('value', '>>').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'COMPARE').set('value', '>=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'COMPARE').set('value', '>').setEnd(this.getPos()));
        case 63:
          return this.addToken(token.set('type', '?').setEnd(this.getPos()));
        case 91:
          return this.addToken(token.set('type', '[').setEnd(this.getPos()));
        case 92:
          return this.addToken(token.set('type', 'BS').setEnd(this.getPos()));
        case 93:
          return this.addToken(token.set('type', ']').setEnd(this.getPos()));
        case 94:
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '^=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'BITWISE').set('value', '^').setEnd(this.getPos()));
        case 123:
          return this.addToken(token.set('type', '{').setEnd(this.getPos()));
        case 124:
          if (this.charCode() === 124) {
            this.colAdvance();
            return this.addToken(token.set('type', 'BITWISE').set('value', '||').setEnd(this.getPos()));
          }
          if (this.charCode() === 61) {
            this.colAdvance();
            return this.addToken(token.set('type', 'ASSIGN').set('value', '|=').setEnd(this.getPos()));
          }
          return this.addToken(token.set('type', 'BITWISE').set('value', '|').setEnd(this.getPos()));
        case 125:
          return this.addToken(token.set('type', '}').setEnd(this.getPos()));
        case 126:
          return this.addToken(token.set('type', '~').setEnd(this.getPos()));
      }
    };

    Lexer.prototype.skipComment = function() {
      var value;
      value = this.input.slice(this.pos).match(REGEX.COMMENT)[0];
      this.posAdvance(value);
      return this.nextToken();
    };

    Lexer.prototype.isStartTag = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.STARTTAG) !== null;
    };

    Lexer.prototype.isEndTag = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.ENDTAG) !== null;
    };

    Lexer.prototype.isComment = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.COMMENT) !== null;
    };

    Lexer.prototype.isVariable = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.VARIABLE) !== null;
    };

    Lexer.prototype.isName = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.NAME) !== null;
    };

    Lexer.prototype.isNumber = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.NUMBER) !== null;
    };

    Lexer.prototype.isString = function(pos) {
      if (pos == null) {
        pos = this.pos;
      }
      return this.input.slice(pos).match(REGEX.STRING) !== null;
    };

    return Lexer;

  })();

  Token = (function() {
    function Token(type, location, obj) {
      var key, value;
      this.type = type != null ? type : null;
      this.location = location != null ? location : {};
      if (obj == null) {
        obj = {};
      }
      for (key in obj) {
        value = obj[key];
        this[key] = value;
      }
      if (this.location === null) {
        delete this.location;
      }
    }

    Token.prototype.set = function(key, value) {
      this[key] = value;
      return this;
    };

    Token.prototype.get = function(key) {
      return this[key];
    };

    Token.prototype.setStart = function(value) {
      this.location.start = value;
      return this;
    };

    Token.prototype.setEnd = function(value) {
      this.location.end = value;
      return this;
    };

    Token.prototype.clone = function() {
      var k, token, v;
      token = new Token;
      for (k in this) {
        v = this[k];
        token.set(k, v);
      }
      return token;
    };

    return Token;

  })();

  Position = (function() {
    function Position(row, col) {
      this.row = row != null ? row : 1;
      this.col = col != null ? col : 0;
    }

    Position.prototype.clone = function() {
      return new Position(this.row, this.col);
    };

    Position.from = function(pos) {
      return new Position(pos.row || 1, pos.col || 0);
    };

    return Position;

  })();

  REGEX = {
    COMMENT: /^\/\*([\s\S]*?)(?:\*\/[^\n\S]*|\*\/$)|^(?:\s*\/\/(.*)+)|^(?:\s*\#(.*)+)/,
    LINETERMINATOR: /[\n\r\u2028]/,
    STARTTAG: /^<\?php|^<\?=/,
    ENDTAG: /^\?>/,
    NAME: /((^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/,
    NUMBER: /^(0b[01]+|0o[0-7]+|0(x|X)[\da-fA-F]+|\d*\.?\d+(?:(e|E)[+-]?\d+)?)/,
    STRING: /^('[^\\']*(?:\\[\s\S][^\\']*)*'|"[^\\"]*(?:\\[\s\S][^\\"]*)*")/,
    VARIABLE: /((^\$[A-Za-z_\x7f-\uffff][\w\x7f-\uffff]*)( [^\n\S]* : (?!:) )?)/
  };

  KEYWORDS = {
    PHPRESERVED: ['abstract', 'and', 'array', 'as', 'break', 'callable', 'case', 'catch', 'class', 'clone', 'const', 'continue', 'declare', 'default', 'do', 'echo', 'else', 'elseif', 'empty', 'enddeclare', 'endfor', 'endforeach', 'endif', 'endswitch', 'endwhile', 'extends', 'final', 'finally', 'for', 'foreach', 'function', 'global', 'goto', 'if', 'implements', 'include', 'include_once', 'instanceof', 'insteadof', 'interface', 'namespace', 'new', 'null', 'or', 'print', 'private', 'protected', 'public', 'require', 'require_once', 'return', 'static', 'switch', 'throw', 'trait', 'try', 'unset', 'use', 'var', 'while']
  };

  module.exports = new Lexer;

}).call(this);
