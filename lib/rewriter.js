// Generated by CoffeeScript 1.7.1
(function() {
  var SuperMammouth, helpers, nodes;

  nodes = require('./nodes');

  helpers = require('./helpers');

  SuperMammouth = "\nfunction mammouth($func, $arg1, $arg2){if ( $func == '+' ){if((is_string($arg1) && is_numeric($arg2))||(is_string($arg2) && is_numeric($arg1))) {return $arg1.$arg2;} else {return $arg1+$arg2;}}}\n";

  exports.rewrite = function(tree, context) {
    var ADD, AddSuperMammouth, IdCounter, UseSuperMammouth, code, compile, doc, php, _i, _len;
    IdCounter = new helpers.IdCounter;
    UseSuperMammouth = false;
    AddSuperMammouth = false;
    php = '';
    ADD = function(string) {
      return php += string;
    };
    compile = function(element) {
      var ID, InElement, Scase, arg, elem, elsei, expression, ext, i, key, line, lr, node, parameter, propertie, r, value, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u;
      switch (element.type) {
        case 'Block':
          if (element.nodes[element.nodes.length - 1].type === 'BlankLine') {
            element.nodes.pop();
          }
          if (element.nodes.length === 1 && element.nodes[0].type === 'Expression') {
            r = ' ' + compile(element.nodes[0]) + ' ';
            return r;
          } else {
            r = '';
            _ref = element.nodes;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              node = _ref[i];
              r += compile(node);
              if (i !== element.nodes.length - 1) {
                r += '\n';
              }
            }
            return '\n' + r + '\n';
          }
          break;
        case 'Expression':
          return compile(element.expression) + ';';
        case 'Value':
          if (element.properties.length > 0) {
            r = compile(element.value);
            _ref1 = element.properties;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              propertie = _ref1[_j];
              switch (propertie.method) {
                case '->':
                case '.':
                  r += "->" + propertie.value.name;
                  break;
                case '::':
                case '..':
                  r += '::' + propertie.value.name;
                  break;
                case '[]':
                  r += '[' + compile(propertie.value) + ']';
              }
            }
            return r;
          } else {
            return compile(element.value);
          }
          break;
        case 'Parens':
          return '(' + compile(element.expression) + ')';
        case 'Identifier':
          if (element.as_arguments) {
            r = '$' + element.name;
          } else {
            r = context.Identify(element.name);
          }
          if (element.passing) {
            r = '&' + r;
          }
          return r;
        case 'Literal':
          if (typeof element.value === 'number') {
            return element.value;
          } else {
            return element.value;
          }
          break;
        case 'Bool':
          if (element.value) {
            return 'TRUE';
          } else {
            return 'FALSE';
          }
          break;
        case 'Null':
          return 'NULL';
        case 'Array':
          r = 'array(';
          _ref2 = element.elements;
          for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
            elem = _ref2[i];
            if (elem.type === 'ArrayKey') {
              r += compile(elem.key) + ' => ' + compile(elem.value);
            } else {
              r += compile(elem);
            }
            if (i !== element.elements.length - 1) {
              r += ', ';
            }
          }
          r += ')';
          return r;
        case 'Call':
          r = compile(element.variable) + '(';
          _ref3 = element["arguments"];
          for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
            arg = _ref3[i];
            r += compile(arg);
            if (i !== element["arguments"].length - 1) {
              r += ', ';
            }
          }
          r += ')';
          return r;
        case 'NewCall':
          r = 'new ' + compile(element.variable);
          if (element["arguments"] !== false) {
            r += '(';
            _ref4 = element["arguments"];
            for (i = _m = 0, _len4 = _ref4.length; _m < _len4; i = ++_m) {
              arg = _ref4[i];
              r += compile(arg);
              if (i !== element["arguments"].length - 1) {
                r += ', ';
              }
            }
            r += ')';
          }
          return r;
        case 'Code':
          if (element.normal) {
            r = 'function ' + element.name + '(';
            context.push({
              name: element.name,
              type: 'function'
            });
          } else {
            r = 'function(';
          }
          _ref5 = element.parameters;
          for (i = _n = 0, _len5 = _ref5.length; _n < _len5; i = ++_n) {
            parameter = _ref5[i];
            if (parameter.and === true) {
              r += '&' + compile(parameter);
            } else {
              r += compile(parameter);
            }
            if (i !== element.parameters.length - 1) {
              r += ', ';
            }
          }
          r += ')';
          if (element.body !== false) {
            r += ' {';
            r += compile(element.body);
            r += '}';
          } else {
            r += ';';
          }
          return r;
        case 'Casting':
          if (element.foreach === true) {
            return compile(new nodes.Identifier(element.typec)) + ' => ' + compile(element.variable);
          } else {
            return '(' + element.typec + ') ' + compile(element.variable);
          }
          break;
        case 'Exec':
          return '`' + element.code + '`';
        case 'HereDoc':
          return '<<<EOT\n' + element.doc + '\nEOT';
        case 'Clone':
          return 'clone ' + compile(element.value);
        case 'Operation':
          if (element.operator === '**') {
            r = 'pow(' + compile(element.left) + ', ' + compile(element.right) + ')';
          } else if (element.operator === 'and') {
            r = compile(element.left) + ' & ' + compile(element.right);
          } else if (element.operator === 'or') {
            r = compile(element.left) + ' or ' + compile(element.right);
          } else if (element.operator === '<->') {
            r = compile(element.left) + '.' + compile(element.right);
          } else if (element.operator === '+') {
            UseSuperMammouth = true;
            r = 'mammouth("+", ' + compile(element.left) + ', ' + compile(element.right) + ')';
          } else {
            r = compile(element.left) + ' ' + element.operator + ' ' + compile(element.right);
          }
          return r;
        case 'Assign':
          r = compile(element.left) + ' ' + element.operator + ' ' + compile(element.right);
          return r;
        case 'GetKeyAssign':
          r = '';
          _ref6 = element.keys;
          for (i = _o = 0, _len6 = _ref6.length; _o < _len6; i = ++_o) {
            key = _ref6[i];
            value = new nodes.Value(element.source.value);
            value.add(new nodes.Access(new nodes.Literal('"' + key.name + '"'), '[]'));
            if (i !== (element.keys.length - 1)) {
              r += compile(new nodes.Expression(new nodes.Assign("=", key, value)));
              r += '\n';
            } else {
              r += compile(new nodes.Assign("=", key, value));
            }
          }
          return r;
        case 'Constant':
          context.push({
            name: element.left.name,
            type: 'cte'
          });
          return 'const ' + compile(element.left) + ' = ' + compile(element.right);
        case 'Unary':
          r = element.operator;
          r += compile(element.expression);
          return r;
        case 'Update':
          r = compile(element.expression);
          r = !element.prefix ? r + element.operator : element.operator + r;
          return r;
        case 'Existence':
          r = 'isset(' + compile(element.expression) + ')';
          return r;
        case 'In':
          r = 'in_array(' + compile(element.left) + ', ' + compile(element.right) + ')';
          return r;
        case 'Echo':
          return 'echo ' + compile(element.value);
        case 'Delete':
          return 'unset(' + compile(element.value) + ')';
        case 'Include':
          if (element.once) {
            r = 'include_once ';
          } else {
            r = 'include ';
          }
          r += compile(element.path);
          return r;
        case 'Require':
          if (element.once) {
            r = 'require_once ';
          } else {
            r = 'require ';
          }
          r += compile(element.path);
          return r;
        case 'Break':
          r = 'break';
          if (element.arg !== false) {
            r += ' ' + compile(element.arg);
          }
          return r;
        case 'Continue':
          r = 'continue';
          if (element.arg !== false) {
            r += ' ' + compile(element.arg);
          }
          return r;
        case 'Return':
          return 'return ' + compile(element.value);
        case 'Declare':
          r = 'declare(' + compile(element.expression) + ')';
          if (element.script !== false) {
            r += ' {';
            r += compile(element.script);
            r += '}';
          }
          return r;
        case 'Goto':
          return 'goto ' + element.section;
        case 'If':
          if (element.as_expression) {
            r = compile(element.condition) + ' ? ' + compile(element.body);
            if (element.Elses === false) {
              r += ' : NULL';
            } else {
              r += ' : ' + compile(element.Elses);
            }
            return r;
          } else {
            r = 'if(' + compile(element.condition) + ') {';
            r += compile(element.body);
            r += '}';
            _ref7 = element.Elses;
            for (_p = 0, _len7 = _ref7.length; _p < _len7; _p++) {
              elsei = _ref7[_p];
              if (elsei.type === 'Else') {
                r += ' else {';
                r += compile(elsei.body);
                r += '}';
              } else if (elsei.type === 'ElseIf') {
                r += ' elseif(' + compile(elsei.condition) + ') {';
                r += compile(elsei.body);
                r += '}';
              }
            }
            return r;
          }
          break;
        case 'While':
          r = 'while(' + compile(element.test) + ') {';
          r += compile(element.body);
          r += '}';
          return r;
        case 'DoWhile':
          r = 'do {';
          r += compile(element.body);
          r += '} while (' + compile(element.test) + ');';
          return r;
        case 'Try':
          r = 'try {';
          r += compile(element.TryBody);
          r += '}';
          r += ' catch(Exception ' + compile(element.CatchIdentifier) + ') {';
          r += compile(element.CatchBody);
          r += '}';
          if (element.Finally) {
            r += ' finally {';
            r += compile(element.FinallyBody);
            r += '}';
          }
          return r;
        case 'Switch':
          r = 'switch (' + compile(element.variable) + ') {\n';
          _ref8 = element.cases;
          for (_q = 0, _len8 = _ref8.length; _q < _len8; _q++) {
            Scase = _ref8[_q];
            if (Scase.type === 'When') {
              r += 'case ' + compile(Scase.condition) + ': {';
              Scase.body.nodes.push(new nodes.Expression(new nodes.Break));
              r += compile(Scase.body);
              r += '}';
            } else if (Scase.type === 'SwitchElse') {
              r += 'default: {';
              r += compile(Scase.body);
              r += '}';
            }
            r += '\n';
          }
          r += '}';
          return r;
        case 'For':
          if (element.method === 'normal' && element.expressions.length > 1) {
            r = 'for(';
            _ref9 = element.expressions;
            for (i = _r = 0, _len9 = _ref9.length; _r < _len9; i = ++_r) {
              expression = _ref9[i];
              if (expression.type === 'In') {
                expression.each = true;
              }
              r += compile(expression);
              if (i !== element.expressions.length) {
                r += '; ';
              }
            }
            r += ') {';
            r += compile(element.body);
            r += '}';
          } else if (element.method === 'normal' && element.expressions.length === 1 && element.expressions[0].type === 'In') {
            InElement = element.expressions[0];
            r = 'for(';
            ID = IdCounter.get();
            r += compile(ID) + ' = 0; ';
            r += compile(ID) + ' < count(' + compile(InElement.right) + '); ';
            r += compile(ID) + '++';
            r += ') {';
            element.body.nodes.unshift(new nodes.Expression(new nodes.Assign('=', InElement.left, new nodes.Value(InElement.right, [new nodes.Access(ID, '[]')]))));
            r += compile(element.body);
            r += '}';
          } else if (element.method === 'foreach') {
            r = 'foreach(';
            r += compile(element.left);
            r += ' as ';
            r += compile(element.right);
            r += ') {';
            r += compile(element.body);
            r += '}';
          }
          return r;
        case 'Section':
          return element.name + ':';
        case 'Class':
          r = 'class ' + element.name;
          context.push({
            name: element.name,
            type: 'class'
          });
          if (element.abstract === true) {
            r = 'abstract ' + r;
          }
          if (element.extendable !== false) {
            r += ' extends ' + element.extendable;
          }
          if (element.implement !== false) {
            r += ' implements ' + element.implement;
          }
          r += ' {\n';
          _ref10 = element.body;
          for (i = _s = 0, _len10 = _ref10.length; _s < _len10; i = ++_s) {
            line = _ref10[i];
            lr = '';
            if (line.visibility !== false) {
              lr += line.visibility + ' ';
            }
            if (line.statically !== false) {
              lr += line.statically + ' ';
            }
            lr += compile(line.element);
            if (line.finaly === true) {
              lr = 'final ' + lr;
            }
            if (line.abstract === true) {
              lr = 'abstract ' + lr;
            }
            r += lr;
            if (i !== (element.body.length - 1)) {
              r += '\n';
            }
          }
          r += '\n}';
          return r;
        case 'Interface':
          r = 'interface ' + element.name;
          context.push({
            name: element.name,
            type: 'interface'
          });
          if (element.extendable !== false) {
            r += ' extends ';
            _ref11 = element.extendable;
            for (i = _t = 0, _len11 = _ref11.length; _t < _len11; i = ++_t) {
              ext = _ref11[i];
              r += ext;
              if (i !== (element.extendable.length - 1)) {
                r += ', ';
              }
            }
          }
          r += ' {\n';
          _ref12 = element.body;
          for (i = _u = 0, _len12 = _ref12.length; _u < _len12; i = ++_u) {
            line = _ref12[i];
            lr = '';
            if (line.type === 'Code') {
              lr += 'public ' + compile(line);
            } else {
              lr += compile(line);
            }
            r += lr;
            if (i !== (element.body.length - 1)) {
              r += '\n';
            }
          }
          return r += '\n}';
        case 'Namespace':
          r = 'namespace ' + element.name;
          if (element.body !== false) {
            r += ' {';
            r += compile(element.body);
            r += '}';
          }
          return r;
        case 'NamespaceRef':
          return element.path;
      }
    };
    for (_i = 0, _len = tree.length; _i < _len; _i++) {
      doc = tree[_i];
      switch (doc.type) {
        case 'PlainBlock':
          ADD(doc.toPHP());
          break;
        case 'MammouthBlock':
          code = compile(doc.body);
          if (UseSuperMammouth && !AddSuperMammouth) {
            code = SuperMammouth + code;
            AddSuperMammouth = true;
            UseSuperMammouth = false;
          }
          ADD('<?php' + code + '?>');
      }
    }
    return php;
  };

}).call(this);
