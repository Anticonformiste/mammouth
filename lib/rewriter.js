// Generated by CoffeeScript 1.7.1
(function() {
  exports.rewrite = function(tree, context) {
    var ADD, UseSuperMammouth, compile, doc, php, _i, _len;
    UseSuperMammouth = false;
    php = '';
    ADD = function(string) {
      return php += string;
    };
    compile = function(element) {
      var Scase, arg, cte, elem, elsei, i, node, parameter, propertie, r, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      switch (element.type) {
        case 'Block':
          if (element.nodes[element.nodes.length - 1].type === 'BlankLine') {
            element.nodes.pop();
          }
          if (element.nodes.length === 1 && element.nodes[0].type === 'Expression') {
            r = ' ' + compile(element.nodes[0]) + ' ';
            return r;
          } else {
            r = '';
            _ref = element.nodes;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              node = _ref[i];
              r += compile(node);
              if (i !== element.nodes.length - 1) {
                r += '\n';
              }
            }
            return '\n' + r + '\n';
          }
          break;
        case 'Expression':
          return compile(element.expression) + ';';
        case 'Value':
          if (element.properties.length > 0) {
            r = compile(element.value);
            _ref1 = element.properties;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              propertie = _ref1[_j];
              switch (propertie.method) {
                case '->':
                case '.':
                  r += "->" + propertie.value.name;
                  break;
                case '::':
                case '..':
                  r += '::' + propertie.value.name;
                  break;
                case '[]':
                  r += '[' + compile(propertie.value) + ']';
              }
            }
            return r;
          } else {
            return compile(element.value);
          }
          break;
        case 'Parens':
          return '(' + compile(element.expression) + ')';
        case 'Identifier':
          if (element.as_arguments) {
            r = '$' + element.name;
          } else {
            r = context.Identify(element.name);
          }
          if (element.passing) {
            r = '&' + r;
          }
          return r;
        case 'Literal':
          if (typeof element.value === 'number') {
            return element.value;
          } else {
            return element.value;
          }
          break;
        case 'Bool':
          if (element.value) {
            return 'true';
          } else {
            return 'false';
          }
          break;
        case 'Array':
          r = 'array(';
          _ref2 = element.elements;
          for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
            elem = _ref2[i];
            if (elem.type === 'ArrayKey') {
              r += compile(elem.key) + ' => ' + compile(elem.value);
            } else {
              r += compile(elem);
            }
            if (i !== element.elements.length - 1) {
              r += ', ';
            }
          }
          r += ')';
          return r;
        case 'Call':
          r = compile(element.variable) + '(';
          _ref3 = element["arguments"];
          for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
            arg = _ref3[i];
            r += compile(arg);
            if (i !== element["arguments"].length - 1) {
              r += ', ';
            }
          }
          r += ')';
          return r;
        case 'Code':
          if (element.normal) {
            r = 'function ' + element.name + '(';
            context.elements[element.name] = {
              'type': 'function'
            };
          } else {
            r = 'function(';
          }
          _ref4 = element.parameters;
          for (i = _m = 0, _len4 = _ref4.length; _m < _len4; i = ++_m) {
            parameter = _ref4[i];
            if (parameter.and === true) {
              r += '&' + compile(parameter);
            } else {
              r += compile(parameter);
            }
            if (i !== element.parameters.length - 1) {
              r += ', ';
            }
          }
          r += ') {';
          r += compile(element.body);
          r += '}';
          return r;
        case 'Operation':
          if (element.operator === '**') {
            r = 'pow(' + compile(element.left) + ', ' + compile(element.right) + ')';
          } else if (element.operator === 'and') {
            r = compile(element.left) + ' & ' + compile(element.right);
          } else if (element.operator === 'or') {
            r = compile(element.left) + ' or ' + compile(element.right);
          } else if (element.operator === '<->') {
            r = compile(element.left) + '.' + compile(element.right);
          } else if (element.operator === '+') {
            UseSuperMammouth = true;
            r = '$Mammouth("+", ' + compile(element.left) + ', ' + compile(element.right) + ')';
          } else {
            r = compile(element.left) + ' ' + element.operator + ' ' + compile(element.right);
          }
          return r;
        case 'Assign':
          if (element.operator === '=') {
            context.Assign(element.left, element.right);
          }
          r = compile(element.left) + ' ' + element.operator + ' ' + compile(element.right);
          return r;
        case 'Constant':
          cte = context.Add(element.left);
          cte.type = 'cte';
          return 'define("' + compile(element.left) + '", ' + compile(element.right) + ')';
        case 'Unary':
          r = element.operator;
          r += compile(element.expression);
          return r;
        case 'Update':
          r = compile(element.expression);
          r = !element.prefix ? r + element.operator : element.operator + r;
          return r;
        case 'Existence':
          r = 'isset(' + compile(element.expression) + ')';
          return r;
        case 'In':
          r = '$Mammouth("in_array", ' + compile(element.left) + ', ' + compile(element.right) + ')';
          return r;
        case 'If':
          r = 'if(' + compile(element.condition) + ') {';
          r += compile(element.body);
          r += '}';
          _ref5 = element.Elses;
          for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
            elsei = _ref5[_n];
            if (elsei.type === 'Else') {
              r += ' else {';
              r += compile(elsei.body);
              r += '}';
            } else if (elsei.type === 'ElseIf') {
              r += ' elseif(' + compile(elsei.condition) + ') {';
              r += compile(elsei.body);
              r += '}';
            }
          }
          return r;
        case 'While':
          r = 'while(' + compile(element.test) + ') {';
          r += compile(element.body);
          r += '}';
          return r;
        case 'Try':
          r = 'try {';
          r += compile(element.TryBody);
          r += '}';
          r += ' catch(Exception ' + compile(element.CatchIdentifier) + ') {';
          r += compile(element.CatchBody);
          r += '}';
          if (element.Finally) {
            r += ' finally {';
            r += compile(element.FinallyBody);
            r += '}';
          }
          return r;
        case 'Switch':
          r = 'switch (' + compile(element.variable) + ') {\n';
          _ref6 = element.cases;
          for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
            Scase = _ref6[_o];
            if (Scase.type === 'When') {
              r += 'case ' + compile(Scase.condition) + ': {';
              r += compile(Scase.body);
              r += '}';
            } else if (Scase.type === 'SwitchElse') {
              r += 'default: {';
              r += compile(Scase.body);
              r += '}';
            }
            r += '\n';
          }
          r += '}';
          return r;
      }
    };
    for (_i = 0, _len = tree.length; _i < _len; _i++) {
      doc = tree[_i];
      switch (doc.type) {
        case 'PlainBlock':
          ADD(doc.toPHP());
          break;
        case 'MammouthBlock':
          ADD('<?php' + compile(doc.body) + '?>');
      }
    }
    return php;
  };

}).call(this);
